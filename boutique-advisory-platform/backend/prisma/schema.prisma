// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Multi-tenant support
model Tenant {
  id          String   @id @default(cuid())
  name        String
  domain      String?  @unique
  settings    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]
  smes        SME[]
  investors   Investor[]
  advisors    Advisor[]
  deals       Deal[]
  workflows   Workflow[]
  documents   Document[]
  notifications Notification[]
  pushSubscriptions PushSubscription[]
  conversations Conversation[]
  matches       Match[]
  payments      Payment[]
  disputes      Dispute[]
  activityLogs  ActivityLog[]

  @@map("tenants")
}

// User management with multi-tenancy
model User {
  id          String   @id @default(cuid())
  tenantId    String
  email       String
  password    String
  firstName   String
  lastName    String
  role        UserRole
  status      UserStatus @default(ACTIVE)
  language    Language  @default(EN)
  did         String?   // DID from existing infrastructure
  resetToken       String?
  resetTokenExpiry DateTime?
  
  // Two-Factor Authentication
  twoFactorSecret      String?
  twoFactorEnabled     Boolean   @default(false)
  twoFactorBackupCodes String[]  @default([])

  // Email Verification
  isEmailVerified      Boolean   @default(false)
  verificationToken    String?
  verificationTokenExpiry DateTime?
  preferences          Json      @default("{}")

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sme         SME?     @relation("SMEUser")
  investor    Investor? @relation("InvestorUser")
  advisor     Advisor? @relation("AdvisorUser")
  notifications Notification[]
  pushSubscriptions PushSubscription[]
  messageParticipants ConversationParticipant[]
  sentMessages      Message[]
  bookings          Booking[]
  matchInterests    MatchInterest[]
  payments          Payment[]
  initiatedDisputes Dispute[] @relation("DisputeInitiator")
  resolvedDisputes  Dispute[] @relation("DisputeResolver")
  activityLogs      ActivityLog[]
  agreementSignatures AgreementSigner[]

  @@unique([tenantId, email])
  @@map("users")
}

// SME Module
model SME {
  id                String   @id @default(cuid())
  tenantId          String
  userId            String   @unique
  name              String
  sector            String
  stage             SMEStage
  fundingRequired   Float
  description       String?
  website           String?
  location          String?
  score             Float?   @default(0)
  certified         Boolean  @default(false)
  certificationDate DateTime?
  status            SMEStatus @default(DRAFT)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user              User     @relation("SMEUser", fields: [userId], references: [id], onDelete: Cascade)
  documents         Document[]
  deals             Deal[]
  certifications    Certification[]
  workflows         Workflow[]
  dueDiligences     DueDiligence[]  // New: Due diligence assessments
  matches           Match[]

  @@map("smes")
}

// Investor Module
model Investor {
  id              String   @id @default(cuid())
  tenantId        String
  userId          String   @unique
  name            String
  type            InvestorType
  kycStatus       KYCStatus @default(PENDING)
  status          InvestorStatus @default(ACTIVE)
  preferences     Json     @default("{}")
  portfolio       Json     @default("[]")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user            User     @relation("InvestorUser", fields: [userId], references: [id], onDelete: Cascade)
  dealInvestments DealInvestor[]
  workflows       Workflow[]
  leadSyndicates  Syndicate[]       @relation("LeadInvestor")  // New: Syndicates led
  syndicateMemberships SyndicateMember[]  // New: Syndicate memberships
  secondaryListings    SecondaryListing[] @relation("ListingSeller")
  tradesAsBuyer        SecondaryTrade[] @relation("TradeBuyer")
  tradesAsSeller       SecondaryTrade[] @relation("TradeSeller")
  matches              Match[]
  
  // Token Trading
  tokenListings        SyndicateTokenListing[]
  tokenTradesAsBuyer   SyndicateTokenTrade[] @relation("TokenTradeBuyer")
  tokenTradesAsSeller  SyndicateTokenTrade[] @relation("TokenTradeSeller")

  @@map("investors")
}

// Advisor Module
model Advisor {
  id              String   @id @default(cuid())
  tenantId        String
  userId          String   @unique
  name            String
  specialization  String[]
  certificationList String[]
  status          AdvisorStatus @default(ACTIVE)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user            User     @relation("AdvisorUser", fields: [userId], references: [id], onDelete: Cascade)
  certifications  Certification[]
  workflows       Workflow[]
  dueDiligences   DueDiligence[]  // New: Due diligence conducted
  services        AdvisoryService[]
  bookings        Booking[]

  @@map("advisors")
}

// Deal Room / Matchmaking
model Deal {
  id              String   @id @default(cuid())
  tenantId        String
  smeId           String
  title           String
  description     String?
  amount          Float
  equity          Float?
  status          DealStatus @default(DRAFT)
  successFee      Float?
  terms           String?
  isDocumentLocked Boolean    @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sme             SME      @relation(fields: [smeId], references: [id], onDelete: Cascade)
  investors       DealInvestor[]
  documents       Document[]
  workflows       Workflow[]
  syndicates      Syndicate[]  // New: Syndicates for this deal
  conversations   Conversation[]
  disputes        Dispute[]
  dueDiligenceItems DueDiligenceItem[]
  escrowAccount   EscrowAccount?
  agreements      Agreement[]

  @@map("deals")
}

// Many-to-many relationship between Deal and Investor
model DealInvestor {
  id          String   @id @default(cuid())
  dealId      String
  investorId  String
  amount      Float
  status      InvestmentStatus @default(PENDING)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  deal        Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)
  investor    Investor @relation(fields: [investorId], references: [id], onDelete: Cascade)
  secondaryListings SecondaryListing[]
  payments      Payment[]

  @@unique([dealId, investorId])
  @@map("deal_investors")
}

// Document Management
model Document {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  type        DocumentType
  url         String
  size        Int
  mimeType    String
  smeId       String?
  dealId      String?
  uploadedBy  String
  
  accessLevel AccessLevel @default(QUALIFIED)
  isLocked    Boolean     @default(false)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sme         SME?     @relation(fields: [smeId], references: [id], onDelete: Cascade)
  deal        Deal?    @relation(fields: [dealId], references: [id], onDelete: Cascade)

  @@map("documents")
}

// Certification Workflow
model Certification {
  id          String   @id @default(cuid())
  smeId       String
  advisorId   String
  status      CertificationStatus @default(PENDING)
  score       Float?
  comments    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sme         SME      @relation(fields: [smeId], references: [id], onDelete: Cascade)
  advisor     Advisor  @relation(fields: [advisorId], references: [id], onDelete: Cascade)

  @@map("certifications")
}

// Workflow Management (integrated with DID workflow engine)
model Workflow {
  id          String   @id @default(cuid())
  tenantId    String
  type        WorkflowType
  status      WorkflowStatus @default(PENDING)
  data        Json     @default("{}")
  smeId       String?
  investorId  String?
  advisorId   String?
  dealId      String?
  didWorkflowId String? // Reference to DID workflow engine
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sme         SME?     @relation(fields: [smeId], references: [id], onDelete: Cascade)
  investor    Investor? @relation(fields: [investorId], references: [id], onDelete: Cascade)
  advisor     Advisor? @relation(fields: [advisorId], references: [id], onDelete: Cascade)
  deal        Deal?    @relation(fields: [dealId], references: [id], onDelete: Cascade)

  @@map("workflows")
}

// ==================== NEW FEATURES ====================

// Investor Syndicate (like AngelList)
model Syndicate {
  id              String   @id @default(cuid())
  tenantId        String
  name            String
  description     String?
  leadInvestorId  String
  targetAmount    Float
  minInvestment   Float    @default(1000)
  maxInvestment   Float?
  managementFee   Float    @default(2.0)  // Percentage
  carryFee        Float    @default(20.0) // Percentage of profits
  
  // Tokenization
  isTokenized     Boolean  @default(false)
  tokenName       String?
  tokenSymbol     String?
  pricePerToken   Float?
  totalTokens     Float?
  tokensSold      Float    @default(0)

  status          SyndicateStatus @default(FORMING)
  dealId          String?
  closingDate     DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  leadInvestor    Investor @relation("LeadInvestor", fields: [leadInvestorId], references: [id])
  deal            Deal?    @relation(fields: [dealId], references: [id])
  members         SyndicateMember[]
  tokenListings   SyndicateTokenListing[]

  @@map("syndicates")
}

model SyndicateMember {
  id            String   @id @default(cuid())
  syndicateId   String
  investorId    String
  amount        Float
  tokens        Float?   @default(0) // Number of tokens owned
  status        SyndicateMemberStatus @default(PENDING)
  joinedAt      DateTime @default(now())
  
  // Relations
  syndicate     Syndicate @relation(fields: [syndicateId], references: [id], onDelete: Cascade)
  investor      Investor  @relation(fields: [investorId], references: [id], onDelete: Cascade)

  @@unique([syndicateId, investorId])
  @@map("syndicate_members")
}

model SyndicateTokenListing {
  id              String   @id @default(cuid())
  syndicateId     String
  sellerId        String   
  
  tokensAvailable Float
  pricePerToken   Float
  minTokens       Float    @default(1)
  
  status          ListingStatus @default(ACTIVE)
  listedAt        DateTime @default(now())
  expiresAt       DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  syndicate       Syndicate @relation(fields: [syndicateId], references: [id])
  seller          Investor  @relation(fields: [sellerId], references: [id])
  trades          SyndicateTokenTrade[]

  @@map("syndicate_token_listings")
}

model SyndicateTokenTrade {
  id              String   @id @default(cuid())
  listingId       String
  buyerId         String
  sellerId        String
  
  tokens          Float
  pricePerToken   Float
  totalAmount     Float
  fee             Float    @default(0)
  
  status          TradeStatus @default(PENDING)
  executedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  listing         SyndicateTokenListing @relation(fields: [listingId], references: [id])
  buyer           Investor              @relation("TokenTradeBuyer", fields: [buyerId], references: [id])
  seller          Investor              @relation("TokenTradeSeller", fields: [sellerId], references: [id])

  @@map("syndicate_token_trades")
}

// Due Diligence Scoring (like OurCrowd)
model DueDiligence {
  id              String   @id @default(cuid())
  smeId           String
  advisorId       String?
  
  // Scoring Categories (0-100)
  financialScore      Float    @default(0)
  teamScore           Float    @default(0)
  marketScore         Float    @default(0)
  productScore        Float    @default(0)
  legalScore          Float    @default(0)
  operationalScore    Float    @default(0)
  
  // Overall calculated score
  overallScore        Float    @default(0)
  riskLevel           RiskLevel @default(MEDIUM)
  
  // Detailed assessments
  strengths           String[]
  weaknesses          String[]
  recommendations     String[]
  redFlags            String[]
  
  status              AssessmentStatus @default(PENDING)
  completedAt         DateTime?
  expiresAt           DateTime?
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  sme                 SME      @relation(fields: [smeId], references: [id], onDelete: Cascade)
  advisor             Advisor? @relation(fields: [advisorId], references: [id])

  @@map("due_diligences")
}

// Community Features (like Wefunder)
model CommunityPost {
  id              String   @id @default(cuid())
  tenantId        String
  authorId        String
  title           String
  content         String
  category        PostCategory @default(GENERAL)
  
  // Related entities (optional)
  smeId           String?
  dealId          String?
  syndicateId     String?
  
  // Engagement
  likes           Int      @default(0)
  views           Int      @default(0)
  isPinned        Boolean  @default(false)
  isAnnouncement  Boolean  @default(false)
  
  status          PostStatus @default(PUBLISHED)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  comments        Comment[]

  @@map("community_posts")
}

model Comment {
  id              String   @id @default(cuid())
  postId          String
  authorId        String
  content         String
  parentId        String?  // For nested comments
  likes           Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  post            CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent          Comment?      @relation("CommentReplies", fields: [parentId], references: [id])
  replies         Comment[]     @relation("CommentReplies")

  @@map("comments")
}

// Secondary Trading (like StartEngine)
model SecondaryListing {
  id              String   @id @default(cuid())
  tenantId        String
  sellerId        String
  dealInvestorId  String   // Original investment
  
  // Listing details
  sharesAvailable Float
  pricePerShare   Float
  minPurchase     Float    @default(1)
  
  status          ListingStatus @default(ACTIVE)
  listedAt        DateTime @default(now())
  expiresAt       DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  seller          Investor      @relation("ListingSeller", fields: [sellerId], references: [id])
  dealInvestor    DealInvestor  @relation(fields: [dealInvestorId], references: [id])
  trades          SecondaryTrade[]

  @@map("secondary_listings")
}

// Escrow System
model EscrowAccount {
  id              String   @id @default(cuid())
  dealId          String   @unique
  tenantId        String
  
  balance         Float    @default(0)
  currency        String   @default("USD")
  status          EscrowStatus @default(OPEN)
  
  bankName        String?
  accountNumber   String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  deal            Deal     @relation(fields: [dealId], references: [id])
  transactions    EscrowTransaction[]

  @@map("escrow_accounts")
}

model EscrowTransaction {
  id              String   @id @default(cuid())
  escrowAccountId String
  tenantId        String
  
  amount          Float
  currency        String   @default("USD")
  type            EscrowTransactionType
  status          TransactionStatus @default(PENDING)
  
  reference       String?  // External reference (e.g. Stripe ID, Bank Tx ID)
  description     String?
  
  requestedBy     String   // User ID
  approvedBy      String?  // User ID (for release/refund)
  approvedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  escrowAccount   EscrowAccount @relation(fields: [escrowAccountId], references: [id])

  @@map("escrow_transactions")
}

enum EscrowStatus {
  OPEN
  LOCKED
  RELEASED
  REFUNDED
  DISPUTED
}

enum EscrowTransactionType {
  DEPOSIT
  RELEASE
  REFUND
  FEE
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

// Digital Signatures / Contracts
model Agreement {
  id          String   @id @default(cuid())
  dealId      String
  tenantId    String
  title       String
  content     String   @db.Text // HTML/Markdown contract content
  status      AgreementStatus @default(DRAFT)
  version     Int      @default(1)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  deal        Deal     @relation(fields: [dealId], references: [id])
  signers     AgreementSigner[]

  @@map("agreements")
}

model AgreementSigner {
  id          String   @id @default(cuid())
  agreementId String
  userId      String
  
  role        String   // e.g., "SME", "INVESTOR", "WITNESS"
  status      SigningStatus @default(PENDING)
  
  signedAt    DateTime?
  signature   String?  // Base64 Signature Image or Text
  ipAddress   String?  // Security Audit
  userAgent   String?  // Security Audit
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  agreement   Agreement @relation(fields: [agreementId], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@unique([agreementId, userId]) // One signature per user per agreement
  @@map("agreement_signers")
}

enum AgreementStatus {
  DRAFT
  PENDING_SIGNATURES
  COMPLETED
  CANCELLED
}

enum SigningStatus {
  PENDING
  SIGNED
  REJECTED
}

// Due Diligence Checklist
model DueDiligenceItem {
  id          String   @id @default(cuid())
  tenantId    String
  dealId      String

  task        String
  description String?
  status      ChecklistStatus @default(PENDING)
  assignedTo  String? 

  completedBy String?
  completedAt DateTime?

  order       Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  deal        Deal     @relation(fields: [dealId], references: [id])

  @@map("deal_checklist_items")
}

enum ChecklistStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  WAIVED
}

model SecondaryTrade {
  id              String   @id @default(cuid())
  listingId       String
  buyerId         String
  sellerId        String
  
  shares          Float
  pricePerShare   Float
  totalAmount     Float
  fee             Float    @default(0) // Platform fee
  
  status          TradeStatus @default(PENDING)
  executedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  listing         SecondaryListing @relation(fields: [listingId], references: [id])
  buyer           Investor         @relation("TradeBuyer", fields: [buyerId], references: [id])
  seller          Investor         @relation("TradeSeller", fields: [sellerId], references: [id])

  @@map("secondary_trades")
}

// Notification System
model Notification {
  id          String           @id @default(cuid())
  tenantId    String
  userId      String
  type        NotificationType
  title       String
  message     String
  read        Boolean          @default(false)
  actionUrl   String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  tenant      Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Enums
enum UserRole {
  SME
  INVESTOR
  ADVISOR
  ADMIN
  SUPER_ADMIN  // System operator with full system access
  SUPPORT      // Helpdesk support with read-only access
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

enum Language {
  EN
  KM
  ZH
}

enum SMEStage {
  SEED
  GROWTH
  EXPANSION
  MATURE
}

enum SMEStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  CERTIFIED
  REJECTED
  DELETED
}

enum InvestorType {
  ANGEL
  VENTURE_CAPITAL
  PRIVATE_EQUITY
  CORPORATE
  INSTITUTIONAL
}

enum KYCStatus {
  PENDING
  VERIFIED
  REJECTED
  UNDER_REVIEW
}

enum AdvisorStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

enum InvestorStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

enum DealStatus {
  DRAFT
  PUBLISHED
  NEGOTIATION
  DUE_DILIGENCE
  FUNDED
  CLOSED
  CANCELLED
}

enum InvestmentStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum DocumentType {
  PITCH_DECK
  FINANCIAL_STATEMENT
  BUSINESS_PLAN
  LEGAL_DOCUMENT
  OTHER
}

enum CertificationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum WorkflowType {
  SME_ONBOARDING
  SME_CERTIFICATION
  INVESTOR_ONBOARDING
  DEAL_APPROVAL
  KYC_VERIFICATION
}

enum WorkflowStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}

// ==================== NEW FEATURE ENUMS ====================

enum SyndicateStatus {
  FORMING
  OPEN
  CLOSED
  FUNDED
  DISSOLVED
}

enum SyndicateMemberStatus {
  PENDING
  APPROVED
  REJECTED
  WITHDRAWN
}

model Dispute {
  id          String   @id @default(cuid())
  tenantId    String
  dealId      String
  initiatorId String
  resolverId  String?
  
  reason      String
  description String
  status      DisputeStatus @default(OPEN)
  resolution  String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  deal        Deal     @relation(fields: [dealId], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  initiator   User     @relation("DisputeInitiator", fields: [initiatorId], references: [id])
  resolver    User?    @relation("DisputeResolver", fields: [resolverId], references: [id])

  @@map("disputes")
}

enum DisputeStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  REJECTED
}

enum AssessmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  EXPIRED
  WAIVED
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  VERY_HIGH
}

enum PostCategory {
  GENERAL
  ANNOUNCEMENT
  DEAL_UPDATE
  INVESTOR_INSIGHT
  SME_NEWS
  QUESTION
  SUCCESS_STORY
}

enum PostStatus {
  DRAFT
  PUBLISHED
  HIDDEN
  DELETED
}

enum ListingStatus {
  ACTIVE
  SOLD
  CANCELLED
  EXPIRED
}

enum TradeStatus {
  PENDING
  PROCESSING
  COMPLETED
  CANCELLED
  FAILED
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
  DEAL
  SYSTEM
  MATCH_FOUND
  INTEREST_RECEIVED
  DEAL_UPDATE
  DOCUMENT_UPLOADED
  MESSAGE_RECEIVED
  MEETING_REMINDER
}

// ==================== MESSAGING SYSTEM ====================

model Conversation {
  id        String   @id @default(cuid())
  tenantId  String
  dealId    String?
  
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  deal      Deal?    @relation(fields: [dealId], references: [id])
  messages  Message[]
  participants ConversationParticipant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  userId         String
  
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  lastReadAt     DateTime     @default(now())
  joinedAt       DateTime     @default(now())

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  type           String       @default("TEXT") // TEXT, IMAGE, FILE
  attachments    Json?        // [{ name, url, type, size }]
  read           Boolean      @default(false)
  
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@map("messages")
}

// Advisory Service (Offered by Advisors)
model AdvisoryService {
  id          String   @id @default(cuid())
  tenantId    String
  advisorId   String
  name        String
  category    String
  description String?
  price       Float
  duration    String   // e.g., "1 hour", "4 weeks"
  features    String[] // What's included
  status      String   @default("ACTIVE")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  advisor     Advisor  @relation(fields: [advisorId], references: [id], onDelete: Cascade)
  bookings    Booking[]

  @@map("advisory_services")
}

// Booking System
model Booking {
  id                String   @id @default(cuid())
  tenantId          String
  userId            String   // The client (User)
  advisorId         String?  // Optional if booking a specific service
  serviceId         String?  // Optional if booking a general session
  preferredDate     DateTime
  notes             String?
  status            BookingStatus @default(PENDING)
  amount            Float?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  advisor           Advisor?          @relation(fields: [advisorId], references: [id])
  service           AdvisoryService?  @relation(fields: [serviceId], references: [id])
  payments          Payment[]

  @@map("bookings")
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

model Match {
  id          String   @id @default(cuid())
  tenantId    String
  smeId       String
  investorId  String
  score       Int      // 0-100
  factors     Json?    // Details about the score calculation
  status      MatchStatus @default(PENDING)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sme         SME      @relation(fields: [smeId], references: [id], onDelete: Cascade)
  investor    Investor @relation(fields: [investorId], references: [id], onDelete: Cascade)
  interests   MatchInterest[]

  @@unique([smeId, investorId])
  @@map("matches")
}

model MatchInterest {
  id          String   @id @default(cuid())
  matchId     String
  userId      String   // User who expressed interest
  interest    Boolean  // true = like, false = dislike
  createdAt   DateTime @default(now())

  match       Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@map("match_interests")
}

enum MatchStatus {
  PENDING
  ADVISOR_VERIFIED
  REJECTED
}

model PushSubscription {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  endpoint  String
  keys      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@map("push_subscriptions")
}

// ==================== PAYMENT SYSTEM ====================

model Payment {
  id              String         @id @default(cuid())
  tenantId        String
  userId          String
  amount          Float
  currency        String         @default("USD")
  method          PaymentMethod
  provider        String         // "ABA", "STRIPE", etc.
  providerTxId    String?        // Transaction ID from the provider
  status          PaymentStatus  @default(PENDING)
  description     String?
  metadata        Json?          // Flexible JSON for provider-specific data (e.g. aba_hash)
  
  // Polymorphic-like associations (optional)
  dealInvestorId  String?
  bookingId       String?

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  tenant          Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  dealInvestment  DealInvestor? @relation(fields: [dealInvestorId], references: [id])
  booking         Booking?       @relation(fields: [bookingId], references: [id])

  @@map("payments")
}

enum PaymentMethod {
  CREDIT_CARD
  BANK_TRANSFER
  ABA_PAYWAY
  KHQR
  CASH
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

// Activity logging for security and auditing
model ActivityLog {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  action    String   // VIEWED, DOWNLOADED, UPLOADED, etc.
  entityId  String   // Document ID or Deal ID
  entityType String  // DOCUMENT, DEAL, etc.
  metadata  Json?    // Additional info (IP, Browser, etc.)
  timestamp DateTime @default(now())

  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("activity_logs")
}

enum AccessLevel {
  PUBLIC
  QUALIFIED
  CONFIDENTIAL
  ADMIN_ONLY
}
