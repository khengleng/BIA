
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SME
 * 
 */
export type SME = $Result.DefaultSelection<Prisma.$SMEPayload>
/**
 * Model Investor
 * 
 */
export type Investor = $Result.DefaultSelection<Prisma.$InvestorPayload>
/**
 * Model Advisor
 * 
 */
export type Advisor = $Result.DefaultSelection<Prisma.$AdvisorPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model DealInvestor
 * 
 */
export type DealInvestor = $Result.DefaultSelection<Prisma.$DealInvestorPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model Syndicate
 * 
 */
export type Syndicate = $Result.DefaultSelection<Prisma.$SyndicatePayload>
/**
 * Model SyndicateMember
 * 
 */
export type SyndicateMember = $Result.DefaultSelection<Prisma.$SyndicateMemberPayload>
/**
 * Model DueDiligence
 * 
 */
export type DueDiligence = $Result.DefaultSelection<Prisma.$DueDiligencePayload>
/**
 * Model CommunityPost
 * 
 */
export type CommunityPost = $Result.DefaultSelection<Prisma.$CommunityPostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model SecondaryListing
 * 
 */
export type SecondaryListing = $Result.DefaultSelection<Prisma.$SecondaryListingPayload>
/**
 * Model SecondaryTrade
 * 
 */
export type SecondaryTrade = $Result.DefaultSelection<Prisma.$SecondaryTradePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SME: 'SME',
  INVESTOR: 'INVESTOR',
  ADVISOR: 'ADVISOR',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN',
  SUPPORT: 'SUPPORT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Language: {
  EN: 'EN',
  KM: 'KM',
  ZH: 'ZH'
};

export type Language = (typeof Language)[keyof typeof Language]


export const SMEStage: {
  SEED: 'SEED',
  GROWTH: 'GROWTH',
  EXPANSION: 'EXPANSION',
  MATURE: 'MATURE'
};

export type SMEStage = (typeof SMEStage)[keyof typeof SMEStage]


export const SMEStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  CERTIFIED: 'CERTIFIED',
  REJECTED: 'REJECTED'
};

export type SMEStatus = (typeof SMEStatus)[keyof typeof SMEStatus]


export const InvestorType: {
  ANGEL: 'ANGEL',
  VENTURE_CAPITAL: 'VENTURE_CAPITAL',
  PRIVATE_EQUITY: 'PRIVATE_EQUITY',
  CORPORATE: 'CORPORATE',
  INSTITUTIONAL: 'INSTITUTIONAL'
};

export type InvestorType = (typeof InvestorType)[keyof typeof InvestorType]


export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const AdvisorStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type AdvisorStatus = (typeof AdvisorStatus)[keyof typeof AdvisorStatus]


export const DealStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  NEGOTIATION: 'NEGOTIATION',
  FUNDED: 'FUNDED',
  CLOSED: 'CLOSED',
  CANCELLED: 'CANCELLED'
};

export type DealStatus = (typeof DealStatus)[keyof typeof DealStatus]


export const InvestmentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type InvestmentStatus = (typeof InvestmentStatus)[keyof typeof InvestmentStatus]


export const DocumentType: {
  PITCH_DECK: 'PITCH_DECK',
  FINANCIAL_STATEMENT: 'FINANCIAL_STATEMENT',
  BUSINESS_PLAN: 'BUSINESS_PLAN',
  LEGAL_DOCUMENT: 'LEGAL_DOCUMENT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const CertificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type CertificationStatus = (typeof CertificationStatus)[keyof typeof CertificationStatus]


export const WorkflowType: {
  SME_ONBOARDING: 'SME_ONBOARDING',
  SME_CERTIFICATION: 'SME_CERTIFICATION',
  INVESTOR_ONBOARDING: 'INVESTOR_ONBOARDING',
  DEAL_APPROVAL: 'DEAL_APPROVAL',
  KYC_VERIFICATION: 'KYC_VERIFICATION'
};

export type WorkflowType = (typeof WorkflowType)[keyof typeof WorkflowType]


export const WorkflowStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]


export const SyndicateStatus: {
  FORMING: 'FORMING',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  FUNDED: 'FUNDED',
  DISSOLVED: 'DISSOLVED'
};

export type SyndicateStatus = (typeof SyndicateStatus)[keyof typeof SyndicateStatus]


export const SyndicateMemberStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type SyndicateMemberStatus = (typeof SyndicateMemberStatus)[keyof typeof SyndicateMemberStatus]


export const RiskLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  VERY_HIGH: 'VERY_HIGH'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const DueDiligenceStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type DueDiligenceStatus = (typeof DueDiligenceStatus)[keyof typeof DueDiligenceStatus]


export const PostCategory: {
  GENERAL: 'GENERAL',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  DEAL_UPDATE: 'DEAL_UPDATE',
  INVESTOR_INSIGHT: 'INVESTOR_INSIGHT',
  SME_NEWS: 'SME_NEWS',
  QUESTION: 'QUESTION',
  SUCCESS_STORY: 'SUCCESS_STORY'
};

export type PostCategory = (typeof PostCategory)[keyof typeof PostCategory]


export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  HIDDEN: 'HIDDEN',
  DELETED: 'DELETED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const ListingStatus: {
  ACTIVE: 'ACTIVE',
  SOLD: 'SOLD',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const TradeStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type TradeStatus = (typeof TradeStatus)[keyof typeof TradeStatus]


export const NotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  DEAL: 'DEAL',
  SYSTEM: 'SYSTEM',
  MATCH_FOUND: 'MATCH_FOUND',
  INTEREST_RECEIVED: 'INTEREST_RECEIVED',
  DEAL_UPDATE: 'DEAL_UPDATE',
  DOCUMENT_UPLOADED: 'DOCUMENT_UPLOADED',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  MEETING_REMINDER: 'MEETING_REMINDER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type SMEStage = $Enums.SMEStage

export const SMEStage: typeof $Enums.SMEStage

export type SMEStatus = $Enums.SMEStatus

export const SMEStatus: typeof $Enums.SMEStatus

export type InvestorType = $Enums.InvestorType

export const InvestorType: typeof $Enums.InvestorType

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type AdvisorStatus = $Enums.AdvisorStatus

export const AdvisorStatus: typeof $Enums.AdvisorStatus

export type DealStatus = $Enums.DealStatus

export const DealStatus: typeof $Enums.DealStatus

export type InvestmentStatus = $Enums.InvestmentStatus

export const InvestmentStatus: typeof $Enums.InvestmentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type CertificationStatus = $Enums.CertificationStatus

export const CertificationStatus: typeof $Enums.CertificationStatus

export type WorkflowType = $Enums.WorkflowType

export const WorkflowType: typeof $Enums.WorkflowType

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

export type SyndicateStatus = $Enums.SyndicateStatus

export const SyndicateStatus: typeof $Enums.SyndicateStatus

export type SyndicateMemberStatus = $Enums.SyndicateMemberStatus

export const SyndicateMemberStatus: typeof $Enums.SyndicateMemberStatus

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type DueDiligenceStatus = $Enums.DueDiligenceStatus

export const DueDiligenceStatus: typeof $Enums.DueDiligenceStatus

export type PostCategory = $Enums.PostCategory

export const PostCategory: typeof $Enums.PostCategory

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type TradeStatus = $Enums.TradeStatus

export const TradeStatus: typeof $Enums.TradeStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.sME`: Exposes CRUD operations for the **SME** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMES
    * const sMES = await prisma.sME.findMany()
    * ```
    */
  get sME(): Prisma.SMEDelegate<ExtArgs>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **Investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.InvestorDelegate<ExtArgs>;

  /**
   * `prisma.advisor`: Exposes CRUD operations for the **Advisor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advisors
    * const advisors = await prisma.advisor.findMany()
    * ```
    */
  get advisor(): Prisma.AdvisorDelegate<ExtArgs>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs>;

  /**
   * `prisma.dealInvestor`: Exposes CRUD operations for the **DealInvestor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DealInvestors
    * const dealInvestors = await prisma.dealInvestor.findMany()
    * ```
    */
  get dealInvestor(): Prisma.DealInvestorDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs>;

  /**
   * `prisma.syndicate`: Exposes CRUD operations for the **Syndicate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Syndicates
    * const syndicates = await prisma.syndicate.findMany()
    * ```
    */
  get syndicate(): Prisma.SyndicateDelegate<ExtArgs>;

  /**
   * `prisma.syndicateMember`: Exposes CRUD operations for the **SyndicateMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyndicateMembers
    * const syndicateMembers = await prisma.syndicateMember.findMany()
    * ```
    */
  get syndicateMember(): Prisma.SyndicateMemberDelegate<ExtArgs>;

  /**
   * `prisma.dueDiligence`: Exposes CRUD operations for the **DueDiligence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DueDiligences
    * const dueDiligences = await prisma.dueDiligence.findMany()
    * ```
    */
  get dueDiligence(): Prisma.DueDiligenceDelegate<ExtArgs>;

  /**
   * `prisma.communityPost`: Exposes CRUD operations for the **CommunityPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPosts
    * const communityPosts = await prisma.communityPost.findMany()
    * ```
    */
  get communityPost(): Prisma.CommunityPostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.secondaryListing`: Exposes CRUD operations for the **SecondaryListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecondaryListings
    * const secondaryListings = await prisma.secondaryListing.findMany()
    * ```
    */
  get secondaryListing(): Prisma.SecondaryListingDelegate<ExtArgs>;

  /**
   * `prisma.secondaryTrade`: Exposes CRUD operations for the **SecondaryTrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecondaryTrades
    * const secondaryTrades = await prisma.secondaryTrade.findMany()
    * ```
    */
  get secondaryTrade(): Prisma.SecondaryTradeDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    SME: 'SME',
    Investor: 'Investor',
    Advisor: 'Advisor',
    Deal: 'Deal',
    DealInvestor: 'DealInvestor',
    Document: 'Document',
    Certification: 'Certification',
    Workflow: 'Workflow',
    Syndicate: 'Syndicate',
    SyndicateMember: 'SyndicateMember',
    DueDiligence: 'DueDiligence',
    CommunityPost: 'CommunityPost',
    Comment: 'Comment',
    SecondaryListing: 'SecondaryListing',
    SecondaryTrade: 'SecondaryTrade',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'tenant' | 'user' | 'sME' | 'investor' | 'advisor' | 'deal' | 'dealInvestor' | 'document' | 'certification' | 'workflow' | 'syndicate' | 'syndicateMember' | 'dueDiligence' | 'communityPost' | 'comment' | 'secondaryListing' | 'secondaryTrade' | 'notification'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>,
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SME: {
        payload: Prisma.$SMEPayload<ExtArgs>
        fields: Prisma.SMEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMEFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMEFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          findFirst: {
            args: Prisma.SMEFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMEFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          findMany: {
            args: Prisma.SMEFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>[]
          }
          create: {
            args: Prisma.SMECreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          createMany: {
            args: Prisma.SMECreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SMEDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          update: {
            args: Prisma.SMEUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          deleteMany: {
            args: Prisma.SMEDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SMEUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SMEUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          aggregate: {
            args: Prisma.SMEAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSME>
          }
          groupBy: {
            args: Prisma.SMEGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SMEGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMECountArgs<ExtArgs>,
            result: $Utils.Optional<SMECountAggregateOutputType> | number
          }
        }
      }
      Investor: {
        payload: Prisma.$InvestorPayload<ExtArgs>
        fields: Prisma.InvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findFirst: {
            args: Prisma.InvestorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findMany: {
            args: Prisma.InvestorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          create: {
            args: Prisma.InvestorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          createMany: {
            args: Prisma.InvestorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvestorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          update: {
            args: Prisma.InvestorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          deleteMany: {
            args: Prisma.InvestorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvestorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.InvestorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorCountArgs<ExtArgs>,
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      Advisor: {
        payload: Prisma.$AdvisorPayload<ExtArgs>
        fields: Prisma.AdvisorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvisorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvisorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          findFirst: {
            args: Prisma.AdvisorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvisorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          findMany: {
            args: Prisma.AdvisorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>[]
          }
          create: {
            args: Prisma.AdvisorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          createMany: {
            args: Prisma.AdvisorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdvisorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          update: {
            args: Prisma.AdvisorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          deleteMany: {
            args: Prisma.AdvisorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdvisorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdvisorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          aggregate: {
            args: Prisma.AdvisorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdvisor>
          }
          groupBy: {
            args: Prisma.AdvisorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdvisorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvisorCountArgs<ExtArgs>,
            result: $Utils.Optional<AdvisorCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>,
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      DealInvestor: {
        payload: Prisma.$DealInvestorPayload<ExtArgs>
        fields: Prisma.DealInvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealInvestorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealInvestorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          findFirst: {
            args: Prisma.DealInvestorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealInvestorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          findMany: {
            args: Prisma.DealInvestorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>[]
          }
          create: {
            args: Prisma.DealInvestorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          createMany: {
            args: Prisma.DealInvestorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DealInvestorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          update: {
            args: Prisma.DealInvestorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          deleteMany: {
            args: Prisma.DealInvestorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DealInvestorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DealInvestorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          aggregate: {
            args: Prisma.DealInvestorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDealInvestor>
          }
          groupBy: {
            args: Prisma.DealInvestorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DealInvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealInvestorCountArgs<ExtArgs>,
            result: $Utils.Optional<DealInvestorCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>,
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      Syndicate: {
        payload: Prisma.$SyndicatePayload<ExtArgs>
        fields: Prisma.SyndicateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyndicateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyndicateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          findFirst: {
            args: Prisma.SyndicateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyndicateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          findMany: {
            args: Prisma.SyndicateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>[]
          }
          create: {
            args: Prisma.SyndicateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          createMany: {
            args: Prisma.SyndicateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SyndicateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          update: {
            args: Prisma.SyndicateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          deleteMany: {
            args: Prisma.SyndicateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SyndicateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SyndicateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          aggregate: {
            args: Prisma.SyndicateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSyndicate>
          }
          groupBy: {
            args: Prisma.SyndicateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyndicateCountArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateCountAggregateOutputType> | number
          }
        }
      }
      SyndicateMember: {
        payload: Prisma.$SyndicateMemberPayload<ExtArgs>
        fields: Prisma.SyndicateMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyndicateMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyndicateMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          findFirst: {
            args: Prisma.SyndicateMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyndicateMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          findMany: {
            args: Prisma.SyndicateMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>[]
          }
          create: {
            args: Prisma.SyndicateMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          createMany: {
            args: Prisma.SyndicateMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SyndicateMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          update: {
            args: Prisma.SyndicateMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          deleteMany: {
            args: Prisma.SyndicateMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SyndicateMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SyndicateMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          aggregate: {
            args: Prisma.SyndicateMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSyndicateMember>
          }
          groupBy: {
            args: Prisma.SyndicateMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyndicateMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateMemberCountAggregateOutputType> | number
          }
        }
      }
      DueDiligence: {
        payload: Prisma.$DueDiligencePayload<ExtArgs>
        fields: Prisma.DueDiligenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DueDiligenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DueDiligenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          findFirst: {
            args: Prisma.DueDiligenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DueDiligenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          findMany: {
            args: Prisma.DueDiligenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>[]
          }
          create: {
            args: Prisma.DueDiligenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          createMany: {
            args: Prisma.DueDiligenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DueDiligenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          update: {
            args: Prisma.DueDiligenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          deleteMany: {
            args: Prisma.DueDiligenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DueDiligenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DueDiligenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          aggregate: {
            args: Prisma.DueDiligenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDueDiligence>
          }
          groupBy: {
            args: Prisma.DueDiligenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DueDiligenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DueDiligenceCountArgs<ExtArgs>,
            result: $Utils.Optional<DueDiligenceCountAggregateOutputType> | number
          }
        }
      }
      CommunityPost: {
        payload: Prisma.$CommunityPostPayload<ExtArgs>
        fields: Prisma.CommunityPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          findFirst: {
            args: Prisma.CommunityPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          findMany: {
            args: Prisma.CommunityPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>[]
          }
          create: {
            args: Prisma.CommunityPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          createMany: {
            args: Prisma.CommunityPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          update: {
            args: Prisma.CommunityPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          deleteMany: {
            args: Prisma.CommunityPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          aggregate: {
            args: Prisma.CommunityPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunityPost>
          }
          groupBy: {
            args: Prisma.CommunityPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityPostCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityPostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      SecondaryListing: {
        payload: Prisma.$SecondaryListingPayload<ExtArgs>
        fields: Prisma.SecondaryListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecondaryListingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecondaryListingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          findFirst: {
            args: Prisma.SecondaryListingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecondaryListingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          findMany: {
            args: Prisma.SecondaryListingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>[]
          }
          create: {
            args: Prisma.SecondaryListingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          createMany: {
            args: Prisma.SecondaryListingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SecondaryListingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          update: {
            args: Prisma.SecondaryListingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          deleteMany: {
            args: Prisma.SecondaryListingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SecondaryListingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SecondaryListingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          aggregate: {
            args: Prisma.SecondaryListingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSecondaryListing>
          }
          groupBy: {
            args: Prisma.SecondaryListingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecondaryListingCountArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryListingCountAggregateOutputType> | number
          }
        }
      }
      SecondaryTrade: {
        payload: Prisma.$SecondaryTradePayload<ExtArgs>
        fields: Prisma.SecondaryTradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecondaryTradeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecondaryTradeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          findFirst: {
            args: Prisma.SecondaryTradeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecondaryTradeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          findMany: {
            args: Prisma.SecondaryTradeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>[]
          }
          create: {
            args: Prisma.SecondaryTradeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          createMany: {
            args: Prisma.SecondaryTradeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SecondaryTradeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          update: {
            args: Prisma.SecondaryTradeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          deleteMany: {
            args: Prisma.SecondaryTradeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SecondaryTradeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SecondaryTradeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          aggregate: {
            args: Prisma.SecondaryTradeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSecondaryTrade>
          }
          groupBy: {
            args: Prisma.SecondaryTradeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryTradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecondaryTradeCountArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryTradeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    smes: number
    investors: number
    advisors: number
    deals: number
    workflows: number
    documents: number
    notifications: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    smes?: boolean | TenantCountOutputTypeCountSmesArgs
    investors?: boolean | TenantCountOutputTypeCountInvestorsArgs
    advisors?: boolean | TenantCountOutputTypeCountAdvisorsArgs
    deals?: boolean | TenantCountOutputTypeCountDealsArgs
    workflows?: boolean | TenantCountOutputTypeCountWorkflowsArgs
    documents?: boolean | TenantCountOutputTypeCountDocumentsArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMEWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAdvisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisorWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }



  /**
   * Count Type SMECountOutputType
   */

  export type SMECountOutputType = {
    documents: number
    deals: number
    certifications: number
    workflows: number
    dueDiligences: number
  }

  export type SMECountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | SMECountOutputTypeCountDocumentsArgs
    deals?: boolean | SMECountOutputTypeCountDealsArgs
    certifications?: boolean | SMECountOutputTypeCountCertificationsArgs
    workflows?: boolean | SMECountOutputTypeCountWorkflowsArgs
    dueDiligences?: boolean | SMECountOutputTypeCountDueDiligencesArgs
  }

  // Custom InputTypes

  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMECountOutputType
     */
    select?: SMECountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceWhereInput
  }



  /**
   * Count Type InvestorCountOutputType
   */

  export type InvestorCountOutputType = {
    dealInvestments: number
    workflows: number
    leadSyndicates: number
    syndicateMemberships: number
  }

  export type InvestorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dealInvestments?: boolean | InvestorCountOutputTypeCountDealInvestmentsArgs
    workflows?: boolean | InvestorCountOutputTypeCountWorkflowsArgs
    leadSyndicates?: boolean | InvestorCountOutputTypeCountLeadSyndicatesArgs
    syndicateMemberships?: boolean | InvestorCountOutputTypeCountSyndicateMembershipsArgs
  }

  // Custom InputTypes

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorCountOutputType
     */
    select?: InvestorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountDealInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountLeadSyndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountSyndicateMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateMemberWhereInput
  }



  /**
   * Count Type AdvisorCountOutputType
   */

  export type AdvisorCountOutputType = {
    certifications: number
    workflows: number
    dueDiligences: number
  }

  export type AdvisorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certifications?: boolean | AdvisorCountOutputTypeCountCertificationsArgs
    workflows?: boolean | AdvisorCountOutputTypeCountWorkflowsArgs
    dueDiligences?: boolean | AdvisorCountOutputTypeCountDueDiligencesArgs
  }

  // Custom InputTypes

  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisorCountOutputType
     */
    select?: AdvisorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountDueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceWhereInput
  }



  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    investors: number
    documents: number
    workflows: number
    syndicates: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investors?: boolean | DealCountOutputTypeCountInvestorsArgs
    documents?: boolean | DealCountOutputTypeCountDocumentsArgs
    workflows?: boolean | DealCountOutputTypeCountWorkflowsArgs
    syndicates?: boolean | DealCountOutputTypeCountSyndicatesArgs
  }

  // Custom InputTypes

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountSyndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateWhereInput
  }



  /**
   * Count Type SyndicateCountOutputType
   */

  export type SyndicateCountOutputType = {
    members: number
  }

  export type SyndicateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | SyndicateCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes

  /**
   * SyndicateCountOutputType without action
   */
  export type SyndicateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateCountOutputType
     */
    select?: SyndicateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SyndicateCountOutputType without action
   */
  export type SyndicateCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateMemberWhereInput
  }



  /**
   * Count Type CommunityPostCountOutputType
   */

  export type CommunityPostCountOutputType = {
    comments: number
  }

  export type CommunityPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | CommunityPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPostCountOutputType
     */
    select?: CommunityPostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type SecondaryListingCountOutputType
   */

  export type SecondaryListingCountOutputType = {
    trades: number
  }

  export type SecondaryListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trades?: boolean | SecondaryListingCountOutputTypeCountTradesArgs
  }

  // Custom InputTypes

  /**
   * SecondaryListingCountOutputType without action
   */
  export type SecondaryListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListingCountOutputType
     */
    select?: SecondaryListingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SecondaryListingCountOutputType without action
   */
  export type SecondaryListingCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryTradeWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    smes?: boolean | Tenant$smesArgs<ExtArgs>
    investors?: boolean | Tenant$investorsArgs<ExtArgs>
    advisors?: boolean | Tenant$advisorsArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    workflows?: boolean | Tenant$workflowsArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    smes?: boolean | Tenant$smesArgs<ExtArgs>
    investors?: boolean | Tenant$investorsArgs<ExtArgs>
    advisors?: boolean | Tenant$advisorsArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    workflows?: boolean | Tenant$workflowsArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      smes: Prisma.$SMEPayload<ExtArgs>[]
      investors: Prisma.$InvestorPayload<ExtArgs>[]
      advisors: Prisma.$AdvisorPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }


  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TenantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TenantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TenantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
    **/
    create<T extends TenantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TenantCreateArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tenants.
     *     @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     *     @example
     *     // Create many Tenants
     *     const tenant = await prisma.tenant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TenantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
    **/
    delete<T extends TenantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TenantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TenantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TenantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
    **/
    upsert<T extends TenantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    smes<T extends Tenant$smesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$smesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findMany'> | Null>;

    investors<T extends Tenant$investorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findMany'> | Null>;

    advisors<T extends Tenant$advisorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$advisorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findMany'> | Null>;

    deals<T extends Tenant$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Tenant$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    documents<T extends Tenant$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }


  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }


  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }


  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }


  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }


  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }


  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }


  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Tenant.smes
   */
  export type Tenant$smesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    cursor?: SMEWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * Tenant.investors
   */
  export type Tenant$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    cursor?: InvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Tenant.advisors
   */
  export type Tenant$advisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    cursor?: AdvisorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Tenant.deals
   */
  export type Tenant$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Tenant.workflows
   */
  export type Tenant$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Tenant.documents
   */
  export type Tenant$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: $Enums.Language | null
    did: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: $Enums.Language | null
    did: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    status: number
    language: number
    did: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    language: $Enums.Language
    did: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | User$smeArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    advisor?: boolean | User$advisorArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | User$smeArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    advisor?: boolean | User$advisorArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      language: $Enums.Language
      did: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends User$smeArgs<ExtArgs> = {}>(args?: Subset<T, User$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    investor<T extends User$investorArgs<ExtArgs> = {}>(args?: Subset<T, User$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    advisor<T extends User$advisorArgs<ExtArgs> = {}>(args?: Subset<T, User$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly language: FieldRef<"User", 'Language'>
    readonly did: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.sme
   */
  export type User$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }


  /**
   * User.investor
   */
  export type User$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }


  /**
   * User.advisor
   */
  export type User$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model SME
   */

  export type AggregateSME = {
    _count: SMECountAggregateOutputType | null
    _avg: SMEAvgAggregateOutputType | null
    _sum: SMESumAggregateOutputType | null
    _min: SMEMinAggregateOutputType | null
    _max: SMEMaxAggregateOutputType | null
  }

  export type SMEAvgAggregateOutputType = {
    fundingRequired: number | null
    score: number | null
  }

  export type SMESumAggregateOutputType = {
    fundingRequired: number | null
    score: number | null
  }

  export type SMEMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    sector: string | null
    stage: $Enums.SMEStage | null
    fundingRequired: number | null
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean | null
    certificationDate: Date | null
    status: $Enums.SMEStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SMEMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    sector: string | null
    stage: $Enums.SMEStage | null
    fundingRequired: number | null
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean | null
    certificationDate: Date | null
    status: $Enums.SMEStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SMECountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    sector: number
    stage: number
    fundingRequired: number
    description: number
    website: number
    location: number
    score: number
    certified: number
    certificationDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SMEAvgAggregateInputType = {
    fundingRequired?: true
    score?: true
  }

  export type SMESumAggregateInputType = {
    fundingRequired?: true
    score?: true
  }

  export type SMEMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SMEMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SMECountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SMEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SME to aggregate.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMES
    **/
    _count?: true | SMECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SMEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SMESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMEMaxAggregateInputType
  }

  export type GetSMEAggregateType<T extends SMEAggregateArgs> = {
        [P in keyof T & keyof AggregateSME]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSME[P]>
      : GetScalarType<T[P], AggregateSME[P]>
  }




  export type SMEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMEWhereInput
    orderBy?: SMEOrderByWithAggregationInput | SMEOrderByWithAggregationInput[]
    by: SMEScalarFieldEnum[] | SMEScalarFieldEnum
    having?: SMEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMECountAggregateInputType | true
    _avg?: SMEAvgAggregateInputType
    _sum?: SMESumAggregateInputType
    _min?: SMEMinAggregateInputType
    _max?: SMEMaxAggregateInputType
  }

  export type SMEGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean
    certificationDate: Date | null
    status: $Enums.SMEStatus
    createdAt: Date
    updatedAt: Date
    _count: SMECountAggregateOutputType | null
    _avg: SMEAvgAggregateOutputType | null
    _sum: SMESumAggregateOutputType | null
    _min: SMEMinAggregateOutputType | null
    _max: SMEMaxAggregateOutputType | null
  }

  type GetSMEGroupByPayload<T extends SMEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMEGroupByOutputType[P]>
            : GetScalarType<T[P], SMEGroupByOutputType[P]>
        }
      >
    >


  export type SMESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | SME$documentsArgs<ExtArgs>
    deals?: boolean | SME$dealsArgs<ExtArgs>
    certifications?: boolean | SME$certificationsArgs<ExtArgs>
    workflows?: boolean | SME$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | SME$dueDiligencesArgs<ExtArgs>
    _count?: boolean | SMECountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sME"]>

  export type SMESelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SMEInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | SME$documentsArgs<ExtArgs>
    deals?: boolean | SME$dealsArgs<ExtArgs>
    certifications?: boolean | SME$certificationsArgs<ExtArgs>
    workflows?: boolean | SME$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | SME$dueDiligencesArgs<ExtArgs>
    _count?: boolean | SMECountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SMEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SME"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      dueDiligences: Prisma.$DueDiligencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      sector: string
      stage: $Enums.SMEStage
      fundingRequired: number
      description: string | null
      website: string | null
      location: string | null
      score: number | null
      certified: boolean
      certificationDate: Date | null
      status: $Enums.SMEStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sME"]>
    composites: {}
  }


  type SMEGetPayload<S extends boolean | null | undefined | SMEDefaultArgs> = $Result.GetResult<Prisma.$SMEPayload, S>

  type SMECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SMEFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SMECountAggregateInputType | true
    }

  export interface SMEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SME'], meta: { name: 'SME' } }
    /**
     * Find zero or one SME that matches the filter.
     * @param {SMEFindUniqueArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SMEFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SMEFindUniqueArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SME that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SMEFindUniqueOrThrowArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SMEFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SME that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindFirstArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SMEFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindFirstArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SME that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindFirstOrThrowArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SMEFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SMES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMES
     * const sMES = await prisma.sME.findMany()
     * 
     * // Get first 10 SMES
     * const sMES = await prisma.sME.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMEWithIdOnly = await prisma.sME.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SMEFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SME.
     * @param {SMECreateArgs} args - Arguments to create a SME.
     * @example
     * // Create one SME
     * const SME = await prisma.sME.create({
     *   data: {
     *     // ... data to create a SME
     *   }
     * })
     * 
    **/
    create<T extends SMECreateArgs<ExtArgs>>(
      args: SelectSubset<T, SMECreateArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SMES.
     *     @param {SMECreateManyArgs} args - Arguments to create many SMES.
     *     @example
     *     // Create many SMES
     *     const sME = await prisma.sME.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SMECreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SMECreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SME.
     * @param {SMEDeleteArgs} args - Arguments to delete one SME.
     * @example
     * // Delete one SME
     * const SME = await prisma.sME.delete({
     *   where: {
     *     // ... filter to delete one SME
     *   }
     * })
     * 
    **/
    delete<T extends SMEDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SMEDeleteArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SME.
     * @param {SMEUpdateArgs} args - Arguments to update one SME.
     * @example
     * // Update one SME
     * const sME = await prisma.sME.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SMEUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SMEUpdateArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SMES.
     * @param {SMEDeleteManyArgs} args - Arguments to filter SMES to delete.
     * @example
     * // Delete a few SMES
     * const { count } = await prisma.sME.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SMEDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMES
     * const sME = await prisma.sME.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SMEUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SMEUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SME.
     * @param {SMEUpsertArgs} args - Arguments to update or create a SME.
     * @example
     * // Update or create a SME
     * const sME = await prisma.sME.upsert({
     *   create: {
     *     // ... data to create a SME
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SME we want to update
     *   }
     * })
    **/
    upsert<T extends SMEUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SMEUpsertArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMECountArgs} args - Arguments to filter SMES to count.
     * @example
     * // Count the number of SMES
     * const count = await prisma.sME.count({
     *   where: {
     *     // ... the filter for the SMES we want to count
     *   }
     * })
    **/
    count<T extends SMECountArgs>(
      args?: Subset<T, SMECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMEAggregateArgs>(args: Subset<T, SMEAggregateArgs>): Prisma.PrismaPromise<GetSMEAggregateType<T>>

    /**
     * Group by SME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMEGroupByArgs['orderBy'] }
        : { orderBy?: SMEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SME model
   */
  readonly fields: SMEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SME.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    documents<T extends SME$documentsArgs<ExtArgs> = {}>(args?: Subset<T, SME$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    deals<T extends SME$dealsArgs<ExtArgs> = {}>(args?: Subset<T, SME$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findMany'> | Null>;

    certifications<T extends SME$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, SME$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends SME$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, SME$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    dueDiligences<T extends SME$dueDiligencesArgs<ExtArgs> = {}>(args?: Subset<T, SME$dueDiligencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SME model
   */ 
  interface SMEFieldRefs {
    readonly id: FieldRef<"SME", 'String'>
    readonly tenantId: FieldRef<"SME", 'String'>
    readonly userId: FieldRef<"SME", 'String'>
    readonly name: FieldRef<"SME", 'String'>
    readonly sector: FieldRef<"SME", 'String'>
    readonly stage: FieldRef<"SME", 'SMEStage'>
    readonly fundingRequired: FieldRef<"SME", 'Float'>
    readonly description: FieldRef<"SME", 'String'>
    readonly website: FieldRef<"SME", 'String'>
    readonly location: FieldRef<"SME", 'String'>
    readonly score: FieldRef<"SME", 'Float'>
    readonly certified: FieldRef<"SME", 'Boolean'>
    readonly certificationDate: FieldRef<"SME", 'DateTime'>
    readonly status: FieldRef<"SME", 'SMEStatus'>
    readonly createdAt: FieldRef<"SME", 'DateTime'>
    readonly updatedAt: FieldRef<"SME", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SME findUnique
   */
  export type SMEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME findUniqueOrThrow
   */
  export type SMEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME findFirst
   */
  export type SMEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMES.
     */
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * SME findFirstOrThrow
   */
  export type SMEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMES.
     */
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * SME findMany
   */
  export type SMEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SMES to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * SME create
   */
  export type SMECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The data needed to create a SME.
     */
    data: XOR<SMECreateInput, SMEUncheckedCreateInput>
  }


  /**
   * SME createMany
   */
  export type SMECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMES.
     */
    data: SMECreateManyInput | SMECreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SME update
   */
  export type SMEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The data needed to update a SME.
     */
    data: XOR<SMEUpdateInput, SMEUncheckedUpdateInput>
    /**
     * Choose, which SME to update.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME updateMany
   */
  export type SMEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMES.
     */
    data: XOR<SMEUpdateManyMutationInput, SMEUncheckedUpdateManyInput>
    /**
     * Filter which SMES to update
     */
    where?: SMEWhereInput
  }


  /**
   * SME upsert
   */
  export type SMEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The filter to search for the SME to update in case it exists.
     */
    where: SMEWhereUniqueInput
    /**
     * In case the SME found by the `where` argument doesn't exist, create a new SME with this data.
     */
    create: XOR<SMECreateInput, SMEUncheckedCreateInput>
    /**
     * In case the SME was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMEUpdateInput, SMEUncheckedUpdateInput>
  }


  /**
   * SME delete
   */
  export type SMEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter which SME to delete.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME deleteMany
   */
  export type SMEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMES to delete
     */
    where?: SMEWhereInput
  }


  /**
   * SME.documents
   */
  export type SME$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * SME.deals
   */
  export type SME$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * SME.certifications
   */
  export type SME$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * SME.workflows
   */
  export type SME$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * SME.dueDiligences
   */
  export type SME$dueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    where?: DueDiligenceWhereInput
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    cursor?: DueDiligenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * SME without action
   */
  export type SMEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
  }



  /**
   * Model Investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    type: $Enums.InvestorType | null
    kycStatus: $Enums.KYCStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    type: $Enums.InvestorType | null
    kycStatus: $Enums.KYCStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    type: number
    kycStatus: number
    preferences: number
    portfolio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    preferences?: true
    portfolio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investor to aggregate.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type InvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithAggregationInput | InvestorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: InvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus: $Enums.KYCStatus
    preferences: JsonValue
    portfolio: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: InvestorCountAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends InvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type InvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestments?: boolean | Investor$dealInvestmentsArgs<ExtArgs>
    workflows?: boolean | Investor$workflowsArgs<ExtArgs>
    leadSyndicates?: boolean | Investor$leadSyndicatesArgs<ExtArgs>
    syndicateMemberships?: boolean | Investor$syndicateMembershipsArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestments?: boolean | Investor$dealInvestmentsArgs<ExtArgs>
    workflows?: boolean | Investor$workflowsArgs<ExtArgs>
    leadSyndicates?: boolean | Investor$leadSyndicatesArgs<ExtArgs>
    syndicateMemberships?: boolean | Investor$syndicateMembershipsArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      dealInvestments: Prisma.$DealInvestorPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      leadSyndicates: Prisma.$SyndicatePayload<ExtArgs>[]
      syndicateMemberships: Prisma.$SyndicateMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      type: $Enums.InvestorType
      kycStatus: $Enums.KYCStatus
      preferences: Prisma.JsonValue
      portfolio: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }


  type InvestorGetPayload<S extends boolean | null | undefined | InvestorDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayload, S>

  type InvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvestorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface InvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investor'], meta: { name: 'Investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {InvestorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvestorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorFindUniqueArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Investor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvestorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvestorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvestorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindFirstArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvestorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvestorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Investor.
     * @param {InvestorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
    **/
    create<T extends InvestorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorCreateArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Investors.
     *     @param {InvestorCreateManyArgs} args - Arguments to create many Investors.
     *     @example
     *     // Create many Investors
     *     const investor = await prisma.investor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvestorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investor.
     * @param {InvestorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
    **/
    delete<T extends InvestorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorDeleteArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Investor.
     * @param {InvestorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvestorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorUpdateArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Investors.
     * @param {InvestorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvestorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvestorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investor.
     * @param {InvestorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
    **/
    upsert<T extends InvestorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorUpsertArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends InvestorCountArgs>(
      args?: Subset<T, InvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investor model
   */
  readonly fields: InvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dealInvestments<T extends Investor$dealInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$dealInvestmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Investor$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    leadSyndicates<T extends Investor$leadSyndicatesArgs<ExtArgs> = {}>(args?: Subset<T, Investor$leadSyndicatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findMany'> | Null>;

    syndicateMemberships<T extends Investor$syndicateMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$syndicateMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Investor model
   */ 
  interface InvestorFieldRefs {
    readonly id: FieldRef<"Investor", 'String'>
    readonly tenantId: FieldRef<"Investor", 'String'>
    readonly userId: FieldRef<"Investor", 'String'>
    readonly name: FieldRef<"Investor", 'String'>
    readonly type: FieldRef<"Investor", 'InvestorType'>
    readonly kycStatus: FieldRef<"Investor", 'KYCStatus'>
    readonly preferences: FieldRef<"Investor", 'Json'>
    readonly portfolio: FieldRef<"Investor", 'Json'>
    readonly createdAt: FieldRef<"Investor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investor", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Investor findUnique
   */
  export type InvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor findUniqueOrThrow
   */
  export type InvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor findFirst
   */
  export type InvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Investor findFirstOrThrow
   */
  export type InvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Investor findMany
   */
  export type InvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investors to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Investor create
   */
  export type InvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a Investor.
     */
    data: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
  }


  /**
   * Investor createMany
   */
  export type InvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Investor update
   */
  export type InvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a Investor.
     */
    data: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
    /**
     * Choose, which Investor to update.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor updateMany
   */
  export type InvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
  }


  /**
   * Investor upsert
   */
  export type InvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the Investor to update in case it exists.
     */
    where: InvestorWhereUniqueInput
    /**
     * In case the Investor found by the `where` argument doesn't exist, create a new Investor with this data.
     */
    create: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
    /**
     * In case the Investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
  }


  /**
   * Investor delete
   */
  export type InvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter which Investor to delete.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor deleteMany
   */
  export type InvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investors to delete
     */
    where?: InvestorWhereInput
  }


  /**
   * Investor.dealInvestments
   */
  export type Investor$dealInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    cursor?: DealInvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * Investor.workflows
   */
  export type Investor$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Investor.leadSyndicates
   */
  export type Investor$leadSyndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    where?: SyndicateWhereInput
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    cursor?: SyndicateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Investor.syndicateMemberships
   */
  export type Investor$syndicateMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    where?: SyndicateMemberWhereInput
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    cursor?: SyndicateMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * Investor without action
   */
  export type InvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
  }



  /**
   * Model Advisor
   */

  export type AggregateAdvisor = {
    _count: AdvisorCountAggregateOutputType | null
    _min: AdvisorMinAggregateOutputType | null
    _max: AdvisorMaxAggregateOutputType | null
  }

  export type AdvisorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    status: $Enums.AdvisorStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    status: $Enums.AdvisorStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    specialization: number
    certificationList: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdvisorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    specialization?: true
    certificationList?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdvisorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advisor to aggregate.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advisors
    **/
    _count?: true | AdvisorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvisorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvisorMaxAggregateInputType
  }

  export type GetAdvisorAggregateType<T extends AdvisorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvisor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvisor[P]>
      : GetScalarType<T[P], AggregateAdvisor[P]>
  }




  export type AdvisorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisorWhereInput
    orderBy?: AdvisorOrderByWithAggregationInput | AdvisorOrderByWithAggregationInput[]
    by: AdvisorScalarFieldEnum[] | AdvisorScalarFieldEnum
    having?: AdvisorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvisorCountAggregateInputType | true
    _min?: AdvisorMinAggregateInputType
    _max?: AdvisorMaxAggregateInputType
  }

  export type AdvisorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    specialization: string[]
    certificationList: string[]
    status: $Enums.AdvisorStatus
    createdAt: Date
    updatedAt: Date
    _count: AdvisorCountAggregateOutputType | null
    _min: AdvisorMinAggregateOutputType | null
    _max: AdvisorMaxAggregateOutputType | null
  }

  type GetAdvisorGroupByPayload<T extends AdvisorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvisorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvisorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvisorGroupByOutputType[P]>
            : GetScalarType<T[P], AdvisorGroupByOutputType[P]>
        }
      >
    >


  export type AdvisorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    certifications?: boolean | Advisor$certificationsArgs<ExtArgs>
    workflows?: boolean | Advisor$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | Advisor$dueDiligencesArgs<ExtArgs>
    _count?: boolean | AdvisorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advisor"]>

  export type AdvisorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdvisorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    certifications?: boolean | Advisor$certificationsArgs<ExtArgs>
    workflows?: boolean | Advisor$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | Advisor$dueDiligencesArgs<ExtArgs>
    _count?: boolean | AdvisorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdvisorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advisor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      dueDiligences: Prisma.$DueDiligencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      specialization: string[]
      certificationList: string[]
      status: $Enums.AdvisorStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["advisor"]>
    composites: {}
  }


  type AdvisorGetPayload<S extends boolean | null | undefined | AdvisorDefaultArgs> = $Result.GetResult<Prisma.$AdvisorPayload, S>

  type AdvisorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvisorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdvisorCountAggregateInputType | true
    }

  export interface AdvisorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advisor'], meta: { name: 'Advisor' } }
    /**
     * Find zero or one Advisor that matches the filter.
     * @param {AdvisorFindUniqueArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvisorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Advisor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdvisorFindUniqueOrThrowArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdvisorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Advisor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindFirstArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvisorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindFirstArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Advisor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindFirstOrThrowArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdvisorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Advisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advisors
     * const advisors = await prisma.advisor.findMany()
     * 
     * // Get first 10 Advisors
     * const advisors = await prisma.advisor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advisorWithIdOnly = await prisma.advisor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdvisorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Advisor.
     * @param {AdvisorCreateArgs} args - Arguments to create a Advisor.
     * @example
     * // Create one Advisor
     * const Advisor = await prisma.advisor.create({
     *   data: {
     *     // ... data to create a Advisor
     *   }
     * })
     * 
    **/
    create<T extends AdvisorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorCreateArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Advisors.
     *     @param {AdvisorCreateManyArgs} args - Arguments to create many Advisors.
     *     @example
     *     // Create many Advisors
     *     const advisor = await prisma.advisor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvisorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advisor.
     * @param {AdvisorDeleteArgs} args - Arguments to delete one Advisor.
     * @example
     * // Delete one Advisor
     * const Advisor = await prisma.advisor.delete({
     *   where: {
     *     // ... filter to delete one Advisor
     *   }
     * })
     * 
    **/
    delete<T extends AdvisorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorDeleteArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Advisor.
     * @param {AdvisorUpdateArgs} args - Arguments to update one Advisor.
     * @example
     * // Update one Advisor
     * const advisor = await prisma.advisor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvisorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorUpdateArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Advisors.
     * @param {AdvisorDeleteManyArgs} args - Arguments to filter Advisors to delete.
     * @example
     * // Delete a few Advisors
     * const { count } = await prisma.advisor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvisorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advisors
     * const advisor = await prisma.advisor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvisorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advisor.
     * @param {AdvisorUpsertArgs} args - Arguments to update or create a Advisor.
     * @example
     * // Update or create a Advisor
     * const advisor = await prisma.advisor.upsert({
     *   create: {
     *     // ... data to create a Advisor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advisor we want to update
     *   }
     * })
    **/
    upsert<T extends AdvisorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorUpsertArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Advisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorCountArgs} args - Arguments to filter Advisors to count.
     * @example
     * // Count the number of Advisors
     * const count = await prisma.advisor.count({
     *   where: {
     *     // ... the filter for the Advisors we want to count
     *   }
     * })
    **/
    count<T extends AdvisorCountArgs>(
      args?: Subset<T, AdvisorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvisorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvisorAggregateArgs>(args: Subset<T, AdvisorAggregateArgs>): Prisma.PrismaPromise<GetAdvisorAggregateType<T>>

    /**
     * Group by Advisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvisorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvisorGroupByArgs['orderBy'] }
        : { orderBy?: AdvisorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvisorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvisorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advisor model
   */
  readonly fields: AdvisorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advisor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvisorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    certifications<T extends Advisor$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Advisor$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    dueDiligences<T extends Advisor$dueDiligencesArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$dueDiligencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Advisor model
   */ 
  interface AdvisorFieldRefs {
    readonly id: FieldRef<"Advisor", 'String'>
    readonly tenantId: FieldRef<"Advisor", 'String'>
    readonly userId: FieldRef<"Advisor", 'String'>
    readonly name: FieldRef<"Advisor", 'String'>
    readonly specialization: FieldRef<"Advisor", 'String[]'>
    readonly certificationList: FieldRef<"Advisor", 'String[]'>
    readonly status: FieldRef<"Advisor", 'AdvisorStatus'>
    readonly createdAt: FieldRef<"Advisor", 'DateTime'>
    readonly updatedAt: FieldRef<"Advisor", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Advisor findUnique
   */
  export type AdvisorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor findUniqueOrThrow
   */
  export type AdvisorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor findFirst
   */
  export type AdvisorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advisors.
     */
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Advisor findFirstOrThrow
   */
  export type AdvisorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advisors.
     */
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Advisor findMany
   */
  export type AdvisorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisors to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Advisor create
   */
  export type AdvisorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The data needed to create a Advisor.
     */
    data: XOR<AdvisorCreateInput, AdvisorUncheckedCreateInput>
  }


  /**
   * Advisor createMany
   */
  export type AdvisorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advisors.
     */
    data: AdvisorCreateManyInput | AdvisorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Advisor update
   */
  export type AdvisorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The data needed to update a Advisor.
     */
    data: XOR<AdvisorUpdateInput, AdvisorUncheckedUpdateInput>
    /**
     * Choose, which Advisor to update.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor updateMany
   */
  export type AdvisorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advisors.
     */
    data: XOR<AdvisorUpdateManyMutationInput, AdvisorUncheckedUpdateManyInput>
    /**
     * Filter which Advisors to update
     */
    where?: AdvisorWhereInput
  }


  /**
   * Advisor upsert
   */
  export type AdvisorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The filter to search for the Advisor to update in case it exists.
     */
    where: AdvisorWhereUniqueInput
    /**
     * In case the Advisor found by the `where` argument doesn't exist, create a new Advisor with this data.
     */
    create: XOR<AdvisorCreateInput, AdvisorUncheckedCreateInput>
    /**
     * In case the Advisor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvisorUpdateInput, AdvisorUncheckedUpdateInput>
  }


  /**
   * Advisor delete
   */
  export type AdvisorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter which Advisor to delete.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor deleteMany
   */
  export type AdvisorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advisors to delete
     */
    where?: AdvisorWhereInput
  }


  /**
   * Advisor.certifications
   */
  export type Advisor$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Advisor.workflows
   */
  export type Advisor$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Advisor.dueDiligences
   */
  export type Advisor$dueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    where?: DueDiligenceWhereInput
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    cursor?: DueDiligenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * Advisor without action
   */
  export type AdvisorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
  }



  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    amount: number | null
    equity: number | null
    successFee: number | null
  }

  export type DealSumAggregateOutputType = {
    amount: number | null
    equity: number | null
    successFee: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    title: string | null
    description: string | null
    amount: number | null
    equity: number | null
    status: $Enums.DealStatus | null
    successFee: number | null
    terms: string | null
    isDocumentLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    title: string | null
    description: string | null
    amount: number | null
    equity: number | null
    status: $Enums.DealStatus | null
    successFee: number | null
    terms: string | null
    isDocumentLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    tenantId: number
    smeId: number
    title: number
    description: number
    amount: number
    equity: number
    status: number
    successFee: number
    terms: number
    isDocumentLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    amount?: true
    equity?: true
    successFee?: true
  }

  export type DealSumAggregateInputType = {
    amount?: true
    equity?: true
    successFee?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    terms?: true
    isDocumentLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    terms?: true
    isDocumentLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    terms?: true
    isDocumentLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    tenantId: string
    smeId: string
    title: string
    description: string | null
    amount: number
    equity: number | null
    status: $Enums.DealStatus
    successFee: number | null
    terms: string | null
    isDocumentLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    terms?: boolean
    isDocumentLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investors?: boolean | Deal$investorsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    workflows?: boolean | Deal$workflowsArgs<ExtArgs>
    syndicates?: boolean | Deal$syndicatesArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    terms?: boolean
    isDocumentLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investors?: boolean | Deal$investorsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    workflows?: boolean | Deal$workflowsArgs<ExtArgs>
    syndicates?: boolean | Deal$syndicatesArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs>
      investors: Prisma.$DealInvestorPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      syndicates: Prisma.$SyndicatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      smeId: string
      title: string
      description: string | null
      amount: number
      equity: number | null
      status: $Enums.DealStatus
      successFee: number | null
      terms: string | null
      isDocumentLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }


  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DealFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Deal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DealFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DealFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
    **/
    create<T extends DealCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DealCreateArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Deals.
     *     @param {DealCreateManyArgs} args - Arguments to create many Deals.
     *     @example
     *     // Create many Deals
     *     const deal = await prisma.deal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DealCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
    **/
    delete<T extends DealDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DealDeleteArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DealUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DealUpdateArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DealDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DealUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
    **/
    upsert<T extends DealUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DealUpsertArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investors<T extends Deal$investorsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findMany'> | Null>;

    documents<T extends Deal$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Deal$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    syndicates<T extends Deal$syndicatesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$syndicatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Deal model
   */ 
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly tenantId: FieldRef<"Deal", 'String'>
    readonly smeId: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly description: FieldRef<"Deal", 'String'>
    readonly amount: FieldRef<"Deal", 'Float'>
    readonly equity: FieldRef<"Deal", 'Float'>
    readonly status: FieldRef<"Deal", 'DealStatus'>
    readonly successFee: FieldRef<"Deal", 'Float'>
    readonly terms: FieldRef<"Deal", 'String'>
    readonly isDocumentLocked: FieldRef<"Deal", 'Boolean'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }


  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
  }


  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }


  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
  }


  /**
   * Deal.investors
   */
  export type Deal$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    cursor?: DealInvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * Deal.documents
   */
  export type Deal$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Deal.workflows
   */
  export type Deal$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Deal.syndicates
   */
  export type Deal$syndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    where?: SyndicateWhereInput
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    cursor?: SyndicateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
  }



  /**
   * Model DealInvestor
   */

  export type AggregateDealInvestor = {
    _count: DealInvestorCountAggregateOutputType | null
    _avg: DealInvestorAvgAggregateOutputType | null
    _sum: DealInvestorSumAggregateOutputType | null
    _min: DealInvestorMinAggregateOutputType | null
    _max: DealInvestorMaxAggregateOutputType | null
  }

  export type DealInvestorAvgAggregateOutputType = {
    amount: number | null
  }

  export type DealInvestorSumAggregateOutputType = {
    amount: number | null
  }

  export type DealInvestorMinAggregateOutputType = {
    id: string | null
    dealId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.InvestmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealInvestorMaxAggregateOutputType = {
    id: string | null
    dealId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.InvestmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealInvestorCountAggregateOutputType = {
    id: number
    dealId: number
    investorId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealInvestorAvgAggregateInputType = {
    amount?: true
  }

  export type DealInvestorSumAggregateInputType = {
    amount?: true
  }

  export type DealInvestorMinAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealInvestorMaxAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealInvestorCountAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealInvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealInvestor to aggregate.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DealInvestors
    **/
    _count?: true | DealInvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealInvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealInvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealInvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealInvestorMaxAggregateInputType
  }

  export type GetDealInvestorAggregateType<T extends DealInvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateDealInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealInvestor[P]>
      : GetScalarType<T[P], AggregateDealInvestor[P]>
  }




  export type DealInvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithAggregationInput | DealInvestorOrderByWithAggregationInput[]
    by: DealInvestorScalarFieldEnum[] | DealInvestorScalarFieldEnum
    having?: DealInvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealInvestorCountAggregateInputType | true
    _avg?: DealInvestorAvgAggregateInputType
    _sum?: DealInvestorSumAggregateInputType
    _min?: DealInvestorMinAggregateInputType
    _max?: DealInvestorMaxAggregateInputType
  }

  export type DealInvestorGroupByOutputType = {
    id: string
    dealId: string
    investorId: string
    amount: number
    status: $Enums.InvestmentStatus
    createdAt: Date
    updatedAt: Date
    _count: DealInvestorCountAggregateOutputType | null
    _avg: DealInvestorAvgAggregateOutputType | null
    _sum: DealInvestorSumAggregateOutputType | null
    _min: DealInvestorMinAggregateOutputType | null
    _max: DealInvestorMaxAggregateOutputType | null
  }

  type GetDealInvestorGroupByPayload<T extends DealInvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealInvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealInvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealInvestorGroupByOutputType[P]>
            : GetScalarType<T[P], DealInvestorGroupByOutputType[P]>
        }
      >
    >


  export type DealInvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealInvestor"]>

  export type DealInvestorSelectScalar = {
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealInvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }


  export type $DealInvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DealInvestor"
    objects: {
      deal: Prisma.$DealPayload<ExtArgs>
      investor: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dealId: string
      investorId: string
      amount: number
      status: $Enums.InvestmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dealInvestor"]>
    composites: {}
  }


  type DealInvestorGetPayload<S extends boolean | null | undefined | DealInvestorDefaultArgs> = $Result.GetResult<Prisma.$DealInvestorPayload, S>

  type DealInvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealInvestorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DealInvestorCountAggregateInputType | true
    }

  export interface DealInvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DealInvestor'], meta: { name: 'DealInvestor' } }
    /**
     * Find zero or one DealInvestor that matches the filter.
     * @param {DealInvestorFindUniqueArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DealInvestorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorFindUniqueArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DealInvestor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DealInvestorFindUniqueOrThrowArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DealInvestorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DealInvestor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindFirstArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DealInvestorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindFirstArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DealInvestor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindFirstOrThrowArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DealInvestorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DealInvestors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DealInvestors
     * const dealInvestors = await prisma.dealInvestor.findMany()
     * 
     * // Get first 10 DealInvestors
     * const dealInvestors = await prisma.dealInvestor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealInvestorWithIdOnly = await prisma.dealInvestor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DealInvestorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DealInvestor.
     * @param {DealInvestorCreateArgs} args - Arguments to create a DealInvestor.
     * @example
     * // Create one DealInvestor
     * const DealInvestor = await prisma.dealInvestor.create({
     *   data: {
     *     // ... data to create a DealInvestor
     *   }
     * })
     * 
    **/
    create<T extends DealInvestorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorCreateArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DealInvestors.
     *     @param {DealInvestorCreateManyArgs} args - Arguments to create many DealInvestors.
     *     @example
     *     // Create many DealInvestors
     *     const dealInvestor = await prisma.dealInvestor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DealInvestorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DealInvestor.
     * @param {DealInvestorDeleteArgs} args - Arguments to delete one DealInvestor.
     * @example
     * // Delete one DealInvestor
     * const DealInvestor = await prisma.dealInvestor.delete({
     *   where: {
     *     // ... filter to delete one DealInvestor
     *   }
     * })
     * 
    **/
    delete<T extends DealInvestorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorDeleteArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DealInvestor.
     * @param {DealInvestorUpdateArgs} args - Arguments to update one DealInvestor.
     * @example
     * // Update one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DealInvestorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorUpdateArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DealInvestors.
     * @param {DealInvestorDeleteManyArgs} args - Arguments to filter DealInvestors to delete.
     * @example
     * // Delete a few DealInvestors
     * const { count } = await prisma.dealInvestor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DealInvestorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealInvestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DealInvestors
     * const dealInvestor = await prisma.dealInvestor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DealInvestorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DealInvestor.
     * @param {DealInvestorUpsertArgs} args - Arguments to update or create a DealInvestor.
     * @example
     * // Update or create a DealInvestor
     * const dealInvestor = await prisma.dealInvestor.upsert({
     *   create: {
     *     // ... data to create a DealInvestor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DealInvestor we want to update
     *   }
     * })
    **/
    upsert<T extends DealInvestorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorUpsertArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DealInvestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorCountArgs} args - Arguments to filter DealInvestors to count.
     * @example
     * // Count the number of DealInvestors
     * const count = await prisma.dealInvestor.count({
     *   where: {
     *     // ... the filter for the DealInvestors we want to count
     *   }
     * })
    **/
    count<T extends DealInvestorCountArgs>(
      args?: Subset<T, DealInvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealInvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DealInvestor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealInvestorAggregateArgs>(args: Subset<T, DealInvestorAggregateArgs>): Prisma.PrismaPromise<GetDealInvestorAggregateType<T>>

    /**
     * Group by DealInvestor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealInvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealInvestorGroupByArgs['orderBy'] }
        : { orderBy?: DealInvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealInvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DealInvestor model
   */
  readonly fields: DealInvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DealInvestor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealInvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    deal<T extends DealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealDefaultArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DealInvestor model
   */ 
  interface DealInvestorFieldRefs {
    readonly id: FieldRef<"DealInvestor", 'String'>
    readonly dealId: FieldRef<"DealInvestor", 'String'>
    readonly investorId: FieldRef<"DealInvestor", 'String'>
    readonly amount: FieldRef<"DealInvestor", 'Float'>
    readonly status: FieldRef<"DealInvestor", 'InvestmentStatus'>
    readonly createdAt: FieldRef<"DealInvestor", 'DateTime'>
    readonly updatedAt: FieldRef<"DealInvestor", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DealInvestor findUnique
   */
  export type DealInvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor findUniqueOrThrow
   */
  export type DealInvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor findFirst
   */
  export type DealInvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealInvestors.
     */
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * DealInvestor findFirstOrThrow
   */
  export type DealInvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealInvestors.
     */
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * DealInvestor findMany
   */
  export type DealInvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestors to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * DealInvestor create
   */
  export type DealInvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a DealInvestor.
     */
    data: XOR<DealInvestorCreateInput, DealInvestorUncheckedCreateInput>
  }


  /**
   * DealInvestor createMany
   */
  export type DealInvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DealInvestors.
     */
    data: DealInvestorCreateManyInput | DealInvestorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DealInvestor update
   */
  export type DealInvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a DealInvestor.
     */
    data: XOR<DealInvestorUpdateInput, DealInvestorUncheckedUpdateInput>
    /**
     * Choose, which DealInvestor to update.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor updateMany
   */
  export type DealInvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DealInvestors.
     */
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyInput>
    /**
     * Filter which DealInvestors to update
     */
    where?: DealInvestorWhereInput
  }


  /**
   * DealInvestor upsert
   */
  export type DealInvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the DealInvestor to update in case it exists.
     */
    where: DealInvestorWhereUniqueInput
    /**
     * In case the DealInvestor found by the `where` argument doesn't exist, create a new DealInvestor with this data.
     */
    create: XOR<DealInvestorCreateInput, DealInvestorUncheckedCreateInput>
    /**
     * In case the DealInvestor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealInvestorUpdateInput, DealInvestorUncheckedUpdateInput>
  }


  /**
   * DealInvestor delete
   */
  export type DealInvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter which DealInvestor to delete.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor deleteMany
   */
  export type DealInvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealInvestors to delete
     */
    where?: DealInvestorWhereInput
  }


  /**
   * DealInvestor without action
   */
  export type DealInvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.DocumentType | null
    url: string | null
    size: number | null
    mimeType: string | null
    smeId: string | null
    dealId: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.DocumentType | null
    url: string | null
    size: number | null
    mimeType: string | null
    smeId: string | null
    dealId: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    type: number
    url: number
    size: number
    mimeType: number
    smeId: number
    dealId: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId: string | null
    dealId: string | null
    uploadedBy: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      type: $Enums.DocumentType
      url: string
      size: number
      mimeType: string
      smeId: string | null
      dealId: string | null
      uploadedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends Document$smeArgs<ExtArgs> = {}>(args?: Subset<T, Document$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    deal<T extends Document$dealArgs<ExtArgs> = {}>(args?: Subset<T, Document$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly tenantId: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly url: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly smeId: FieldRef<"Document", 'String'>
    readonly dealId: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.sme
   */
  export type Document$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }


  /**
   * Document.deal
   */
  export type Document$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _avg: CertificationAvgAggregateOutputType | null
    _sum: CertificationSumAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationAvgAggregateOutputType = {
    score: number | null
  }

  export type CertificationSumAggregateOutputType = {
    score: number | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    status: $Enums.CertificationStatus | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    status: $Enums.CertificationStatus | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    smeId: number
    advisorId: number
    status: number
    score: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificationAvgAggregateInputType = {
    score?: true
  }

  export type CertificationSumAggregateInputType = {
    score?: true
  }

  export type CertificationMinAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _avg?: CertificationAvgAggregateInputType
    _sum?: CertificationSumAggregateInputType
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    smeId: string
    advisorId: string
    status: $Enums.CertificationStatus
    score: number | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificationCountAggregateOutputType | null
    _avg: CertificationAvgAggregateOutputType | null
    _sum: CertificationSumAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }


  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      sme: Prisma.$SMEPayload<ExtArgs>
      advisor: Prisma.$AdvisorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      smeId: string
      advisorId: string
      status: $Enums.CertificationStatus
      score: number | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }


  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CertificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Certification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CertificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CertificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
    **/
    create<T extends CertificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Certifications.
     *     @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     *     @example
     *     // Create many Certifications
     *     const certification = await prisma.certification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CertificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
    **/
    delete<T extends CertificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CertificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CertificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CertificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
    **/
    upsert<T extends CertificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    advisor<T extends AdvisorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvisorDefaultArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Certification model
   */ 
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly smeId: FieldRef<"Certification", 'String'>
    readonly advisorId: FieldRef<"Certification", 'String'>
    readonly status: FieldRef<"Certification", 'CertificationStatus'>
    readonly score: FieldRef<"Certification", 'Float'>
    readonly comments: FieldRef<"Certification", 'String'>
    readonly createdAt: FieldRef<"Certification", 'DateTime'>
    readonly updatedAt: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }


  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
  }


  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }


  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
  }


  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
  }



  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.WorkflowType | null
    status: $Enums.WorkflowStatus | null
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.WorkflowType | null
    status: $Enums.WorkflowStatus | null
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    status: number
    data: number
    smeId: number
    investorId: number
    advisorId: number
    dealId: number
    didWorkflowId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    data?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.WorkflowType
    status: $Enums.WorkflowStatus
    data: JsonValue
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }


  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.WorkflowType
      status: $Enums.WorkflowStatus
      data: Prisma.JsonValue
      smeId: string | null
      investorId: string | null
      advisorId: string | null
      dealId: string | null
      didWorkflowId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }


  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkflowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Workflow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkflowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkflowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
    **/
    create<T extends WorkflowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Workflows.
     *     @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     *     @example
     *     // Create many Workflows
     *     const workflow = await prisma.workflow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkflowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
    **/
    delete<T extends WorkflowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkflowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkflowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkflowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
    **/
    upsert<T extends WorkflowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends Workflow$smeArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    investor<T extends Workflow$investorArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    advisor<T extends Workflow$advisorArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    deal<T extends Workflow$dealArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Workflow model
   */ 
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly tenantId: FieldRef<"Workflow", 'String'>
    readonly type: FieldRef<"Workflow", 'WorkflowType'>
    readonly status: FieldRef<"Workflow", 'WorkflowStatus'>
    readonly data: FieldRef<"Workflow", 'Json'>
    readonly smeId: FieldRef<"Workflow", 'String'>
    readonly investorId: FieldRef<"Workflow", 'String'>
    readonly advisorId: FieldRef<"Workflow", 'String'>
    readonly dealId: FieldRef<"Workflow", 'String'>
    readonly didWorkflowId: FieldRef<"Workflow", 'String'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }


  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
  }


  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }


  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
  }


  /**
   * Workflow.sme
   */
  export type Workflow$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }


  /**
   * Workflow.investor
   */
  export type Workflow$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }


  /**
   * Workflow.advisor
   */
  export type Workflow$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * Workflow.deal
   */
  export type Workflow$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
  }



  /**
   * Model Syndicate
   */

  export type AggregateSyndicate = {
    _count: SyndicateCountAggregateOutputType | null
    _avg: SyndicateAvgAggregateOutputType | null
    _sum: SyndicateSumAggregateOutputType | null
    _min: SyndicateMinAggregateOutputType | null
    _max: SyndicateMaxAggregateOutputType | null
  }

  export type SyndicateAvgAggregateOutputType = {
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
  }

  export type SyndicateSumAggregateOutputType = {
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
  }

  export type SyndicateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    leadInvestorId: string | null
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
    status: $Enums.SyndicateStatus | null
    dealId: string | null
    closingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyndicateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    leadInvestorId: string | null
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
    status: $Enums.SyndicateStatus | null
    dealId: string | null
    closingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyndicateCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    leadInvestorId: number
    targetAmount: number
    minInvestment: number
    maxInvestment: number
    managementFee: number
    carryFee: number
    status: number
    dealId: number
    closingDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SyndicateAvgAggregateInputType = {
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
  }

  export type SyndicateSumAggregateInputType = {
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
  }

  export type SyndicateMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    leadInvestorId?: true
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
    status?: true
    dealId?: true
    closingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyndicateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    leadInvestorId?: true
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
    status?: true
    dealId?: true
    closingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyndicateCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    leadInvestorId?: true
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
    status?: true
    dealId?: true
    closingDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SyndicateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syndicate to aggregate.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Syndicates
    **/
    _count?: true | SyndicateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyndicateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyndicateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyndicateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyndicateMaxAggregateInputType
  }

  export type GetSyndicateAggregateType<T extends SyndicateAggregateArgs> = {
        [P in keyof T & keyof AggregateSyndicate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyndicate[P]>
      : GetScalarType<T[P], AggregateSyndicate[P]>
  }




  export type SyndicateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateWhereInput
    orderBy?: SyndicateOrderByWithAggregationInput | SyndicateOrderByWithAggregationInput[]
    by: SyndicateScalarFieldEnum[] | SyndicateScalarFieldEnum
    having?: SyndicateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyndicateCountAggregateInputType | true
    _avg?: SyndicateAvgAggregateInputType
    _sum?: SyndicateSumAggregateInputType
    _min?: SyndicateMinAggregateInputType
    _max?: SyndicateMaxAggregateInputType
  }

  export type SyndicateGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment: number
    maxInvestment: number | null
    managementFee: number
    carryFee: number
    status: $Enums.SyndicateStatus
    dealId: string | null
    closingDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SyndicateCountAggregateOutputType | null
    _avg: SyndicateAvgAggregateOutputType | null
    _sum: SyndicateSumAggregateOutputType | null
    _min: SyndicateMinAggregateOutputType | null
    _max: SyndicateMaxAggregateOutputType | null
  }

  type GetSyndicateGroupByPayload<T extends SyndicateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyndicateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyndicateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyndicateGroupByOutputType[P]>
            : GetScalarType<T[P], SyndicateGroupByOutputType[P]>
        }
      >
    >


  export type SyndicateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    leadInvestorId?: boolean
    targetAmount?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    managementFee?: boolean
    carryFee?: boolean
    status?: boolean
    dealId?: boolean
    closingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leadInvestor?: boolean | InvestorDefaultArgs<ExtArgs>
    deal?: boolean | Syndicate$dealArgs<ExtArgs>
    members?: boolean | Syndicate$membersArgs<ExtArgs>
    _count?: boolean | SyndicateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syndicate"]>

  export type SyndicateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    leadInvestorId?: boolean
    targetAmount?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    managementFee?: boolean
    carryFee?: boolean
    status?: boolean
    dealId?: boolean
    closingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SyndicateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leadInvestor?: boolean | InvestorDefaultArgs<ExtArgs>
    deal?: boolean | Syndicate$dealArgs<ExtArgs>
    members?: boolean | Syndicate$membersArgs<ExtArgs>
    _count?: boolean | SyndicateCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SyndicatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Syndicate"
    objects: {
      leadInvestor: Prisma.$InvestorPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      members: Prisma.$SyndicateMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      leadInvestorId: string
      targetAmount: number
      minInvestment: number
      maxInvestment: number | null
      managementFee: number
      carryFee: number
      status: $Enums.SyndicateStatus
      dealId: string | null
      closingDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["syndicate"]>
    composites: {}
  }


  type SyndicateGetPayload<S extends boolean | null | undefined | SyndicateDefaultArgs> = $Result.GetResult<Prisma.$SyndicatePayload, S>

  type SyndicateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyndicateFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SyndicateCountAggregateInputType | true
    }

  export interface SyndicateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Syndicate'], meta: { name: 'Syndicate' } }
    /**
     * Find zero or one Syndicate that matches the filter.
     * @param {SyndicateFindUniqueArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SyndicateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateFindUniqueArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Syndicate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SyndicateFindUniqueOrThrowArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SyndicateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Syndicate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateFindFirstArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SyndicateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindFirstArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Syndicate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateFindFirstOrThrowArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SyndicateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Syndicates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Syndicates
     * const syndicates = await prisma.syndicate.findMany()
     * 
     * // Get first 10 Syndicates
     * const syndicates = await prisma.syndicate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syndicateWithIdOnly = await prisma.syndicate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SyndicateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Syndicate.
     * @param {SyndicateCreateArgs} args - Arguments to create a Syndicate.
     * @example
     * // Create one Syndicate
     * const Syndicate = await prisma.syndicate.create({
     *   data: {
     *     // ... data to create a Syndicate
     *   }
     * })
     * 
    **/
    create<T extends SyndicateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateCreateArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Syndicates.
     *     @param {SyndicateCreateManyArgs} args - Arguments to create many Syndicates.
     *     @example
     *     // Create many Syndicates
     *     const syndicate = await prisma.syndicate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SyndicateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Syndicate.
     * @param {SyndicateDeleteArgs} args - Arguments to delete one Syndicate.
     * @example
     * // Delete one Syndicate
     * const Syndicate = await prisma.syndicate.delete({
     *   where: {
     *     // ... filter to delete one Syndicate
     *   }
     * })
     * 
    **/
    delete<T extends SyndicateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateDeleteArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Syndicate.
     * @param {SyndicateUpdateArgs} args - Arguments to update one Syndicate.
     * @example
     * // Update one Syndicate
     * const syndicate = await prisma.syndicate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SyndicateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateUpdateArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Syndicates.
     * @param {SyndicateDeleteManyArgs} args - Arguments to filter Syndicates to delete.
     * @example
     * // Delete a few Syndicates
     * const { count } = await prisma.syndicate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SyndicateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syndicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Syndicates
     * const syndicate = await prisma.syndicate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SyndicateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Syndicate.
     * @param {SyndicateUpsertArgs} args - Arguments to update or create a Syndicate.
     * @example
     * // Update or create a Syndicate
     * const syndicate = await prisma.syndicate.upsert({
     *   create: {
     *     // ... data to create a Syndicate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Syndicate we want to update
     *   }
     * })
    **/
    upsert<T extends SyndicateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateUpsertArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Syndicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateCountArgs} args - Arguments to filter Syndicates to count.
     * @example
     * // Count the number of Syndicates
     * const count = await prisma.syndicate.count({
     *   where: {
     *     // ... the filter for the Syndicates we want to count
     *   }
     * })
    **/
    count<T extends SyndicateCountArgs>(
      args?: Subset<T, SyndicateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyndicateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Syndicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyndicateAggregateArgs>(args: Subset<T, SyndicateAggregateArgs>): Prisma.PrismaPromise<GetSyndicateAggregateType<T>>

    /**
     * Group by Syndicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyndicateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyndicateGroupByArgs['orderBy'] }
        : { orderBy?: SyndicateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyndicateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyndicateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Syndicate model
   */
  readonly fields: SyndicateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Syndicate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyndicateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    leadInvestor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    deal<T extends Syndicate$dealArgs<ExtArgs> = {}>(args?: Subset<T, Syndicate$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    members<T extends Syndicate$membersArgs<ExtArgs> = {}>(args?: Subset<T, Syndicate$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Syndicate model
   */ 
  interface SyndicateFieldRefs {
    readonly id: FieldRef<"Syndicate", 'String'>
    readonly tenantId: FieldRef<"Syndicate", 'String'>
    readonly name: FieldRef<"Syndicate", 'String'>
    readonly description: FieldRef<"Syndicate", 'String'>
    readonly leadInvestorId: FieldRef<"Syndicate", 'String'>
    readonly targetAmount: FieldRef<"Syndicate", 'Float'>
    readonly minInvestment: FieldRef<"Syndicate", 'Float'>
    readonly maxInvestment: FieldRef<"Syndicate", 'Float'>
    readonly managementFee: FieldRef<"Syndicate", 'Float'>
    readonly carryFee: FieldRef<"Syndicate", 'Float'>
    readonly status: FieldRef<"Syndicate", 'SyndicateStatus'>
    readonly dealId: FieldRef<"Syndicate", 'String'>
    readonly closingDate: FieldRef<"Syndicate", 'DateTime'>
    readonly createdAt: FieldRef<"Syndicate", 'DateTime'>
    readonly updatedAt: FieldRef<"Syndicate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Syndicate findUnique
   */
  export type SyndicateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate findUniqueOrThrow
   */
  export type SyndicateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate findFirst
   */
  export type SyndicateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syndicates.
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syndicates.
     */
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Syndicate findFirstOrThrow
   */
  export type SyndicateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syndicates.
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syndicates.
     */
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Syndicate findMany
   */
  export type SyndicateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicates to fetch.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Syndicates.
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Syndicate create
   */
  export type SyndicateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * The data needed to create a Syndicate.
     */
    data: XOR<SyndicateCreateInput, SyndicateUncheckedCreateInput>
  }


  /**
   * Syndicate createMany
   */
  export type SyndicateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Syndicates.
     */
    data: SyndicateCreateManyInput | SyndicateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Syndicate update
   */
  export type SyndicateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * The data needed to update a Syndicate.
     */
    data: XOR<SyndicateUpdateInput, SyndicateUncheckedUpdateInput>
    /**
     * Choose, which Syndicate to update.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate updateMany
   */
  export type SyndicateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Syndicates.
     */
    data: XOR<SyndicateUpdateManyMutationInput, SyndicateUncheckedUpdateManyInput>
    /**
     * Filter which Syndicates to update
     */
    where?: SyndicateWhereInput
  }


  /**
   * Syndicate upsert
   */
  export type SyndicateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * The filter to search for the Syndicate to update in case it exists.
     */
    where: SyndicateWhereUniqueInput
    /**
     * In case the Syndicate found by the `where` argument doesn't exist, create a new Syndicate with this data.
     */
    create: XOR<SyndicateCreateInput, SyndicateUncheckedCreateInput>
    /**
     * In case the Syndicate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyndicateUpdateInput, SyndicateUncheckedUpdateInput>
  }


  /**
   * Syndicate delete
   */
  export type SyndicateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter which Syndicate to delete.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate deleteMany
   */
  export type SyndicateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syndicates to delete
     */
    where?: SyndicateWhereInput
  }


  /**
   * Syndicate.deal
   */
  export type Syndicate$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Syndicate.members
   */
  export type Syndicate$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    where?: SyndicateMemberWhereInput
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    cursor?: SyndicateMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * Syndicate without action
   */
  export type SyndicateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
  }



  /**
   * Model SyndicateMember
   */

  export type AggregateSyndicateMember = {
    _count: SyndicateMemberCountAggregateOutputType | null
    _avg: SyndicateMemberAvgAggregateOutputType | null
    _sum: SyndicateMemberSumAggregateOutputType | null
    _min: SyndicateMemberMinAggregateOutputType | null
    _max: SyndicateMemberMaxAggregateOutputType | null
  }

  export type SyndicateMemberAvgAggregateOutputType = {
    amount: number | null
  }

  export type SyndicateMemberSumAggregateOutputType = {
    amount: number | null
  }

  export type SyndicateMemberMinAggregateOutputType = {
    id: string | null
    syndicateId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.SyndicateMemberStatus | null
    joinedAt: Date | null
  }

  export type SyndicateMemberMaxAggregateOutputType = {
    id: string | null
    syndicateId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.SyndicateMemberStatus | null
    joinedAt: Date | null
  }

  export type SyndicateMemberCountAggregateOutputType = {
    id: number
    syndicateId: number
    investorId: number
    amount: number
    status: number
    joinedAt: number
    _all: number
  }


  export type SyndicateMemberAvgAggregateInputType = {
    amount?: true
  }

  export type SyndicateMemberSumAggregateInputType = {
    amount?: true
  }

  export type SyndicateMemberMinAggregateInputType = {
    id?: true
    syndicateId?: true
    investorId?: true
    amount?: true
    status?: true
    joinedAt?: true
  }

  export type SyndicateMemberMaxAggregateInputType = {
    id?: true
    syndicateId?: true
    investorId?: true
    amount?: true
    status?: true
    joinedAt?: true
  }

  export type SyndicateMemberCountAggregateInputType = {
    id?: true
    syndicateId?: true
    investorId?: true
    amount?: true
    status?: true
    joinedAt?: true
    _all?: true
  }

  export type SyndicateMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyndicateMember to aggregate.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyndicateMembers
    **/
    _count?: true | SyndicateMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyndicateMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyndicateMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyndicateMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyndicateMemberMaxAggregateInputType
  }

  export type GetSyndicateMemberAggregateType<T extends SyndicateMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateSyndicateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyndicateMember[P]>
      : GetScalarType<T[P], AggregateSyndicateMember[P]>
  }




  export type SyndicateMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateMemberWhereInput
    orderBy?: SyndicateMemberOrderByWithAggregationInput | SyndicateMemberOrderByWithAggregationInput[]
    by: SyndicateMemberScalarFieldEnum[] | SyndicateMemberScalarFieldEnum
    having?: SyndicateMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyndicateMemberCountAggregateInputType | true
    _avg?: SyndicateMemberAvgAggregateInputType
    _sum?: SyndicateMemberSumAggregateInputType
    _min?: SyndicateMemberMinAggregateInputType
    _max?: SyndicateMemberMaxAggregateInputType
  }

  export type SyndicateMemberGroupByOutputType = {
    id: string
    syndicateId: string
    investorId: string
    amount: number
    status: $Enums.SyndicateMemberStatus
    joinedAt: Date
    _count: SyndicateMemberCountAggregateOutputType | null
    _avg: SyndicateMemberAvgAggregateOutputType | null
    _sum: SyndicateMemberSumAggregateOutputType | null
    _min: SyndicateMemberMinAggregateOutputType | null
    _max: SyndicateMemberMaxAggregateOutputType | null
  }

  type GetSyndicateMemberGroupByPayload<T extends SyndicateMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyndicateMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyndicateMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyndicateMemberGroupByOutputType[P]>
            : GetScalarType<T[P], SyndicateMemberGroupByOutputType[P]>
        }
      >
    >


  export type SyndicateMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syndicateId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    joinedAt?: boolean
    syndicate?: boolean | SyndicateDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syndicateMember"]>

  export type SyndicateMemberSelectScalar = {
    id?: boolean
    syndicateId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    joinedAt?: boolean
  }

  export type SyndicateMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syndicate?: boolean | SyndicateDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }


  export type $SyndicateMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyndicateMember"
    objects: {
      syndicate: Prisma.$SyndicatePayload<ExtArgs>
      investor: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syndicateId: string
      investorId: string
      amount: number
      status: $Enums.SyndicateMemberStatus
      joinedAt: Date
    }, ExtArgs["result"]["syndicateMember"]>
    composites: {}
  }


  type SyndicateMemberGetPayload<S extends boolean | null | undefined | SyndicateMemberDefaultArgs> = $Result.GetResult<Prisma.$SyndicateMemberPayload, S>

  type SyndicateMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyndicateMemberFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SyndicateMemberCountAggregateInputType | true
    }

  export interface SyndicateMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyndicateMember'], meta: { name: 'SyndicateMember' } }
    /**
     * Find zero or one SyndicateMember that matches the filter.
     * @param {SyndicateMemberFindUniqueArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SyndicateMemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SyndicateMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SyndicateMemberFindUniqueOrThrowArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SyndicateMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SyndicateMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberFindFirstArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SyndicateMemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindFirstArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SyndicateMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberFindFirstOrThrowArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SyndicateMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SyndicateMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyndicateMembers
     * const syndicateMembers = await prisma.syndicateMember.findMany()
     * 
     * // Get first 10 SyndicateMembers
     * const syndicateMembers = await prisma.syndicateMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syndicateMemberWithIdOnly = await prisma.syndicateMember.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SyndicateMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SyndicateMember.
     * @param {SyndicateMemberCreateArgs} args - Arguments to create a SyndicateMember.
     * @example
     * // Create one SyndicateMember
     * const SyndicateMember = await prisma.syndicateMember.create({
     *   data: {
     *     // ... data to create a SyndicateMember
     *   }
     * })
     * 
    **/
    create<T extends SyndicateMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberCreateArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SyndicateMembers.
     *     @param {SyndicateMemberCreateManyArgs} args - Arguments to create many SyndicateMembers.
     *     @example
     *     // Create many SyndicateMembers
     *     const syndicateMember = await prisma.syndicateMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SyndicateMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyndicateMember.
     * @param {SyndicateMemberDeleteArgs} args - Arguments to delete one SyndicateMember.
     * @example
     * // Delete one SyndicateMember
     * const SyndicateMember = await prisma.syndicateMember.delete({
     *   where: {
     *     // ... filter to delete one SyndicateMember
     *   }
     * })
     * 
    **/
    delete<T extends SyndicateMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberDeleteArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SyndicateMember.
     * @param {SyndicateMemberUpdateArgs} args - Arguments to update one SyndicateMember.
     * @example
     * // Update one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SyndicateMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberUpdateArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SyndicateMembers.
     * @param {SyndicateMemberDeleteManyArgs} args - Arguments to filter SyndicateMembers to delete.
     * @example
     * // Delete a few SyndicateMembers
     * const { count } = await prisma.syndicateMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SyndicateMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyndicateMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyndicateMembers
     * const syndicateMember = await prisma.syndicateMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SyndicateMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyndicateMember.
     * @param {SyndicateMemberUpsertArgs} args - Arguments to update or create a SyndicateMember.
     * @example
     * // Update or create a SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.upsert({
     *   create: {
     *     // ... data to create a SyndicateMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyndicateMember we want to update
     *   }
     * })
    **/
    upsert<T extends SyndicateMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberUpsertArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SyndicateMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberCountArgs} args - Arguments to filter SyndicateMembers to count.
     * @example
     * // Count the number of SyndicateMembers
     * const count = await prisma.syndicateMember.count({
     *   where: {
     *     // ... the filter for the SyndicateMembers we want to count
     *   }
     * })
    **/
    count<T extends SyndicateMemberCountArgs>(
      args?: Subset<T, SyndicateMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyndicateMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyndicateMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyndicateMemberAggregateArgs>(args: Subset<T, SyndicateMemberAggregateArgs>): Prisma.PrismaPromise<GetSyndicateMemberAggregateType<T>>

    /**
     * Group by SyndicateMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyndicateMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyndicateMemberGroupByArgs['orderBy'] }
        : { orderBy?: SyndicateMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyndicateMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyndicateMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyndicateMember model
   */
  readonly fields: SyndicateMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyndicateMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyndicateMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    syndicate<T extends SyndicateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyndicateDefaultArgs<ExtArgs>>): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SyndicateMember model
   */ 
  interface SyndicateMemberFieldRefs {
    readonly id: FieldRef<"SyndicateMember", 'String'>
    readonly syndicateId: FieldRef<"SyndicateMember", 'String'>
    readonly investorId: FieldRef<"SyndicateMember", 'String'>
    readonly amount: FieldRef<"SyndicateMember", 'Float'>
    readonly status: FieldRef<"SyndicateMember", 'SyndicateMemberStatus'>
    readonly joinedAt: FieldRef<"SyndicateMember", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SyndicateMember findUnique
   */
  export type SyndicateMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember findUniqueOrThrow
   */
  export type SyndicateMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember findFirst
   */
  export type SyndicateMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyndicateMembers.
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyndicateMembers.
     */
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * SyndicateMember findFirstOrThrow
   */
  export type SyndicateMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyndicateMembers.
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyndicateMembers.
     */
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * SyndicateMember findMany
   */
  export type SyndicateMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMembers to fetch.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyndicateMembers.
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * SyndicateMember create
   */
  export type SyndicateMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a SyndicateMember.
     */
    data: XOR<SyndicateMemberCreateInput, SyndicateMemberUncheckedCreateInput>
  }


  /**
   * SyndicateMember createMany
   */
  export type SyndicateMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyndicateMembers.
     */
    data: SyndicateMemberCreateManyInput | SyndicateMemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SyndicateMember update
   */
  export type SyndicateMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a SyndicateMember.
     */
    data: XOR<SyndicateMemberUpdateInput, SyndicateMemberUncheckedUpdateInput>
    /**
     * Choose, which SyndicateMember to update.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember updateMany
   */
  export type SyndicateMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyndicateMembers.
     */
    data: XOR<SyndicateMemberUpdateManyMutationInput, SyndicateMemberUncheckedUpdateManyInput>
    /**
     * Filter which SyndicateMembers to update
     */
    where?: SyndicateMemberWhereInput
  }


  /**
   * SyndicateMember upsert
   */
  export type SyndicateMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the SyndicateMember to update in case it exists.
     */
    where: SyndicateMemberWhereUniqueInput
    /**
     * In case the SyndicateMember found by the `where` argument doesn't exist, create a new SyndicateMember with this data.
     */
    create: XOR<SyndicateMemberCreateInput, SyndicateMemberUncheckedCreateInput>
    /**
     * In case the SyndicateMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyndicateMemberUpdateInput, SyndicateMemberUncheckedUpdateInput>
  }


  /**
   * SyndicateMember delete
   */
  export type SyndicateMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter which SyndicateMember to delete.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember deleteMany
   */
  export type SyndicateMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyndicateMembers to delete
     */
    where?: SyndicateMemberWhereInput
  }


  /**
   * SyndicateMember without action
   */
  export type SyndicateMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
  }



  /**
   * Model DueDiligence
   */

  export type AggregateDueDiligence = {
    _count: DueDiligenceCountAggregateOutputType | null
    _avg: DueDiligenceAvgAggregateOutputType | null
    _sum: DueDiligenceSumAggregateOutputType | null
    _min: DueDiligenceMinAggregateOutputType | null
    _max: DueDiligenceMaxAggregateOutputType | null
  }

  export type DueDiligenceAvgAggregateOutputType = {
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
  }

  export type DueDiligenceSumAggregateOutputType = {
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
  }

  export type DueDiligenceMinAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
    riskLevel: $Enums.RiskLevel | null
    status: $Enums.DueDiligenceStatus | null
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DueDiligenceMaxAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
    riskLevel: $Enums.RiskLevel | null
    status: $Enums.DueDiligenceStatus | null
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DueDiligenceCountAggregateOutputType = {
    id: number
    smeId: number
    advisorId: number
    financialScore: number
    teamScore: number
    marketScore: number
    productScore: number
    legalScore: number
    operationalScore: number
    overallScore: number
    riskLevel: number
    strengths: number
    weaknesses: number
    recommendations: number
    redFlags: number
    status: number
    completedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DueDiligenceAvgAggregateInputType = {
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
  }

  export type DueDiligenceSumAggregateInputType = {
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
  }

  export type DueDiligenceMinAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
    riskLevel?: true
    status?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DueDiligenceMaxAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
    riskLevel?: true
    status?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DueDiligenceCountAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
    riskLevel?: true
    strengths?: true
    weaknesses?: true
    recommendations?: true
    redFlags?: true
    status?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DueDiligenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DueDiligence to aggregate.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DueDiligences
    **/
    _count?: true | DueDiligenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DueDiligenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DueDiligenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DueDiligenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DueDiligenceMaxAggregateInputType
  }

  export type GetDueDiligenceAggregateType<T extends DueDiligenceAggregateArgs> = {
        [P in keyof T & keyof AggregateDueDiligence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDueDiligence[P]>
      : GetScalarType<T[P], AggregateDueDiligence[P]>
  }




  export type DueDiligenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceWhereInput
    orderBy?: DueDiligenceOrderByWithAggregationInput | DueDiligenceOrderByWithAggregationInput[]
    by: DueDiligenceScalarFieldEnum[] | DueDiligenceScalarFieldEnum
    having?: DueDiligenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DueDiligenceCountAggregateInputType | true
    _avg?: DueDiligenceAvgAggregateInputType
    _sum?: DueDiligenceSumAggregateInputType
    _min?: DueDiligenceMinAggregateInputType
    _max?: DueDiligenceMaxAggregateInputType
  }

  export type DueDiligenceGroupByOutputType = {
    id: string
    smeId: string
    advisorId: string | null
    financialScore: number
    teamScore: number
    marketScore: number
    productScore: number
    legalScore: number
    operationalScore: number
    overallScore: number
    riskLevel: $Enums.RiskLevel
    strengths: string[]
    weaknesses: string[]
    recommendations: string[]
    redFlags: string[]
    status: $Enums.DueDiligenceStatus
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DueDiligenceCountAggregateOutputType | null
    _avg: DueDiligenceAvgAggregateOutputType | null
    _sum: DueDiligenceSumAggregateOutputType | null
    _min: DueDiligenceMinAggregateOutputType | null
    _max: DueDiligenceMaxAggregateOutputType | null
  }

  type GetDueDiligenceGroupByPayload<T extends DueDiligenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DueDiligenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DueDiligenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DueDiligenceGroupByOutputType[P]>
            : GetScalarType<T[P], DueDiligenceGroupByOutputType[P]>
        }
      >
    >


  export type DueDiligenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    productScore?: boolean
    legalScore?: boolean
    operationalScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    redFlags?: boolean
    status?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | DueDiligence$advisorArgs<ExtArgs>
  }, ExtArgs["result"]["dueDiligence"]>

  export type DueDiligenceSelectScalar = {
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    productScore?: boolean
    legalScore?: boolean
    operationalScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    redFlags?: boolean
    status?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DueDiligenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | DueDiligence$advisorArgs<ExtArgs>
  }


  export type $DueDiligencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DueDiligence"
    objects: {
      sme: Prisma.$SMEPayload<ExtArgs>
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      smeId: string
      advisorId: string | null
      financialScore: number
      teamScore: number
      marketScore: number
      productScore: number
      legalScore: number
      operationalScore: number
      overallScore: number
      riskLevel: $Enums.RiskLevel
      strengths: string[]
      weaknesses: string[]
      recommendations: string[]
      redFlags: string[]
      status: $Enums.DueDiligenceStatus
      completedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dueDiligence"]>
    composites: {}
  }


  type DueDiligenceGetPayload<S extends boolean | null | undefined | DueDiligenceDefaultArgs> = $Result.GetResult<Prisma.$DueDiligencePayload, S>

  type DueDiligenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DueDiligenceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DueDiligenceCountAggregateInputType | true
    }

  export interface DueDiligenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DueDiligence'], meta: { name: 'DueDiligence' } }
    /**
     * Find zero or one DueDiligence that matches the filter.
     * @param {DueDiligenceFindUniqueArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DueDiligenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceFindUniqueArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DueDiligence that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DueDiligenceFindUniqueOrThrowArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DueDiligenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DueDiligence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceFindFirstArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DueDiligenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindFirstArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DueDiligence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceFindFirstOrThrowArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DueDiligenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DueDiligences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DueDiligences
     * const dueDiligences = await prisma.dueDiligence.findMany()
     * 
     * // Get first 10 DueDiligences
     * const dueDiligences = await prisma.dueDiligence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dueDiligenceWithIdOnly = await prisma.dueDiligence.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DueDiligenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DueDiligence.
     * @param {DueDiligenceCreateArgs} args - Arguments to create a DueDiligence.
     * @example
     * // Create one DueDiligence
     * const DueDiligence = await prisma.dueDiligence.create({
     *   data: {
     *     // ... data to create a DueDiligence
     *   }
     * })
     * 
    **/
    create<T extends DueDiligenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceCreateArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DueDiligences.
     *     @param {DueDiligenceCreateManyArgs} args - Arguments to create many DueDiligences.
     *     @example
     *     // Create many DueDiligences
     *     const dueDiligence = await prisma.dueDiligence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DueDiligenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DueDiligence.
     * @param {DueDiligenceDeleteArgs} args - Arguments to delete one DueDiligence.
     * @example
     * // Delete one DueDiligence
     * const DueDiligence = await prisma.dueDiligence.delete({
     *   where: {
     *     // ... filter to delete one DueDiligence
     *   }
     * })
     * 
    **/
    delete<T extends DueDiligenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceDeleteArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DueDiligence.
     * @param {DueDiligenceUpdateArgs} args - Arguments to update one DueDiligence.
     * @example
     * // Update one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DueDiligenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceUpdateArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DueDiligences.
     * @param {DueDiligenceDeleteManyArgs} args - Arguments to filter DueDiligences to delete.
     * @example
     * // Delete a few DueDiligences
     * const { count } = await prisma.dueDiligence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DueDiligenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DueDiligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DueDiligences
     * const dueDiligence = await prisma.dueDiligence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DueDiligenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DueDiligence.
     * @param {DueDiligenceUpsertArgs} args - Arguments to update or create a DueDiligence.
     * @example
     * // Update or create a DueDiligence
     * const dueDiligence = await prisma.dueDiligence.upsert({
     *   create: {
     *     // ... data to create a DueDiligence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DueDiligence we want to update
     *   }
     * })
    **/
    upsert<T extends DueDiligenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceUpsertArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DueDiligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceCountArgs} args - Arguments to filter DueDiligences to count.
     * @example
     * // Count the number of DueDiligences
     * const count = await prisma.dueDiligence.count({
     *   where: {
     *     // ... the filter for the DueDiligences we want to count
     *   }
     * })
    **/
    count<T extends DueDiligenceCountArgs>(
      args?: Subset<T, DueDiligenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DueDiligenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DueDiligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DueDiligenceAggregateArgs>(args: Subset<T, DueDiligenceAggregateArgs>): Prisma.PrismaPromise<GetDueDiligenceAggregateType<T>>

    /**
     * Group by DueDiligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DueDiligenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DueDiligenceGroupByArgs['orderBy'] }
        : { orderBy?: DueDiligenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DueDiligenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDueDiligenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DueDiligence model
   */
  readonly fields: DueDiligenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DueDiligence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DueDiligenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    advisor<T extends DueDiligence$advisorArgs<ExtArgs> = {}>(args?: Subset<T, DueDiligence$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DueDiligence model
   */ 
  interface DueDiligenceFieldRefs {
    readonly id: FieldRef<"DueDiligence", 'String'>
    readonly smeId: FieldRef<"DueDiligence", 'String'>
    readonly advisorId: FieldRef<"DueDiligence", 'String'>
    readonly financialScore: FieldRef<"DueDiligence", 'Float'>
    readonly teamScore: FieldRef<"DueDiligence", 'Float'>
    readonly marketScore: FieldRef<"DueDiligence", 'Float'>
    readonly productScore: FieldRef<"DueDiligence", 'Float'>
    readonly legalScore: FieldRef<"DueDiligence", 'Float'>
    readonly operationalScore: FieldRef<"DueDiligence", 'Float'>
    readonly overallScore: FieldRef<"DueDiligence", 'Float'>
    readonly riskLevel: FieldRef<"DueDiligence", 'RiskLevel'>
    readonly strengths: FieldRef<"DueDiligence", 'String[]'>
    readonly weaknesses: FieldRef<"DueDiligence", 'String[]'>
    readonly recommendations: FieldRef<"DueDiligence", 'String[]'>
    readonly redFlags: FieldRef<"DueDiligence", 'String[]'>
    readonly status: FieldRef<"DueDiligence", 'DueDiligenceStatus'>
    readonly completedAt: FieldRef<"DueDiligence", 'DateTime'>
    readonly expiresAt: FieldRef<"DueDiligence", 'DateTime'>
    readonly createdAt: FieldRef<"DueDiligence", 'DateTime'>
    readonly updatedAt: FieldRef<"DueDiligence", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DueDiligence findUnique
   */
  export type DueDiligenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence findUniqueOrThrow
   */
  export type DueDiligenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence findFirst
   */
  export type DueDiligenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDiligences.
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDiligences.
     */
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * DueDiligence findFirstOrThrow
   */
  export type DueDiligenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDiligences.
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDiligences.
     */
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * DueDiligence findMany
   */
  export type DueDiligenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligences to fetch.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DueDiligences.
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * DueDiligence create
   */
  export type DueDiligenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * The data needed to create a DueDiligence.
     */
    data: XOR<DueDiligenceCreateInput, DueDiligenceUncheckedCreateInput>
  }


  /**
   * DueDiligence createMany
   */
  export type DueDiligenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DueDiligences.
     */
    data: DueDiligenceCreateManyInput | DueDiligenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DueDiligence update
   */
  export type DueDiligenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * The data needed to update a DueDiligence.
     */
    data: XOR<DueDiligenceUpdateInput, DueDiligenceUncheckedUpdateInput>
    /**
     * Choose, which DueDiligence to update.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence updateMany
   */
  export type DueDiligenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DueDiligences.
     */
    data: XOR<DueDiligenceUpdateManyMutationInput, DueDiligenceUncheckedUpdateManyInput>
    /**
     * Filter which DueDiligences to update
     */
    where?: DueDiligenceWhereInput
  }


  /**
   * DueDiligence upsert
   */
  export type DueDiligenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * The filter to search for the DueDiligence to update in case it exists.
     */
    where: DueDiligenceWhereUniqueInput
    /**
     * In case the DueDiligence found by the `where` argument doesn't exist, create a new DueDiligence with this data.
     */
    create: XOR<DueDiligenceCreateInput, DueDiligenceUncheckedCreateInput>
    /**
     * In case the DueDiligence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DueDiligenceUpdateInput, DueDiligenceUncheckedUpdateInput>
  }


  /**
   * DueDiligence delete
   */
  export type DueDiligenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter which DueDiligence to delete.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence deleteMany
   */
  export type DueDiligenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DueDiligences to delete
     */
    where?: DueDiligenceWhereInput
  }


  /**
   * DueDiligence.advisor
   */
  export type DueDiligence$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * DueDiligence without action
   */
  export type DueDiligenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
  }



  /**
   * Model CommunityPost
   */

  export type AggregateCommunityPost = {
    _count: CommunityPostCountAggregateOutputType | null
    _avg: CommunityPostAvgAggregateOutputType | null
    _sum: CommunityPostSumAggregateOutputType | null
    _min: CommunityPostMinAggregateOutputType | null
    _max: CommunityPostMaxAggregateOutputType | null
  }

  export type CommunityPostAvgAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type CommunityPostSumAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type CommunityPostMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    category: $Enums.PostCategory | null
    smeId: string | null
    dealId: string | null
    syndicateId: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    isAnnouncement: boolean | null
    status: $Enums.PostStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityPostMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    category: $Enums.PostCategory | null
    smeId: string | null
    dealId: string | null
    syndicateId: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    isAnnouncement: boolean | null
    status: $Enums.PostStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityPostCountAggregateOutputType = {
    id: number
    tenantId: number
    authorId: number
    title: number
    content: number
    category: number
    smeId: number
    dealId: number
    syndicateId: number
    likes: number
    views: number
    isPinned: number
    isAnnouncement: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityPostAvgAggregateInputType = {
    likes?: true
    views?: true
  }

  export type CommunityPostSumAggregateInputType = {
    likes?: true
    views?: true
  }

  export type CommunityPostMinAggregateInputType = {
    id?: true
    tenantId?: true
    authorId?: true
    title?: true
    content?: true
    category?: true
    smeId?: true
    dealId?: true
    syndicateId?: true
    likes?: true
    views?: true
    isPinned?: true
    isAnnouncement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityPostMaxAggregateInputType = {
    id?: true
    tenantId?: true
    authorId?: true
    title?: true
    content?: true
    category?: true
    smeId?: true
    dealId?: true
    syndicateId?: true
    likes?: true
    views?: true
    isPinned?: true
    isAnnouncement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityPostCountAggregateInputType = {
    id?: true
    tenantId?: true
    authorId?: true
    title?: true
    content?: true
    category?: true
    smeId?: true
    dealId?: true
    syndicateId?: true
    likes?: true
    views?: true
    isPinned?: true
    isAnnouncement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPost to aggregate.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPosts
    **/
    _count?: true | CommunityPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityPostMaxAggregateInputType
  }

  export type GetCommunityPostAggregateType<T extends CommunityPostAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPost[P]>
      : GetScalarType<T[P], AggregateCommunityPost[P]>
  }




  export type CommunityPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPostWhereInput
    orderBy?: CommunityPostOrderByWithAggregationInput | CommunityPostOrderByWithAggregationInput[]
    by: CommunityPostScalarFieldEnum[] | CommunityPostScalarFieldEnum
    having?: CommunityPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityPostCountAggregateInputType | true
    _avg?: CommunityPostAvgAggregateInputType
    _sum?: CommunityPostSumAggregateInputType
    _min?: CommunityPostMinAggregateInputType
    _max?: CommunityPostMaxAggregateInputType
  }

  export type CommunityPostGroupByOutputType = {
    id: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category: $Enums.PostCategory
    smeId: string | null
    dealId: string | null
    syndicateId: string | null
    likes: number
    views: number
    isPinned: boolean
    isAnnouncement: boolean
    status: $Enums.PostStatus
    createdAt: Date
    updatedAt: Date
    _count: CommunityPostCountAggregateOutputType | null
    _avg: CommunityPostAvgAggregateOutputType | null
    _sum: CommunityPostSumAggregateOutputType | null
    _min: CommunityPostMinAggregateOutputType | null
    _max: CommunityPostMaxAggregateOutputType | null
  }

  type GetCommunityPostGroupByPayload<T extends CommunityPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
        }
      >
    >


  export type CommunityPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    smeId?: boolean
    dealId?: boolean
    syndicateId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | CommunityPost$commentsArgs<ExtArgs>
    _count?: boolean | CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityPost"]>

  export type CommunityPostSelectScalar = {
    id?: boolean
    tenantId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    smeId?: boolean
    dealId?: boolean
    syndicateId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | CommunityPost$commentsArgs<ExtArgs>
    _count?: boolean | CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommunityPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityPost"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      authorId: string
      title: string
      content: string
      category: $Enums.PostCategory
      smeId: string | null
      dealId: string | null
      syndicateId: string | null
      likes: number
      views: number
      isPinned: boolean
      isAnnouncement: boolean
      status: $Enums.PostStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityPost"]>
    composites: {}
  }


  type CommunityPostGetPayload<S extends boolean | null | undefined | CommunityPostDefaultArgs> = $Result.GetResult<Prisma.$CommunityPostPayload, S>

  type CommunityPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityPostFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CommunityPostCountAggregateInputType | true
    }

  export interface CommunityPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityPost'], meta: { name: 'CommunityPost' } }
    /**
     * Find zero or one CommunityPost that matches the filter.
     * @param {CommunityPostFindUniqueArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommunityPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityPostFindUniqueOrThrowArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommunityPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommunityPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstOrThrowArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommunityPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany()
     * 
     * // Get first 10 CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommunityPost.
     * @param {CommunityPostCreateArgs} args - Arguments to create a CommunityPost.
     * @example
     * // Create one CommunityPost
     * const CommunityPost = await prisma.communityPost.create({
     *   data: {
     *     // ... data to create a CommunityPost
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostCreateArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommunityPosts.
     *     @param {CommunityPostCreateManyArgs} args - Arguments to create many CommunityPosts.
     *     @example
     *     // Create many CommunityPosts
     *     const communityPost = await prisma.communityPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityPost.
     * @param {CommunityPostDeleteArgs} args - Arguments to delete one CommunityPost.
     * @example
     * // Delete one CommunityPost
     * const CommunityPost = await prisma.communityPost.delete({
     *   where: {
     *     // ... filter to delete one CommunityPost
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostDeleteArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommunityPost.
     * @param {CommunityPostUpdateArgs} args - Arguments to update one CommunityPost.
     * @example
     * // Update one CommunityPost
     * const communityPost = await prisma.communityPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostUpdateArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommunityPosts.
     * @param {CommunityPostDeleteManyArgs} args - Arguments to filter CommunityPosts to delete.
     * @example
     * // Delete a few CommunityPosts
     * const { count } = await prisma.communityPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPosts
     * const communityPost = await prisma.communityPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityPost.
     * @param {CommunityPostUpsertArgs} args - Arguments to update or create a CommunityPost.
     * @example
     * // Update or create a CommunityPost
     * const communityPost = await prisma.communityPost.upsert({
     *   create: {
     *     // ... data to create a CommunityPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPost we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostUpsertArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostCountArgs} args - Arguments to filter CommunityPosts to count.
     * @example
     * // Count the number of CommunityPosts
     * const count = await prisma.communityPost.count({
     *   where: {
     *     // ... the filter for the CommunityPosts we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostCountArgs>(
      args?: Subset<T, CommunityPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostAggregateArgs>(args: Subset<T, CommunityPostAggregateArgs>): Prisma.PrismaPromise<GetCommunityPostAggregateType<T>>

    /**
     * Group by CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPostGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityPost model
   */
  readonly fields: CommunityPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    comments<T extends CommunityPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommunityPost model
   */ 
  interface CommunityPostFieldRefs {
    readonly id: FieldRef<"CommunityPost", 'String'>
    readonly tenantId: FieldRef<"CommunityPost", 'String'>
    readonly authorId: FieldRef<"CommunityPost", 'String'>
    readonly title: FieldRef<"CommunityPost", 'String'>
    readonly content: FieldRef<"CommunityPost", 'String'>
    readonly category: FieldRef<"CommunityPost", 'PostCategory'>
    readonly smeId: FieldRef<"CommunityPost", 'String'>
    readonly dealId: FieldRef<"CommunityPost", 'String'>
    readonly syndicateId: FieldRef<"CommunityPost", 'String'>
    readonly likes: FieldRef<"CommunityPost", 'Int'>
    readonly views: FieldRef<"CommunityPost", 'Int'>
    readonly isPinned: FieldRef<"CommunityPost", 'Boolean'>
    readonly isAnnouncement: FieldRef<"CommunityPost", 'Boolean'>
    readonly status: FieldRef<"CommunityPost", 'PostStatus'>
    readonly createdAt: FieldRef<"CommunityPost", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityPost", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CommunityPost findUnique
   */
  export type CommunityPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost findUniqueOrThrow
   */
  export type CommunityPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost findFirst
   */
  export type CommunityPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
     */
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }


  /**
   * CommunityPost findFirstOrThrow
   */
  export type CommunityPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
     */
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }


  /**
   * CommunityPost findMany
   */
  export type CommunityPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPosts to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }


  /**
   * CommunityPost create
   */
  export type CommunityPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityPost.
     */
    data: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
  }


  /**
   * CommunityPost createMany
   */
  export type CommunityPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityPosts.
     */
    data: CommunityPostCreateManyInput | CommunityPostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CommunityPost update
   */
  export type CommunityPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityPost.
     */
    data: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
    /**
     * Choose, which CommunityPost to update.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost updateMany
   */
  export type CommunityPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityPosts.
     */
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyInput>
    /**
     * Filter which CommunityPosts to update
     */
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost upsert
   */
  export type CommunityPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityPost to update in case it exists.
     */
    where: CommunityPostWhereUniqueInput
    /**
     * In case the CommunityPost found by the `where` argument doesn't exist, create a new CommunityPost with this data.
     */
    create: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
    /**
     * In case the CommunityPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
  }


  /**
   * CommunityPost delete
   */
  export type CommunityPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter which CommunityPost to delete.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost deleteMany
   */
  export type CommunityPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPosts to delete
     */
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost.comments
   */
  export type CommunityPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * CommunityPost without action
   */
  export type CommunityPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    likes: number | null
  }

  export type CommentSumAggregateOutputType = {
    likes: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    parentId: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    parentId: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    parentId: number
    likes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    likes?: true
  }

  export type CommentSumAggregateInputType = {
    likes?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    parentId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    parentId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    parentId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    content: string
    parentId: string | null
    likes: number
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    parentId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    parentId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$CommunityPostPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      authorId: string
      content: string
      parentId: string | null
      likes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    post<T extends CommunityPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPostDefaultArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly likes: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }


  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model SecondaryListing
   */

  export type AggregateSecondaryListing = {
    _count: SecondaryListingCountAggregateOutputType | null
    _avg: SecondaryListingAvgAggregateOutputType | null
    _sum: SecondaryListingSumAggregateOutputType | null
    _min: SecondaryListingMinAggregateOutputType | null
    _max: SecondaryListingMaxAggregateOutputType | null
  }

  export type SecondaryListingAvgAggregateOutputType = {
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
  }

  export type SecondaryListingSumAggregateOutputType = {
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
  }

  export type SecondaryListingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sellerId: string | null
    dealInvestorId: string | null
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
    status: $Enums.ListingStatus | null
    listedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryListingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sellerId: string | null
    dealInvestorId: string | null
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
    status: $Enums.ListingStatus | null
    listedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryListingCountAggregateOutputType = {
    id: number
    tenantId: number
    sellerId: number
    dealInvestorId: number
    sharesAvailable: number
    pricePerShare: number
    minPurchase: number
    status: number
    listedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecondaryListingAvgAggregateInputType = {
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
  }

  export type SecondaryListingSumAggregateInputType = {
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
  }

  export type SecondaryListingMinAggregateInputType = {
    id?: true
    tenantId?: true
    sellerId?: true
    dealInvestorId?: true
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
    status?: true
    listedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryListingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    sellerId?: true
    dealInvestorId?: true
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
    status?: true
    listedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryListingCountAggregateInputType = {
    id?: true
    tenantId?: true
    sellerId?: true
    dealInvestorId?: true
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
    status?: true
    listedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecondaryListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryListing to aggregate.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecondaryListings
    **/
    _count?: true | SecondaryListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecondaryListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecondaryListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecondaryListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecondaryListingMaxAggregateInputType
  }

  export type GetSecondaryListingAggregateType<T extends SecondaryListingAggregateArgs> = {
        [P in keyof T & keyof AggregateSecondaryListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecondaryListing[P]>
      : GetScalarType<T[P], AggregateSecondaryListing[P]>
  }




  export type SecondaryListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryListingWhereInput
    orderBy?: SecondaryListingOrderByWithAggregationInput | SecondaryListingOrderByWithAggregationInput[]
    by: SecondaryListingScalarFieldEnum[] | SecondaryListingScalarFieldEnum
    having?: SecondaryListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecondaryListingCountAggregateInputType | true
    _avg?: SecondaryListingAvgAggregateInputType
    _sum?: SecondaryListingSumAggregateInputType
    _min?: SecondaryListingMinAggregateInputType
    _max?: SecondaryListingMaxAggregateInputType
  }

  export type SecondaryListingGroupByOutputType = {
    id: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase: number
    status: $Enums.ListingStatus
    listedAt: Date
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SecondaryListingCountAggregateOutputType | null
    _avg: SecondaryListingAvgAggregateOutputType | null
    _sum: SecondaryListingSumAggregateOutputType | null
    _min: SecondaryListingMinAggregateOutputType | null
    _max: SecondaryListingMaxAggregateOutputType | null
  }

  type GetSecondaryListingGroupByPayload<T extends SecondaryListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecondaryListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecondaryListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecondaryListingGroupByOutputType[P]>
            : GetScalarType<T[P], SecondaryListingGroupByOutputType[P]>
        }
      >
    >


  export type SecondaryListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    sellerId?: boolean
    dealInvestorId?: boolean
    sharesAvailable?: boolean
    pricePerShare?: boolean
    minPurchase?: boolean
    status?: boolean
    listedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trades?: boolean | SecondaryListing$tradesArgs<ExtArgs>
    _count?: boolean | SecondaryListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secondaryListing"]>

  export type SecondaryListingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    sellerId?: boolean
    dealInvestorId?: boolean
    sharesAvailable?: boolean
    pricePerShare?: boolean
    minPurchase?: boolean
    status?: boolean
    listedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecondaryListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trades?: boolean | SecondaryListing$tradesArgs<ExtArgs>
    _count?: boolean | SecondaryListingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SecondaryListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecondaryListing"
    objects: {
      trades: Prisma.$SecondaryTradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      sellerId: string
      dealInvestorId: string
      sharesAvailable: number
      pricePerShare: number
      minPurchase: number
      status: $Enums.ListingStatus
      listedAt: Date
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["secondaryListing"]>
    composites: {}
  }


  type SecondaryListingGetPayload<S extends boolean | null | undefined | SecondaryListingDefaultArgs> = $Result.GetResult<Prisma.$SecondaryListingPayload, S>

  type SecondaryListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecondaryListingFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SecondaryListingCountAggregateInputType | true
    }

  export interface SecondaryListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecondaryListing'], meta: { name: 'SecondaryListing' } }
    /**
     * Find zero or one SecondaryListing that matches the filter.
     * @param {SecondaryListingFindUniqueArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecondaryListingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingFindUniqueArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SecondaryListing that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SecondaryListingFindUniqueOrThrowArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecondaryListingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SecondaryListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingFindFirstArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecondaryListingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindFirstArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SecondaryListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingFindFirstOrThrowArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecondaryListingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SecondaryListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecondaryListings
     * const secondaryListings = await prisma.secondaryListing.findMany()
     * 
     * // Get first 10 SecondaryListings
     * const secondaryListings = await prisma.secondaryListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const secondaryListingWithIdOnly = await prisma.secondaryListing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecondaryListingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SecondaryListing.
     * @param {SecondaryListingCreateArgs} args - Arguments to create a SecondaryListing.
     * @example
     * // Create one SecondaryListing
     * const SecondaryListing = await prisma.secondaryListing.create({
     *   data: {
     *     // ... data to create a SecondaryListing
     *   }
     * })
     * 
    **/
    create<T extends SecondaryListingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingCreateArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SecondaryListings.
     *     @param {SecondaryListingCreateManyArgs} args - Arguments to create many SecondaryListings.
     *     @example
     *     // Create many SecondaryListings
     *     const secondaryListing = await prisma.secondaryListing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecondaryListingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecondaryListing.
     * @param {SecondaryListingDeleteArgs} args - Arguments to delete one SecondaryListing.
     * @example
     * // Delete one SecondaryListing
     * const SecondaryListing = await prisma.secondaryListing.delete({
     *   where: {
     *     // ... filter to delete one SecondaryListing
     *   }
     * })
     * 
    **/
    delete<T extends SecondaryListingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingDeleteArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SecondaryListing.
     * @param {SecondaryListingUpdateArgs} args - Arguments to update one SecondaryListing.
     * @example
     * // Update one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecondaryListingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingUpdateArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SecondaryListings.
     * @param {SecondaryListingDeleteManyArgs} args - Arguments to filter SecondaryListings to delete.
     * @example
     * // Delete a few SecondaryListings
     * const { count } = await prisma.secondaryListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecondaryListingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecondaryListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecondaryListings
     * const secondaryListing = await prisma.secondaryListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecondaryListingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecondaryListing.
     * @param {SecondaryListingUpsertArgs} args - Arguments to update or create a SecondaryListing.
     * @example
     * // Update or create a SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.upsert({
     *   create: {
     *     // ... data to create a SecondaryListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecondaryListing we want to update
     *   }
     * })
    **/
    upsert<T extends SecondaryListingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingUpsertArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SecondaryListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingCountArgs} args - Arguments to filter SecondaryListings to count.
     * @example
     * // Count the number of SecondaryListings
     * const count = await prisma.secondaryListing.count({
     *   where: {
     *     // ... the filter for the SecondaryListings we want to count
     *   }
     * })
    **/
    count<T extends SecondaryListingCountArgs>(
      args?: Subset<T, SecondaryListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecondaryListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecondaryListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecondaryListingAggregateArgs>(args: Subset<T, SecondaryListingAggregateArgs>): Prisma.PrismaPromise<GetSecondaryListingAggregateType<T>>

    /**
     * Group by SecondaryListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecondaryListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecondaryListingGroupByArgs['orderBy'] }
        : { orderBy?: SecondaryListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecondaryListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecondaryListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecondaryListing model
   */
  readonly fields: SecondaryListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecondaryListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecondaryListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    trades<T extends SecondaryListing$tradesArgs<ExtArgs> = {}>(args?: Subset<T, SecondaryListing$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SecondaryListing model
   */ 
  interface SecondaryListingFieldRefs {
    readonly id: FieldRef<"SecondaryListing", 'String'>
    readonly tenantId: FieldRef<"SecondaryListing", 'String'>
    readonly sellerId: FieldRef<"SecondaryListing", 'String'>
    readonly dealInvestorId: FieldRef<"SecondaryListing", 'String'>
    readonly sharesAvailable: FieldRef<"SecondaryListing", 'Float'>
    readonly pricePerShare: FieldRef<"SecondaryListing", 'Float'>
    readonly minPurchase: FieldRef<"SecondaryListing", 'Float'>
    readonly status: FieldRef<"SecondaryListing", 'ListingStatus'>
    readonly listedAt: FieldRef<"SecondaryListing", 'DateTime'>
    readonly expiresAt: FieldRef<"SecondaryListing", 'DateTime'>
    readonly createdAt: FieldRef<"SecondaryListing", 'DateTime'>
    readonly updatedAt: FieldRef<"SecondaryListing", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SecondaryListing findUnique
   */
  export type SecondaryListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing findUniqueOrThrow
   */
  export type SecondaryListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing findFirst
   */
  export type SecondaryListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryListings.
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryListings.
     */
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * SecondaryListing findFirstOrThrow
   */
  export type SecondaryListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryListings.
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryListings.
     */
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * SecondaryListing findMany
   */
  export type SecondaryListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListings to fetch.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecondaryListings.
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * SecondaryListing create
   */
  export type SecondaryListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * The data needed to create a SecondaryListing.
     */
    data: XOR<SecondaryListingCreateInput, SecondaryListingUncheckedCreateInput>
  }


  /**
   * SecondaryListing createMany
   */
  export type SecondaryListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecondaryListings.
     */
    data: SecondaryListingCreateManyInput | SecondaryListingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SecondaryListing update
   */
  export type SecondaryListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * The data needed to update a SecondaryListing.
     */
    data: XOR<SecondaryListingUpdateInput, SecondaryListingUncheckedUpdateInput>
    /**
     * Choose, which SecondaryListing to update.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing updateMany
   */
  export type SecondaryListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecondaryListings.
     */
    data: XOR<SecondaryListingUpdateManyMutationInput, SecondaryListingUncheckedUpdateManyInput>
    /**
     * Filter which SecondaryListings to update
     */
    where?: SecondaryListingWhereInput
  }


  /**
   * SecondaryListing upsert
   */
  export type SecondaryListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * The filter to search for the SecondaryListing to update in case it exists.
     */
    where: SecondaryListingWhereUniqueInput
    /**
     * In case the SecondaryListing found by the `where` argument doesn't exist, create a new SecondaryListing with this data.
     */
    create: XOR<SecondaryListingCreateInput, SecondaryListingUncheckedCreateInput>
    /**
     * In case the SecondaryListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecondaryListingUpdateInput, SecondaryListingUncheckedUpdateInput>
  }


  /**
   * SecondaryListing delete
   */
  export type SecondaryListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter which SecondaryListing to delete.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing deleteMany
   */
  export type SecondaryListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryListings to delete
     */
    where?: SecondaryListingWhereInput
  }


  /**
   * SecondaryListing.trades
   */
  export type SecondaryListing$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    where?: SecondaryTradeWhereInput
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    cursor?: SecondaryTradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryListing without action
   */
  export type SecondaryListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
  }



  /**
   * Model SecondaryTrade
   */

  export type AggregateSecondaryTrade = {
    _count: SecondaryTradeCountAggregateOutputType | null
    _avg: SecondaryTradeAvgAggregateOutputType | null
    _sum: SecondaryTradeSumAggregateOutputType | null
    _min: SecondaryTradeMinAggregateOutputType | null
    _max: SecondaryTradeMaxAggregateOutputType | null
  }

  export type SecondaryTradeAvgAggregateOutputType = {
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
  }

  export type SecondaryTradeSumAggregateOutputType = {
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
  }

  export type SecondaryTradeMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    buyerId: string | null
    sellerId: string | null
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
    status: $Enums.TradeStatus | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryTradeMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    buyerId: string | null
    sellerId: string | null
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
    status: $Enums.TradeStatus | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryTradeCountAggregateOutputType = {
    id: number
    listingId: number
    buyerId: number
    sellerId: number
    shares: number
    pricePerShare: number
    totalAmount: number
    fee: number
    status: number
    executedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecondaryTradeAvgAggregateInputType = {
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
  }

  export type SecondaryTradeSumAggregateInputType = {
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
  }

  export type SecondaryTradeMinAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryTradeMaxAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryTradeCountAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecondaryTradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryTrade to aggregate.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecondaryTrades
    **/
    _count?: true | SecondaryTradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecondaryTradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecondaryTradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecondaryTradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecondaryTradeMaxAggregateInputType
  }

  export type GetSecondaryTradeAggregateType<T extends SecondaryTradeAggregateArgs> = {
        [P in keyof T & keyof AggregateSecondaryTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecondaryTrade[P]>
      : GetScalarType<T[P], AggregateSecondaryTrade[P]>
  }




  export type SecondaryTradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryTradeWhereInput
    orderBy?: SecondaryTradeOrderByWithAggregationInput | SecondaryTradeOrderByWithAggregationInput[]
    by: SecondaryTradeScalarFieldEnum[] | SecondaryTradeScalarFieldEnum
    having?: SecondaryTradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecondaryTradeCountAggregateInputType | true
    _avg?: SecondaryTradeAvgAggregateInputType
    _sum?: SecondaryTradeSumAggregateInputType
    _min?: SecondaryTradeMinAggregateInputType
    _max?: SecondaryTradeMaxAggregateInputType
  }

  export type SecondaryTradeGroupByOutputType = {
    id: string
    listingId: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee: number
    status: $Enums.TradeStatus
    executedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SecondaryTradeCountAggregateOutputType | null
    _avg: SecondaryTradeAvgAggregateOutputType | null
    _sum: SecondaryTradeSumAggregateOutputType | null
    _min: SecondaryTradeMinAggregateOutputType | null
    _max: SecondaryTradeMaxAggregateOutputType | null
  }

  type GetSecondaryTradeGroupByPayload<T extends SecondaryTradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecondaryTradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecondaryTradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecondaryTradeGroupByOutputType[P]>
            : GetScalarType<T[P], SecondaryTradeGroupByOutputType[P]>
        }
      >
    >


  export type SecondaryTradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    shares?: boolean
    pricePerShare?: boolean
    totalAmount?: boolean
    fee?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listing?: boolean | SecondaryListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secondaryTrade"]>

  export type SecondaryTradeSelectScalar = {
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    shares?: boolean
    pricePerShare?: boolean
    totalAmount?: boolean
    fee?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecondaryTradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | SecondaryListingDefaultArgs<ExtArgs>
  }


  export type $SecondaryTradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecondaryTrade"
    objects: {
      listing: Prisma.$SecondaryListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      buyerId: string
      sellerId: string
      shares: number
      pricePerShare: number
      totalAmount: number
      fee: number
      status: $Enums.TradeStatus
      executedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["secondaryTrade"]>
    composites: {}
  }


  type SecondaryTradeGetPayload<S extends boolean | null | undefined | SecondaryTradeDefaultArgs> = $Result.GetResult<Prisma.$SecondaryTradePayload, S>

  type SecondaryTradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecondaryTradeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SecondaryTradeCountAggregateInputType | true
    }

  export interface SecondaryTradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecondaryTrade'], meta: { name: 'SecondaryTrade' } }
    /**
     * Find zero or one SecondaryTrade that matches the filter.
     * @param {SecondaryTradeFindUniqueArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecondaryTradeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeFindUniqueArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SecondaryTrade that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SecondaryTradeFindUniqueOrThrowArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecondaryTradeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SecondaryTrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeFindFirstArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecondaryTradeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindFirstArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SecondaryTrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeFindFirstOrThrowArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecondaryTradeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SecondaryTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecondaryTrades
     * const secondaryTrades = await prisma.secondaryTrade.findMany()
     * 
     * // Get first 10 SecondaryTrades
     * const secondaryTrades = await prisma.secondaryTrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const secondaryTradeWithIdOnly = await prisma.secondaryTrade.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecondaryTradeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SecondaryTrade.
     * @param {SecondaryTradeCreateArgs} args - Arguments to create a SecondaryTrade.
     * @example
     * // Create one SecondaryTrade
     * const SecondaryTrade = await prisma.secondaryTrade.create({
     *   data: {
     *     // ... data to create a SecondaryTrade
     *   }
     * })
     * 
    **/
    create<T extends SecondaryTradeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeCreateArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SecondaryTrades.
     *     @param {SecondaryTradeCreateManyArgs} args - Arguments to create many SecondaryTrades.
     *     @example
     *     // Create many SecondaryTrades
     *     const secondaryTrade = await prisma.secondaryTrade.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecondaryTradeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecondaryTrade.
     * @param {SecondaryTradeDeleteArgs} args - Arguments to delete one SecondaryTrade.
     * @example
     * // Delete one SecondaryTrade
     * const SecondaryTrade = await prisma.secondaryTrade.delete({
     *   where: {
     *     // ... filter to delete one SecondaryTrade
     *   }
     * })
     * 
    **/
    delete<T extends SecondaryTradeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeDeleteArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SecondaryTrade.
     * @param {SecondaryTradeUpdateArgs} args - Arguments to update one SecondaryTrade.
     * @example
     * // Update one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecondaryTradeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeUpdateArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SecondaryTrades.
     * @param {SecondaryTradeDeleteManyArgs} args - Arguments to filter SecondaryTrades to delete.
     * @example
     * // Delete a few SecondaryTrades
     * const { count } = await prisma.secondaryTrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecondaryTradeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecondaryTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecondaryTrades
     * const secondaryTrade = await prisma.secondaryTrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecondaryTradeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecondaryTrade.
     * @param {SecondaryTradeUpsertArgs} args - Arguments to update or create a SecondaryTrade.
     * @example
     * // Update or create a SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.upsert({
     *   create: {
     *     // ... data to create a SecondaryTrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecondaryTrade we want to update
     *   }
     * })
    **/
    upsert<T extends SecondaryTradeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeUpsertArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SecondaryTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeCountArgs} args - Arguments to filter SecondaryTrades to count.
     * @example
     * // Count the number of SecondaryTrades
     * const count = await prisma.secondaryTrade.count({
     *   where: {
     *     // ... the filter for the SecondaryTrades we want to count
     *   }
     * })
    **/
    count<T extends SecondaryTradeCountArgs>(
      args?: Subset<T, SecondaryTradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecondaryTradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecondaryTrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecondaryTradeAggregateArgs>(args: Subset<T, SecondaryTradeAggregateArgs>): Prisma.PrismaPromise<GetSecondaryTradeAggregateType<T>>

    /**
     * Group by SecondaryTrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecondaryTradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecondaryTradeGroupByArgs['orderBy'] }
        : { orderBy?: SecondaryTradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecondaryTradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecondaryTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecondaryTrade model
   */
  readonly fields: SecondaryTradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecondaryTrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecondaryTradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    listing<T extends SecondaryListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SecondaryListingDefaultArgs<ExtArgs>>): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SecondaryTrade model
   */ 
  interface SecondaryTradeFieldRefs {
    readonly id: FieldRef<"SecondaryTrade", 'String'>
    readonly listingId: FieldRef<"SecondaryTrade", 'String'>
    readonly buyerId: FieldRef<"SecondaryTrade", 'String'>
    readonly sellerId: FieldRef<"SecondaryTrade", 'String'>
    readonly shares: FieldRef<"SecondaryTrade", 'Float'>
    readonly pricePerShare: FieldRef<"SecondaryTrade", 'Float'>
    readonly totalAmount: FieldRef<"SecondaryTrade", 'Float'>
    readonly fee: FieldRef<"SecondaryTrade", 'Float'>
    readonly status: FieldRef<"SecondaryTrade", 'TradeStatus'>
    readonly executedAt: FieldRef<"SecondaryTrade", 'DateTime'>
    readonly createdAt: FieldRef<"SecondaryTrade", 'DateTime'>
    readonly updatedAt: FieldRef<"SecondaryTrade", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SecondaryTrade findUnique
   */
  export type SecondaryTradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade findUniqueOrThrow
   */
  export type SecondaryTradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade findFirst
   */
  export type SecondaryTradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryTrades.
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryTrades.
     */
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryTrade findFirstOrThrow
   */
  export type SecondaryTradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryTrades.
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryTrades.
     */
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryTrade findMany
   */
  export type SecondaryTradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrades to fetch.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecondaryTrades.
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryTrade create
   */
  export type SecondaryTradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * The data needed to create a SecondaryTrade.
     */
    data: XOR<SecondaryTradeCreateInput, SecondaryTradeUncheckedCreateInput>
  }


  /**
   * SecondaryTrade createMany
   */
  export type SecondaryTradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecondaryTrades.
     */
    data: SecondaryTradeCreateManyInput | SecondaryTradeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SecondaryTrade update
   */
  export type SecondaryTradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * The data needed to update a SecondaryTrade.
     */
    data: XOR<SecondaryTradeUpdateInput, SecondaryTradeUncheckedUpdateInput>
    /**
     * Choose, which SecondaryTrade to update.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade updateMany
   */
  export type SecondaryTradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecondaryTrades.
     */
    data: XOR<SecondaryTradeUpdateManyMutationInput, SecondaryTradeUncheckedUpdateManyInput>
    /**
     * Filter which SecondaryTrades to update
     */
    where?: SecondaryTradeWhereInput
  }


  /**
   * SecondaryTrade upsert
   */
  export type SecondaryTradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * The filter to search for the SecondaryTrade to update in case it exists.
     */
    where: SecondaryTradeWhereUniqueInput
    /**
     * In case the SecondaryTrade found by the `where` argument doesn't exist, create a new SecondaryTrade with this data.
     */
    create: XOR<SecondaryTradeCreateInput, SecondaryTradeUncheckedCreateInput>
    /**
     * In case the SecondaryTrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecondaryTradeUpdateInput, SecondaryTradeUncheckedUpdateInput>
  }


  /**
   * SecondaryTrade delete
   */
  export type SecondaryTradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter which SecondaryTrade to delete.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade deleteMany
   */
  export type SecondaryTradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryTrades to delete
     */
    where?: SecondaryTradeWhereInput
  }


  /**
   * SecondaryTrade without action
   */
  export type SecondaryTradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    type: number
    title: number
    message: number
    read: number
    actionUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read: boolean
    actionUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      read: boolean
      actionUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    language: 'language',
    did: 'did',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SMEScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    sector: 'sector',
    stage: 'stage',
    fundingRequired: 'fundingRequired',
    description: 'description',
    website: 'website',
    location: 'location',
    score: 'score',
    certified: 'certified',
    certificationDate: 'certificationDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SMEScalarFieldEnum = (typeof SMEScalarFieldEnum)[keyof typeof SMEScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    type: 'type',
    kycStatus: 'kycStatus',
    preferences: 'preferences',
    portfolio: 'portfolio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const AdvisorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    specialization: 'specialization',
    certificationList: 'certificationList',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdvisorScalarFieldEnum = (typeof AdvisorScalarFieldEnum)[keyof typeof AdvisorScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    smeId: 'smeId',
    title: 'title',
    description: 'description',
    amount: 'amount',
    equity: 'equity',
    status: 'status',
    successFee: 'successFee',
    terms: 'terms',
    isDocumentLocked: 'isDocumentLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const DealInvestorScalarFieldEnum: {
    id: 'id',
    dealId: 'dealId',
    investorId: 'investorId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealInvestorScalarFieldEnum = (typeof DealInvestorScalarFieldEnum)[keyof typeof DealInvestorScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    type: 'type',
    url: 'url',
    size: 'size',
    mimeType: 'mimeType',
    smeId: 'smeId',
    dealId: 'dealId',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    smeId: 'smeId',
    advisorId: 'advisorId',
    status: 'status',
    score: 'score',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    status: 'status',
    data: 'data',
    smeId: 'smeId',
    investorId: 'investorId',
    advisorId: 'advisorId',
    dealId: 'dealId',
    didWorkflowId: 'didWorkflowId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const SyndicateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    leadInvestorId: 'leadInvestorId',
    targetAmount: 'targetAmount',
    minInvestment: 'minInvestment',
    maxInvestment: 'maxInvestment',
    managementFee: 'managementFee',
    carryFee: 'carryFee',
    status: 'status',
    dealId: 'dealId',
    closingDate: 'closingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SyndicateScalarFieldEnum = (typeof SyndicateScalarFieldEnum)[keyof typeof SyndicateScalarFieldEnum]


  export const SyndicateMemberScalarFieldEnum: {
    id: 'id',
    syndicateId: 'syndicateId',
    investorId: 'investorId',
    amount: 'amount',
    status: 'status',
    joinedAt: 'joinedAt'
  };

  export type SyndicateMemberScalarFieldEnum = (typeof SyndicateMemberScalarFieldEnum)[keyof typeof SyndicateMemberScalarFieldEnum]


  export const DueDiligenceScalarFieldEnum: {
    id: 'id',
    smeId: 'smeId',
    advisorId: 'advisorId',
    financialScore: 'financialScore',
    teamScore: 'teamScore',
    marketScore: 'marketScore',
    productScore: 'productScore',
    legalScore: 'legalScore',
    operationalScore: 'operationalScore',
    overallScore: 'overallScore',
    riskLevel: 'riskLevel',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    recommendations: 'recommendations',
    redFlags: 'redFlags',
    status: 'status',
    completedAt: 'completedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DueDiligenceScalarFieldEnum = (typeof DueDiligenceScalarFieldEnum)[keyof typeof DueDiligenceScalarFieldEnum]


  export const CommunityPostScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    authorId: 'authorId',
    title: 'title',
    content: 'content',
    category: 'category',
    smeId: 'smeId',
    dealId: 'dealId',
    syndicateId: 'syndicateId',
    likes: 'likes',
    views: 'views',
    isPinned: 'isPinned',
    isAnnouncement: 'isAnnouncement',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityPostScalarFieldEnum = (typeof CommunityPostScalarFieldEnum)[keyof typeof CommunityPostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    parentId: 'parentId',
    likes: 'likes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SecondaryListingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    sellerId: 'sellerId',
    dealInvestorId: 'dealInvestorId',
    sharesAvailable: 'sharesAvailable',
    pricePerShare: 'pricePerShare',
    minPurchase: 'minPurchase',
    status: 'status',
    listedAt: 'listedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecondaryListingScalarFieldEnum = (typeof SecondaryListingScalarFieldEnum)[keyof typeof SecondaryListingScalarFieldEnum]


  export const SecondaryTradeScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    buyerId: 'buyerId',
    sellerId: 'sellerId',
    shares: 'shares',
    pricePerShare: 'pricePerShare',
    totalAmount: 'totalAmount',
    fee: 'fee',
    status: 'status',
    executedAt: 'executedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecondaryTradeScalarFieldEnum = (typeof SecondaryTradeScalarFieldEnum)[keyof typeof SecondaryTradeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    actionUrl: 'actionUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'SMEStage'
   */
  export type EnumSMEStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStage'>
    


  /**
   * Reference to a field of type 'SMEStage[]'
   */
  export type ListEnumSMEStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStage[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SMEStatus'
   */
  export type EnumSMEStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStatus'>
    


  /**
   * Reference to a field of type 'SMEStatus[]'
   */
  export type ListEnumSMEStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStatus[]'>
    


  /**
   * Reference to a field of type 'InvestorType'
   */
  export type EnumInvestorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestorType'>
    


  /**
   * Reference to a field of type 'InvestorType[]'
   */
  export type ListEnumInvestorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestorType[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'AdvisorStatus'
   */
  export type EnumAdvisorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvisorStatus'>
    


  /**
   * Reference to a field of type 'AdvisorStatus[]'
   */
  export type ListEnumAdvisorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvisorStatus[]'>
    


  /**
   * Reference to a field of type 'DealStatus'
   */
  export type EnumDealStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealStatus'>
    


  /**
   * Reference to a field of type 'DealStatus[]'
   */
  export type ListEnumDealStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealStatus[]'>
    


  /**
   * Reference to a field of type 'InvestmentStatus'
   */
  export type EnumInvestmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestmentStatus'>
    


  /**
   * Reference to a field of type 'InvestmentStatus[]'
   */
  export type ListEnumInvestmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestmentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CertificationStatus'
   */
  export type EnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus'>
    


  /**
   * Reference to a field of type 'CertificationStatus[]'
   */
  export type ListEnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowType'
   */
  export type EnumWorkflowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowType'>
    


  /**
   * Reference to a field of type 'WorkflowType[]'
   */
  export type ListEnumWorkflowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowType[]'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


  /**
   * Reference to a field of type 'SyndicateStatus'
   */
  export type EnumSyndicateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateStatus'>
    


  /**
   * Reference to a field of type 'SyndicateStatus[]'
   */
  export type ListEnumSyndicateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateStatus[]'>
    


  /**
   * Reference to a field of type 'SyndicateMemberStatus'
   */
  export type EnumSyndicateMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateMemberStatus'>
    


  /**
   * Reference to a field of type 'SyndicateMemberStatus[]'
   */
  export type ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateMemberStatus[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'DueDiligenceStatus'
   */
  export type EnumDueDiligenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DueDiligenceStatus'>
    


  /**
   * Reference to a field of type 'DueDiligenceStatus[]'
   */
  export type ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DueDiligenceStatus[]'>
    


  /**
   * Reference to a field of type 'PostCategory'
   */
  export type EnumPostCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostCategory'>
    


  /**
   * Reference to a field of type 'PostCategory[]'
   */
  export type ListEnumPostCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostCategory[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'TradeStatus'
   */
  export type EnumTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeStatus'>
    


  /**
   * Reference to a field of type 'TradeStatus[]'
   */
  export type ListEnumTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    smes?: SMEListRelationFilter
    investors?: InvestorListRelationFilter
    advisors?: AdvisorListRelationFilter
    deals?: DealListRelationFilter
    workflows?: WorkflowListRelationFilter
    documents?: DocumentListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    smes?: SMEOrderByRelationAggregateInput
    investors?: InvestorOrderByRelationAggregateInput
    advisors?: AdvisorOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    smes?: SMEListRelationFilter
    investors?: InvestorListRelationFilter
    advisors?: AdvisorListRelationFilter
    deals?: DealListRelationFilter
    workflows?: WorkflowListRelationFilter
    documents?: DocumentListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    settings?: JsonWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageWithAggregatesFilter<"User"> | $Enums.Language
    did?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SMEWhereInput = {
    AND?: SMEWhereInput | SMEWhereInput[]
    OR?: SMEWhereInput[]
    NOT?: SMEWhereInput | SMEWhereInput[]
    id?: StringFilter<"SME"> | string
    tenantId?: StringFilter<"SME"> | string
    userId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: DocumentListRelationFilter
    deals?: DealListRelationFilter
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
  }

  export type SMEOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    certified?: SortOrder
    certificationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    dueDiligences?: DueDiligenceOrderByRelationAggregateInput
  }

  export type SMEWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SMEWhereInput | SMEWhereInput[]
    OR?: SMEWhereInput[]
    NOT?: SMEWhereInput | SMEWhereInput[]
    tenantId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: DocumentListRelationFilter
    deals?: DealListRelationFilter
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
  }, "id" | "userId">

  export type SMEOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    certified?: SortOrder
    certificationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SMECountOrderByAggregateInput
    _avg?: SMEAvgOrderByAggregateInput
    _max?: SMEMaxOrderByAggregateInput
    _min?: SMEMinOrderByAggregateInput
    _sum?: SMESumOrderByAggregateInput
  }

  export type SMEScalarWhereWithAggregatesInput = {
    AND?: SMEScalarWhereWithAggregatesInput | SMEScalarWhereWithAggregatesInput[]
    OR?: SMEScalarWhereWithAggregatesInput[]
    NOT?: SMEScalarWhereWithAggregatesInput | SMEScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SME"> | string
    tenantId?: StringWithAggregatesFilter<"SME"> | string
    userId?: StringWithAggregatesFilter<"SME"> | string
    name?: StringWithAggregatesFilter<"SME"> | string
    sector?: StringWithAggregatesFilter<"SME"> | string
    stage?: EnumSMEStageWithAggregatesFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatWithAggregatesFilter<"SME"> | number
    description?: StringNullableWithAggregatesFilter<"SME"> | string | null
    website?: StringNullableWithAggregatesFilter<"SME"> | string | null
    location?: StringNullableWithAggregatesFilter<"SME"> | string | null
    score?: FloatNullableWithAggregatesFilter<"SME"> | number | null
    certified?: BoolWithAggregatesFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableWithAggregatesFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusWithAggregatesFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeWithAggregatesFilter<"SME"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SME"> | Date | string
  }

  export type InvestorWhereInput = {
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    id?: StringFilter<"Investor"> | string
    tenantId?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestments?: DealInvestorListRelationFilter
    workflows?: WorkflowListRelationFilter
    leadSyndicates?: SyndicateListRelationFilter
    syndicateMemberships?: SyndicateMemberListRelationFilter
  }

  export type InvestorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    dealInvestments?: DealInvestorOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    leadSyndicates?: SyndicateOrderByRelationAggregateInput
    syndicateMemberships?: SyndicateMemberOrderByRelationAggregateInput
  }

  export type InvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    tenantId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestments?: DealInvestorListRelationFilter
    workflows?: WorkflowListRelationFilter
    leadSyndicates?: SyndicateListRelationFilter
    syndicateMemberships?: SyndicateMemberListRelationFilter
  }, "id" | "userId">

  export type InvestorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorCountOrderByAggregateInput
    _max?: InvestorMaxOrderByAggregateInput
    _min?: InvestorMinOrderByAggregateInput
  }

  export type InvestorScalarWhereWithAggregatesInput = {
    AND?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    OR?: InvestorScalarWhereWithAggregatesInput[]
    NOT?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investor"> | string
    tenantId?: StringWithAggregatesFilter<"Investor"> | string
    userId?: StringWithAggregatesFilter<"Investor"> | string
    name?: StringWithAggregatesFilter<"Investor"> | string
    type?: EnumInvestorTypeWithAggregatesFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusWithAggregatesFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonWithAggregatesFilter<"Investor">
    portfolio?: JsonWithAggregatesFilter<"Investor">
    createdAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
  }

  export type AdvisorWhereInput = {
    AND?: AdvisorWhereInput | AdvisorWhereInput[]
    OR?: AdvisorWhereInput[]
    NOT?: AdvisorWhereInput | AdvisorWhereInput[]
    id?: StringFilter<"Advisor"> | string
    tenantId?: StringFilter<"Advisor"> | string
    userId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
  }

  export type AdvisorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    certifications?: CertificationOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    dueDiligences?: DueDiligenceOrderByRelationAggregateInput
  }

  export type AdvisorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdvisorWhereInput | AdvisorWhereInput[]
    OR?: AdvisorWhereInput[]
    NOT?: AdvisorWhereInput | AdvisorWhereInput[]
    tenantId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
  }, "id" | "userId">

  export type AdvisorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdvisorCountOrderByAggregateInput
    _max?: AdvisorMaxOrderByAggregateInput
    _min?: AdvisorMinOrderByAggregateInput
  }

  export type AdvisorScalarWhereWithAggregatesInput = {
    AND?: AdvisorScalarWhereWithAggregatesInput | AdvisorScalarWhereWithAggregatesInput[]
    OR?: AdvisorScalarWhereWithAggregatesInput[]
    NOT?: AdvisorScalarWhereWithAggregatesInput | AdvisorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Advisor"> | string
    tenantId?: StringWithAggregatesFilter<"Advisor"> | string
    userId?: StringWithAggregatesFilter<"Advisor"> | string
    name?: StringWithAggregatesFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusWithAggregatesFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeWithAggregatesFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Advisor"> | Date | string
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    terms?: StringNullableFilter<"Deal"> | string | null
    isDocumentLocked?: BoolFilter<"Deal"> | boolean
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investors?: DealInvestorListRelationFilter
    documents?: DocumentListRelationFilter
    workflows?: WorkflowListRelationFilter
    syndicates?: SyndicateListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    equity?: SortOrderInput | SortOrder
    status?: SortOrder
    successFee?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investors?: DealInvestorOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    syndicates?: SyndicateOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    terms?: StringNullableFilter<"Deal"> | string | null
    isDocumentLocked?: BoolFilter<"Deal"> | boolean
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investors?: DealInvestorListRelationFilter
    documents?: DocumentListRelationFilter
    workflows?: WorkflowListRelationFilter
    syndicates?: SyndicateListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    equity?: SortOrderInput | SortOrder
    status?: SortOrder
    successFee?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    tenantId?: StringWithAggregatesFilter<"Deal"> | string
    smeId?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    description?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    amount?: FloatWithAggregatesFilter<"Deal"> | number
    equity?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    status?: EnumDealStatusWithAggregatesFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    terms?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    isDocumentLocked?: BoolWithAggregatesFilter<"Deal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
  }

  export type DealInvestorWhereInput = {
    AND?: DealInvestorWhereInput | DealInvestorWhereInput[]
    OR?: DealInvestorWhereInput[]
    NOT?: DealInvestorWhereInput | DealInvestorWhereInput[]
    id?: StringFilter<"DealInvestor"> | string
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
    deal?: XOR<DealRelationFilter, DealWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }

  export type DealInvestorOrderByWithRelationInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deal?: DealOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
  }

  export type DealInvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dealId_investorId?: DealInvestorDealIdInvestorIdCompoundUniqueInput
    AND?: DealInvestorWhereInput | DealInvestorWhereInput[]
    OR?: DealInvestorWhereInput[]
    NOT?: DealInvestorWhereInput | DealInvestorWhereInput[]
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
    deal?: XOR<DealRelationFilter, DealWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }, "id" | "dealId_investorId">

  export type DealInvestorOrderByWithAggregationInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealInvestorCountOrderByAggregateInput
    _avg?: DealInvestorAvgOrderByAggregateInput
    _max?: DealInvestorMaxOrderByAggregateInput
    _min?: DealInvestorMinOrderByAggregateInput
    _sum?: DealInvestorSumOrderByAggregateInput
  }

  export type DealInvestorScalarWhereWithAggregatesInput = {
    AND?: DealInvestorScalarWhereWithAggregatesInput | DealInvestorScalarWhereWithAggregatesInput[]
    OR?: DealInvestorScalarWhereWithAggregatesInput[]
    NOT?: DealInvestorScalarWhereWithAggregatesInput | DealInvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DealInvestor"> | string
    dealId?: StringWithAggregatesFilter<"DealInvestor"> | string
    investorId?: StringWithAggregatesFilter<"DealInvestor"> | string
    amount?: FloatWithAggregatesFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusWithAggregatesFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DealInvestor"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    tenantId?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    smeId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedBy?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sme?: SMEOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _avg?: CertificationAvgOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
    _sum?: CertificationSumOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    smeId?: StringWithAggregatesFilter<"Certification"> | string
    advisorId?: StringWithAggregatesFilter<"Certification"> | string
    status?: EnumCertificationStatusWithAggregatesFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableWithAggregatesFilter<"Certification"> | number | null
    comments?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrderInput | SortOrder
    investorId?: SortOrderInput | SortOrder
    advisorId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    didWorkflowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrderInput | SortOrder
    investorId?: SortOrderInput | SortOrder
    advisorId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    didWorkflowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    tenantId?: StringWithAggregatesFilter<"Workflow"> | string
    type?: EnumWorkflowTypeWithAggregatesFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusWithAggregatesFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonWithAggregatesFilter<"Workflow">
    smeId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    investorId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    advisorId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
  }

  export type SyndicateWhereInput = {
    AND?: SyndicateWhereInput | SyndicateWhereInput[]
    OR?: SyndicateWhereInput[]
    NOT?: SyndicateWhereInput | SyndicateWhereInput[]
    id?: StringFilter<"Syndicate"> | string
    tenantId?: StringFilter<"Syndicate"> | string
    name?: StringFilter<"Syndicate"> | string
    description?: StringNullableFilter<"Syndicate"> | string | null
    leadInvestorId?: StringFilter<"Syndicate"> | string
    targetAmount?: FloatFilter<"Syndicate"> | number
    minInvestment?: FloatFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableFilter<"Syndicate"> | number | null
    managementFee?: FloatFilter<"Syndicate"> | number
    carryFee?: FloatFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeFilter<"Syndicate"> | Date | string
    leadInvestor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    members?: SyndicateMemberListRelationFilter
  }

  export type SyndicateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrderInput | SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadInvestor?: InvestorOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    members?: SyndicateMemberOrderByRelationAggregateInput
  }

  export type SyndicateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyndicateWhereInput | SyndicateWhereInput[]
    OR?: SyndicateWhereInput[]
    NOT?: SyndicateWhereInput | SyndicateWhereInput[]
    tenantId?: StringFilter<"Syndicate"> | string
    name?: StringFilter<"Syndicate"> | string
    description?: StringNullableFilter<"Syndicate"> | string | null
    leadInvestorId?: StringFilter<"Syndicate"> | string
    targetAmount?: FloatFilter<"Syndicate"> | number
    minInvestment?: FloatFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableFilter<"Syndicate"> | number | null
    managementFee?: FloatFilter<"Syndicate"> | number
    carryFee?: FloatFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeFilter<"Syndicate"> | Date | string
    leadInvestor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    members?: SyndicateMemberListRelationFilter
  }, "id">

  export type SyndicateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrderInput | SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SyndicateCountOrderByAggregateInput
    _avg?: SyndicateAvgOrderByAggregateInput
    _max?: SyndicateMaxOrderByAggregateInput
    _min?: SyndicateMinOrderByAggregateInput
    _sum?: SyndicateSumOrderByAggregateInput
  }

  export type SyndicateScalarWhereWithAggregatesInput = {
    AND?: SyndicateScalarWhereWithAggregatesInput | SyndicateScalarWhereWithAggregatesInput[]
    OR?: SyndicateScalarWhereWithAggregatesInput[]
    NOT?: SyndicateScalarWhereWithAggregatesInput | SyndicateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Syndicate"> | string
    tenantId?: StringWithAggregatesFilter<"Syndicate"> | string
    name?: StringWithAggregatesFilter<"Syndicate"> | string
    description?: StringNullableWithAggregatesFilter<"Syndicate"> | string | null
    leadInvestorId?: StringWithAggregatesFilter<"Syndicate"> | string
    targetAmount?: FloatWithAggregatesFilter<"Syndicate"> | number
    minInvestment?: FloatWithAggregatesFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableWithAggregatesFilter<"Syndicate"> | number | null
    managementFee?: FloatWithAggregatesFilter<"Syndicate"> | number
    carryFee?: FloatWithAggregatesFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusWithAggregatesFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableWithAggregatesFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableWithAggregatesFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Syndicate"> | Date | string
  }

  export type SyndicateMemberWhereInput = {
    AND?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    OR?: SyndicateMemberWhereInput[]
    NOT?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    id?: StringFilter<"SyndicateMember"> | string
    syndicateId?: StringFilter<"SyndicateMember"> | string
    investorId?: StringFilter<"SyndicateMember"> | string
    amount?: FloatFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFilter<"SyndicateMember"> | Date | string
    syndicate?: XOR<SyndicateRelationFilter, SyndicateWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }

  export type SyndicateMemberOrderByWithRelationInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    syndicate?: SyndicateOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
  }

  export type SyndicateMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syndicateId_investorId?: SyndicateMemberSyndicateIdInvestorIdCompoundUniqueInput
    AND?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    OR?: SyndicateMemberWhereInput[]
    NOT?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    syndicateId?: StringFilter<"SyndicateMember"> | string
    investorId?: StringFilter<"SyndicateMember"> | string
    amount?: FloatFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFilter<"SyndicateMember"> | Date | string
    syndicate?: XOR<SyndicateRelationFilter, SyndicateWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }, "id" | "syndicateId_investorId">

  export type SyndicateMemberOrderByWithAggregationInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    _count?: SyndicateMemberCountOrderByAggregateInput
    _avg?: SyndicateMemberAvgOrderByAggregateInput
    _max?: SyndicateMemberMaxOrderByAggregateInput
    _min?: SyndicateMemberMinOrderByAggregateInput
    _sum?: SyndicateMemberSumOrderByAggregateInput
  }

  export type SyndicateMemberScalarWhereWithAggregatesInput = {
    AND?: SyndicateMemberScalarWhereWithAggregatesInput | SyndicateMemberScalarWhereWithAggregatesInput[]
    OR?: SyndicateMemberScalarWhereWithAggregatesInput[]
    NOT?: SyndicateMemberScalarWhereWithAggregatesInput | SyndicateMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyndicateMember"> | string
    syndicateId?: StringWithAggregatesFilter<"SyndicateMember"> | string
    investorId?: StringWithAggregatesFilter<"SyndicateMember"> | string
    amount?: FloatWithAggregatesFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusWithAggregatesFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeWithAggregatesFilter<"SyndicateMember"> | Date | string
  }

  export type DueDiligenceWhereInput = {
    AND?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    OR?: DueDiligenceWhereInput[]
    NOT?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    id?: StringFilter<"DueDiligence"> | string
    smeId?: StringFilter<"DueDiligence"> | string
    advisorId?: StringNullableFilter<"DueDiligence"> | string | null
    financialScore?: FloatFilter<"DueDiligence"> | number
    teamScore?: FloatFilter<"DueDiligence"> | number
    marketScore?: FloatFilter<"DueDiligence"> | number
    productScore?: FloatFilter<"DueDiligence"> | number
    legalScore?: FloatFilter<"DueDiligence"> | number
    operationalScore?: FloatFilter<"DueDiligence"> | number
    overallScore?: FloatFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligence"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
  }

  export type DueDiligenceOrderByWithRelationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    redFlags?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sme?: SMEOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
  }

  export type DueDiligenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    OR?: DueDiligenceWhereInput[]
    NOT?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    smeId?: StringFilter<"DueDiligence"> | string
    advisorId?: StringNullableFilter<"DueDiligence"> | string | null
    financialScore?: FloatFilter<"DueDiligence"> | number
    teamScore?: FloatFilter<"DueDiligence"> | number
    marketScore?: FloatFilter<"DueDiligence"> | number
    productScore?: FloatFilter<"DueDiligence"> | number
    legalScore?: FloatFilter<"DueDiligence"> | number
    operationalScore?: FloatFilter<"DueDiligence"> | number
    overallScore?: FloatFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligence"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
  }, "id">

  export type DueDiligenceOrderByWithAggregationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    redFlags?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DueDiligenceCountOrderByAggregateInput
    _avg?: DueDiligenceAvgOrderByAggregateInput
    _max?: DueDiligenceMaxOrderByAggregateInput
    _min?: DueDiligenceMinOrderByAggregateInput
    _sum?: DueDiligenceSumOrderByAggregateInput
  }

  export type DueDiligenceScalarWhereWithAggregatesInput = {
    AND?: DueDiligenceScalarWhereWithAggregatesInput | DueDiligenceScalarWhereWithAggregatesInput[]
    OR?: DueDiligenceScalarWhereWithAggregatesInput[]
    NOT?: DueDiligenceScalarWhereWithAggregatesInput | DueDiligenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DueDiligence"> | string
    smeId?: StringWithAggregatesFilter<"DueDiligence"> | string
    advisorId?: StringNullableWithAggregatesFilter<"DueDiligence"> | string | null
    financialScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    teamScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    marketScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    productScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    legalScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    operationalScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    overallScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelWithAggregatesFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusWithAggregatesFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DueDiligence"> | Date | string
  }

  export type CommunityPostWhereInput = {
    AND?: CommunityPostWhereInput | CommunityPostWhereInput[]
    OR?: CommunityPostWhereInput[]
    NOT?: CommunityPostWhereInput | CommunityPostWhereInput[]
    id?: StringFilter<"CommunityPost"> | string
    tenantId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    category?: EnumPostCategoryFilter<"CommunityPost"> | $Enums.PostCategory
    smeId?: StringNullableFilter<"CommunityPost"> | string | null
    dealId?: StringNullableFilter<"CommunityPost"> | string | null
    syndicateId?: StringNullableFilter<"CommunityPost"> | string | null
    likes?: IntFilter<"CommunityPost"> | number
    views?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    isAnnouncement?: BoolFilter<"CommunityPost"> | boolean
    status?: EnumPostStatusFilter<"CommunityPost"> | $Enums.PostStatus
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
    comments?: CommentListRelationFilter
  }

  export type CommunityPostOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    syndicateId?: SortOrderInput | SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
  }

  export type CommunityPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityPostWhereInput | CommunityPostWhereInput[]
    OR?: CommunityPostWhereInput[]
    NOT?: CommunityPostWhereInput | CommunityPostWhereInput[]
    tenantId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    category?: EnumPostCategoryFilter<"CommunityPost"> | $Enums.PostCategory
    smeId?: StringNullableFilter<"CommunityPost"> | string | null
    dealId?: StringNullableFilter<"CommunityPost"> | string | null
    syndicateId?: StringNullableFilter<"CommunityPost"> | string | null
    likes?: IntFilter<"CommunityPost"> | number
    views?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    isAnnouncement?: BoolFilter<"CommunityPost"> | boolean
    status?: EnumPostStatusFilter<"CommunityPost"> | $Enums.PostStatus
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
    comments?: CommentListRelationFilter
  }, "id">

  export type CommunityPostOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    syndicateId?: SortOrderInput | SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityPostCountOrderByAggregateInput
    _avg?: CommunityPostAvgOrderByAggregateInput
    _max?: CommunityPostMaxOrderByAggregateInput
    _min?: CommunityPostMinOrderByAggregateInput
    _sum?: CommunityPostSumOrderByAggregateInput
  }

  export type CommunityPostScalarWhereWithAggregatesInput = {
    AND?: CommunityPostScalarWhereWithAggregatesInput | CommunityPostScalarWhereWithAggregatesInput[]
    OR?: CommunityPostScalarWhereWithAggregatesInput[]
    NOT?: CommunityPostScalarWhereWithAggregatesInput | CommunityPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityPost"> | string
    tenantId?: StringWithAggregatesFilter<"CommunityPost"> | string
    authorId?: StringWithAggregatesFilter<"CommunityPost"> | string
    title?: StringWithAggregatesFilter<"CommunityPost"> | string
    content?: StringWithAggregatesFilter<"CommunityPost"> | string
    category?: EnumPostCategoryWithAggregatesFilter<"CommunityPost"> | $Enums.PostCategory
    smeId?: StringNullableWithAggregatesFilter<"CommunityPost"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"CommunityPost"> | string | null
    syndicateId?: StringNullableWithAggregatesFilter<"CommunityPost"> | string | null
    likes?: IntWithAggregatesFilter<"CommunityPost"> | number
    views?: IntWithAggregatesFilter<"CommunityPost"> | number
    isPinned?: BoolWithAggregatesFilter<"CommunityPost"> | boolean
    isAnnouncement?: BoolWithAggregatesFilter<"CommunityPost"> | boolean
    status?: EnumPostStatusWithAggregatesFilter<"CommunityPost"> | $Enums.PostStatus
    createdAt?: DateTimeWithAggregatesFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityPost"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    likes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: CommunityPostOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    likes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    likes?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type SecondaryListingWhereInput = {
    AND?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    OR?: SecondaryListingWhereInput[]
    NOT?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    id?: StringFilter<"SecondaryListing"> | string
    tenantId?: StringFilter<"SecondaryListing"> | string
    sellerId?: StringFilter<"SecondaryListing"> | string
    dealInvestorId?: StringFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatFilter<"SecondaryListing"> | number
    pricePerShare?: FloatFilter<"SecondaryListing"> | number
    minPurchase?: FloatFilter<"SecondaryListing"> | number
    status?: EnumListingStatusFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    trades?: SecondaryTradeListRelationFilter
  }

  export type SecondaryListingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trades?: SecondaryTradeOrderByRelationAggregateInput
  }

  export type SecondaryListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    OR?: SecondaryListingWhereInput[]
    NOT?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    tenantId?: StringFilter<"SecondaryListing"> | string
    sellerId?: StringFilter<"SecondaryListing"> | string
    dealInvestorId?: StringFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatFilter<"SecondaryListing"> | number
    pricePerShare?: FloatFilter<"SecondaryListing"> | number
    minPurchase?: FloatFilter<"SecondaryListing"> | number
    status?: EnumListingStatusFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    trades?: SecondaryTradeListRelationFilter
  }, "id">

  export type SecondaryListingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecondaryListingCountOrderByAggregateInput
    _avg?: SecondaryListingAvgOrderByAggregateInput
    _max?: SecondaryListingMaxOrderByAggregateInput
    _min?: SecondaryListingMinOrderByAggregateInput
    _sum?: SecondaryListingSumOrderByAggregateInput
  }

  export type SecondaryListingScalarWhereWithAggregatesInput = {
    AND?: SecondaryListingScalarWhereWithAggregatesInput | SecondaryListingScalarWhereWithAggregatesInput[]
    OR?: SecondaryListingScalarWhereWithAggregatesInput[]
    NOT?: SecondaryListingScalarWhereWithAggregatesInput | SecondaryListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecondaryListing"> | string
    tenantId?: StringWithAggregatesFilter<"SecondaryListing"> | string
    sellerId?: StringWithAggregatesFilter<"SecondaryListing"> | string
    dealInvestorId?: StringWithAggregatesFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatWithAggregatesFilter<"SecondaryListing"> | number
    pricePerShare?: FloatWithAggregatesFilter<"SecondaryListing"> | number
    minPurchase?: FloatWithAggregatesFilter<"SecondaryListing"> | number
    status?: EnumListingStatusWithAggregatesFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeWithAggregatesFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecondaryListing"> | Date | string
  }

  export type SecondaryTradeWhereInput = {
    AND?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    OR?: SecondaryTradeWhereInput[]
    NOT?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    id?: StringFilter<"SecondaryTrade"> | string
    listingId?: StringFilter<"SecondaryTrade"> | string
    buyerId?: StringFilter<"SecondaryTrade"> | string
    sellerId?: StringFilter<"SecondaryTrade"> | string
    shares?: FloatFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatFilter<"SecondaryTrade"> | number
    totalAmount?: FloatFilter<"SecondaryTrade"> | number
    fee?: FloatFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    listing?: XOR<SecondaryListingRelationFilter, SecondaryListingWhereInput>
  }

  export type SecondaryTradeOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listing?: SecondaryListingOrderByWithRelationInput
  }

  export type SecondaryTradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    OR?: SecondaryTradeWhereInput[]
    NOT?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    listingId?: StringFilter<"SecondaryTrade"> | string
    buyerId?: StringFilter<"SecondaryTrade"> | string
    sellerId?: StringFilter<"SecondaryTrade"> | string
    shares?: FloatFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatFilter<"SecondaryTrade"> | number
    totalAmount?: FloatFilter<"SecondaryTrade"> | number
    fee?: FloatFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    listing?: XOR<SecondaryListingRelationFilter, SecondaryListingWhereInput>
  }, "id">

  export type SecondaryTradeOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecondaryTradeCountOrderByAggregateInput
    _avg?: SecondaryTradeAvgOrderByAggregateInput
    _max?: SecondaryTradeMaxOrderByAggregateInput
    _min?: SecondaryTradeMinOrderByAggregateInput
    _sum?: SecondaryTradeSumOrderByAggregateInput
  }

  export type SecondaryTradeScalarWhereWithAggregatesInput = {
    AND?: SecondaryTradeScalarWhereWithAggregatesInput | SecondaryTradeScalarWhereWithAggregatesInput[]
    OR?: SecondaryTradeScalarWhereWithAggregatesInput[]
    NOT?: SecondaryTradeScalarWhereWithAggregatesInput | SecondaryTradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    listingId?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    buyerId?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    sellerId?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    shares?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    totalAmount?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    fee?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusWithAggregatesFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableWithAggregatesFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecondaryTrade"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    tenantId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMECreateInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMEUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type SMECreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMEUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMEUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorCreateInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
  }

  export type DealInvestorUncheckedCreateInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
  }

  export type DealInvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    sme?: SMECreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutCertificationsInput
    advisor: AdvisorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    smeId: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutCertificationsNestedInput
    advisor?: AdvisorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyInput = {
    id?: string
    smeId: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateManyInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadInvestor: InvestorCreateNestedOneWithoutLeadSyndicatesInput
    deal?: DealCreateNestedOneWithoutSyndicatesInput
    members?: SyndicateMemberCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadInvestor?: InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput
    deal?: DealUpdateOneWithoutSyndicatesNestedInput
    members?: SyndicateMemberUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberCreateInput = {
    id?: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
    syndicate: SyndicateCreateNestedOneWithoutMembersInput
    investor: InvestorCreateNestedOneWithoutSyndicateMembershipsInput
  }

  export type SyndicateMemberUncheckedCreateInput = {
    id?: string
    syndicateId: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syndicate?: SyndicateUpdateOneRequiredWithoutMembersNestedInput
    investor?: InvestorUpdateOneRequiredWithoutSyndicateMembershipsNestedInput
  }

  export type SyndicateMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberCreateManyInput = {
    id?: string
    syndicateId: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceCreateInput = {
    id?: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDueDiligencesInput
    advisor?: AdvisorCreateNestedOneWithoutDueDiligencesInput
  }

  export type DueDiligenceUncheckedCreateInput = {
    id?: string
    smeId: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDueDiligencesNestedInput
    advisor?: AdvisorUpdateOneWithoutDueDiligencesNestedInput
  }

  export type DueDiligenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceCreateManyInput = {
    id?: string
    smeId: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostCreateInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostCreateManyInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingCreateInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: SecondaryTradeCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingUncheckedCreateInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: SecondaryTradeUncheckedCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: SecondaryTradeUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: SecondaryTradeUncheckedUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingCreateManyInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeCreateInput = {
    id?: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: SecondaryListingCreateNestedOneWithoutTradesInput
  }

  export type SecondaryTradeUncheckedCreateInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: SecondaryListingUpdateOneRequiredWithoutTradesNestedInput
  }

  export type SecondaryTradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeCreateManyInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SMEListRelationFilter = {
    every?: SMEWhereInput
    some?: SMEWhereInput
    none?: SMEWhereInput
  }

  export type InvestorListRelationFilter = {
    every?: InvestorWhereInput
    some?: InvestorWhereInput
    none?: InvestorWhereInput
  }

  export type AdvisorListRelationFilter = {
    every?: AdvisorWhereInput
    some?: AdvisorWhereInput
    none?: AdvisorWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMEOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvisorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type EnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SMENullableRelationFilter = {
    is?: SMEWhereInput | null
    isNot?: SMEWhereInput | null
  }

  export type InvestorNullableRelationFilter = {
    is?: InvestorWhereInput | null
    isNot?: InvestorWhereInput | null
  }

  export type AdvisorNullableRelationFilter = {
    is?: AdvisorWhereInput | null
    isNot?: AdvisorWhereInput | null
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type EnumSMEStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageFilter<$PrismaModel> | $Enums.SMEStage
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSMEStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusFilter<$PrismaModel> | $Enums.SMEStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type DueDiligenceListRelationFilter = {
    every?: DueDiligenceWhereInput
    some?: DueDiligenceWhereInput
    none?: DueDiligenceWhereInput
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DueDiligenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMECountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMEAvgOrderByAggregateInput = {
    fundingRequired?: SortOrder
    score?: SortOrder
  }

  export type SMEMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMEMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMESumOrderByAggregateInput = {
    fundingRequired?: SortOrder
    score?: SortOrder
  }

  export type EnumSMEStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageWithAggregatesFilter<$PrismaModel> | $Enums.SMEStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStageFilter<$PrismaModel>
    _max?: NestedEnumSMEStageFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSMEStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel> | $Enums.SMEStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStatusFilter<$PrismaModel>
    _max?: NestedEnumSMEStatusFilter<$PrismaModel>
  }

  export type EnumInvestorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeFilter<$PrismaModel> | $Enums.InvestorType
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type DealInvestorListRelationFilter = {
    every?: DealInvestorWhereInput
    some?: DealInvestorWhereInput
    none?: DealInvestorWhereInput
  }

  export type SyndicateListRelationFilter = {
    every?: SyndicateWhereInput
    some?: SyndicateWhereInput
    none?: SyndicateWhereInput
  }

  export type SyndicateMemberListRelationFilter = {
    every?: SyndicateMemberWhereInput
    some?: SyndicateMemberWhereInput
    none?: SyndicateMemberWhereInput
  }

  export type DealInvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyndicateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyndicateMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvestorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvestorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestorTypeFilter<$PrismaModel>
    _max?: NestedEnumInvestorTypeFilter<$PrismaModel>
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumAdvisorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusFilter<$PrismaModel> | $Enums.AdvisorStatus
  }

  export type AdvisorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdvisorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvisorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvisorStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvisorStatusFilter<$PrismaModel>
  }

  export type EnumDealStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusFilter<$PrismaModel> | $Enums.DealStatus
  }

  export type SMERelationFilter = {
    is?: SMEWhereInput
    isNot?: SMEWhereInput
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    terms?: SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    amount?: SortOrder
    equity?: SortOrder
    successFee?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    terms?: SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    terms?: SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    amount?: SortOrder
    equity?: SortOrder
    successFee?: SortOrder
  }

  export type EnumDealStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealStatusFilter<$PrismaModel>
    _max?: NestedEnumDealStatusFilter<$PrismaModel>
  }

  export type EnumInvestmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusFilter<$PrismaModel> | $Enums.InvestmentStatus
  }

  export type DealRelationFilter = {
    is?: DealWhereInput
    isNot?: DealWhereInput
  }

  export type InvestorRelationFilter = {
    is?: InvestorWhereInput
    isNot?: InvestorWhereInput
  }

  export type DealInvestorDealIdInvestorIdCompoundUniqueInput = {
    dealId: string
    investorId: string
  }

  export type DealInvestorCountOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DealInvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorMinOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvestmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestmentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DealNullableRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type AdvisorRelationFilter = {
    is?: AdvisorWhereInput
    isNot?: AdvisorWhereInput
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type EnumWorkflowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeFilter<$PrismaModel> | $Enums.WorkflowType
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkflowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTypeFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type EnumSyndicateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusFilter<$PrismaModel> | $Enums.SyndicateStatus
  }

  export type SyndicateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrder
    closingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyndicateAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
  }

  export type SyndicateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrder
    closingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyndicateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrder
    closingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyndicateSumOrderByAggregateInput = {
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
  }

  export type EnumSyndicateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateStatusFilter<$PrismaModel>
  }

  export type EnumSyndicateMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
  }

  export type SyndicateRelationFilter = {
    is?: SyndicateWhereInput
    isNot?: SyndicateWhereInput
  }

  export type SyndicateMemberSyndicateIdInvestorIdCompoundUniqueInput = {
    syndicateId: string
    investorId: string
  }

  export type SyndicateMemberCountOrderByAggregateInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
  }

  export type SyndicateMemberAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SyndicateMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
  }

  export type SyndicateMemberMinOrderByAggregateInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
  }

  export type SyndicateMemberSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type EnumDueDiligenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusFilter<$PrismaModel> | $Enums.DueDiligenceStatus
  }

  export type DueDiligenceCountOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    redFlags?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDiligenceAvgOrderByAggregateInput = {
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
  }

  export type DueDiligenceMaxOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDiligenceMinOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDiligenceSumOrderByAggregateInput = {
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type EnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DueDiligenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
    _max?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
  }

  export type EnumPostCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryFilter<$PrismaModel> | $Enums.PostCategory
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityPostCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    syndicateId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type CommunityPostMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    syndicateId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    syndicateId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type EnumPostCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PostCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostCategoryFilter<$PrismaModel>
    _max?: NestedEnumPostCategoryFilter<$PrismaModel>
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type CommunityPostRelationFilter = {
    is?: CommunityPostWhereInput
    isNot?: CommunityPostWhereInput
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type SecondaryTradeListRelationFilter = {
    every?: SecondaryTradeWhereInput
    some?: SecondaryTradeWhereInput
    none?: SecondaryTradeWhereInput
  }

  export type SecondaryTradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecondaryListingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryListingAvgOrderByAggregateInput = {
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
  }

  export type SecondaryListingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryListingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryListingSumOrderByAggregateInput = {
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type EnumTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusFilter<$PrismaModel> | $Enums.TradeStatus
  }

  export type SecondaryListingRelationFilter = {
    is?: SecondaryListingWhereInput
    isNot?: SecondaryListingWhereInput
  }

  export type SecondaryTradeCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryTradeAvgOrderByAggregateInput = {
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
  }

  export type SecondaryTradeMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryTradeMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryTradeSumOrderByAggregateInput = {
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
  }

  export type EnumTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SMECreateNestedManyWithoutTenantInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
  }

  export type InvestorCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type AdvisorCreateNestedManyWithoutTenantInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SMEUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
  }

  export type InvestorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type AdvisorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SMEUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    upsert?: SMEUpsertWithWhereUniqueWithoutTenantInput | SMEUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    set?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    disconnect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    delete?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    update?: SMEUpdateWithWhereUniqueWithoutTenantInput | SMEUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SMEUpdateManyWithWhereWithoutTenantInput | SMEUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SMEScalarWhereInput | SMEScalarWhereInput[]
  }

  export type InvestorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutTenantInput | InvestorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutTenantInput | InvestorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutTenantInput | InvestorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type AdvisorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    upsert?: AdvisorUpsertWithWhereUniqueWithoutTenantInput | AdvisorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    set?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    disconnect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    delete?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    update?: AdvisorUpdateWithWhereUniqueWithoutTenantInput | AdvisorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AdvisorUpdateManyWithWhereWithoutTenantInput | AdvisorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
  }

  export type DealUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutTenantInput | WorkflowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutTenantInput | WorkflowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutTenantInput | WorkflowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SMEUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    upsert?: SMEUpsertWithWhereUniqueWithoutTenantInput | SMEUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    set?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    disconnect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    delete?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    update?: SMEUpdateWithWhereUniqueWithoutTenantInput | SMEUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SMEUpdateManyWithWhereWithoutTenantInput | SMEUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SMEScalarWhereInput | SMEScalarWhereInput[]
  }

  export type InvestorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutTenantInput | InvestorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutTenantInput | InvestorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutTenantInput | InvestorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type AdvisorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    upsert?: AdvisorUpsertWithWhereUniqueWithoutTenantInput | AdvisorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    set?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    disconnect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    delete?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    update?: AdvisorUpdateWithWhereUniqueWithoutTenantInput | AdvisorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AdvisorUpdateManyWithWhereWithoutTenantInput | AdvisorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutTenantInput | WorkflowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutTenantInput | WorkflowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutTenantInput | WorkflowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutUserInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutUserInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    connect?: AdvisorWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SMEUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    connect?: AdvisorWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumLanguageFieldUpdateOperationsInput = {
    set?: $Enums.Language
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type SMEUpdateOneWithoutUserNestedInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    upsert?: SMEUpsertWithoutUserInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutUserInput, SMEUpdateWithoutUserInput>, SMEUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    upsert?: AdvisorUpsertWithoutUserInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutUserInput, AdvisorUpdateWithoutUserInput>, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SMEUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    upsert?: SMEUpsertWithoutUserInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutUserInput, SMEUpdateWithoutUserInput>, SMEUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    upsert?: AdvisorUpsertWithoutUserInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutUserInput, AdvisorUpdateWithoutUserInput>, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutSmesInput = {
    create?: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSmeInput = {
    create?: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmeInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutSmeInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutSmeInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutSmeInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutSmeInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceCreateNestedManyWithoutSmeInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type EnumSMEStageFieldUpdateOperationsInput = {
    set?: $Enums.SMEStage
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSMEStatusFieldUpdateOperationsInput = {
    set?: $Enums.SMEStatus
  }

  export type TenantUpdateOneRequiredWithoutSmesNestedInput = {
    create?: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmesInput
    upsert?: TenantUpsertWithoutSmesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSmesInput, TenantUpdateWithoutSmesInput>, TenantUncheckedUpdateWithoutSmesInput>
  }

  export type UserUpdateOneRequiredWithoutSmeNestedInput = {
    create?: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmeInput
    upsert?: UserUpsertWithoutSmeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmeInput, UserUpdateWithoutSmeInput>, UserUncheckedUpdateWithoutSmeInput>
  }

  export type DocumentUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSmeInput | DocumentUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSmeInput | DocumentUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSmeInput | DocumentUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutSmeInput | DealUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutSmeInput | DealUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DealUpdateManyWithWhereWithoutSmeInput | DealUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutSmeNestedInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutSmeInput | CertificationUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutSmeInput | CertificationUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutSmeInput | CertificationUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutSmeNestedInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutSmeInput | WorkflowUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutSmeInput | WorkflowUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutSmeInput | WorkflowUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutSmeInput | DueDiligenceUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutSmeInput | DueDiligenceUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutSmeInput | DueDiligenceUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSmeInput | DocumentUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSmeInput | DocumentUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSmeInput | DocumentUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutSmeInput | DealUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutSmeInput | DealUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DealUpdateManyWithWhereWithoutSmeInput | DealUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutSmeInput | CertificationUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutSmeInput | CertificationUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutSmeInput | CertificationUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutSmeInput | WorkflowUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutSmeInput | WorkflowUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutSmeInput | WorkflowUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutSmeInput | DueDiligenceUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutSmeInput | DueDiligenceUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutSmeInput | DueDiligenceUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvestorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvestorInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    connect?: UserWhereUniqueInput
  }

  export type DealInvestorCreateNestedManyWithoutInvestorInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutInvestorInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateCreateNestedManyWithoutLeadInvestorInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type SyndicateMemberCreateNestedManyWithoutInvestorInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type DealInvestorUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type EnumInvestorTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvestorType
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type TenantUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvestorsInput
    upsert?: TenantUpsertWithoutInvestorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvestorsInput, TenantUpdateWithoutInvestorsInput>, TenantUncheckedUpdateWithoutInvestorsInput>
  }

  export type UserUpdateOneRequiredWithoutInvestorNestedInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    upsert?: UserUpsertWithoutInvestorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorInput, UserUpdateWithoutInvestorInput>, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type DealInvestorUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutInvestorInput | DealInvestorUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutInvestorInput | DealInvestorUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutInvestorInput | DealInvestorUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutInvestorInput | WorkflowUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutInvestorInput | WorkflowUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutInvestorInput | WorkflowUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUpdateManyWithoutLeadInvestorNestedInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutLeadInvestorInput | SyndicateUpdateManyWithWhereWithoutLeadInvestorInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type SyndicateMemberUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutInvestorInput | SyndicateMemberUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutInvestorInput | DealInvestorUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutInvestorInput | DealInvestorUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutInvestorInput | DealInvestorUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutInvestorInput | WorkflowUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutInvestorInput | WorkflowUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutInvestorInput | WorkflowUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutLeadInvestorInput | SyndicateUpdateManyWithWhereWithoutLeadInvestorInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutInvestorInput | SyndicateMemberUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type AdvisorCreatespecializationInput = {
    set: string[]
  }

  export type AdvisorCreatecertificationListInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutAdvisorsInput = {
    create?: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAdvisorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdvisorInput = {
    create?: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvisorInput
    connect?: UserWhereUniqueInput
  }

  export type CertificationCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type AdvisorUpdatespecializationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdvisorUpdatecertificationListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAdvisorStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdvisorStatus
  }

  export type TenantUpdateOneRequiredWithoutAdvisorsNestedInput = {
    create?: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAdvisorsInput
    upsert?: TenantUpsertWithoutAdvisorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAdvisorsInput, TenantUpdateWithoutAdvisorsInput>, TenantUncheckedUpdateWithoutAdvisorsInput>
  }

  export type UserUpdateOneRequiredWithoutAdvisorNestedInput = {
    create?: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvisorInput
    upsert?: UserUpsertWithoutAdvisorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdvisorInput, UserUpdateWithoutAdvisorInput>, UserUncheckedUpdateWithoutAdvisorInput>
  }

  export type CertificationUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutAdvisorInput | CertificationUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutAdvisorInput | CertificationUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutAdvisorInput | CertificationUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAdvisorInput | WorkflowUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAdvisorInput | WorkflowUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAdvisorInput | WorkflowUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutAdvisorInput | DueDiligenceUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutAdvisorInput | CertificationUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutAdvisorInput | CertificationUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutAdvisorInput | CertificationUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAdvisorInput | WorkflowUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAdvisorInput | WorkflowUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAdvisorInput | WorkflowUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutAdvisorInput | DueDiligenceUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDealsInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutDealsInput = {
    create?: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDealsInput
    connect?: SMEWhereUniqueInput
  }

  export type DealInvestorCreateNestedManyWithoutDealInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutDealInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateCreateNestedManyWithoutDealInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type DealInvestorUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type EnumDealStatusFieldUpdateOperationsInput = {
    set?: $Enums.DealStatus
  }

  export type TenantUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    upsert?: TenantUpsertWithoutDealsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDealsInput, TenantUpdateWithoutDealsInput>, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type SMEUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDealsInput
    upsert?: SMEUpsertWithoutDealsInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDealsInput, SMEUpdateWithoutDealsInput>, SMEUncheckedUpdateWithoutDealsInput>
  }

  export type DealInvestorUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutDealInput | DealInvestorUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutDealInput | DealInvestorUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutDealInput | DealInvestorUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutDealNestedInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutDealInput | WorkflowUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutDealInput | WorkflowUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutDealInput | WorkflowUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUpdateManyWithoutDealNestedInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutDealInput | SyndicateUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutDealInput | SyndicateUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutDealInput | SyndicateUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type DealInvestorUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutDealInput | DealInvestorUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutDealInput | DealInvestorUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutDealInput | DealInvestorUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutDealInput | WorkflowUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutDealInput | WorkflowUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutDealInput | WorkflowUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutDealInput | SyndicateUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutDealInput | SyndicateUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutDealInput | SyndicateUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type DealCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInvestorsInput
    connect?: DealWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutDealInvestmentsInput = {
    create?: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutDealInvestmentsInput
    connect?: InvestorWhereUniqueInput
  }

  export type EnumInvestmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvestmentStatus
  }

  export type DealUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInvestorsInput
    upsert?: DealUpsertWithoutInvestorsInput
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutInvestorsInput, DealUpdateWithoutInvestorsInput>, DealUncheckedUpdateWithoutInvestorsInput>
  }

  export type InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput = {
    create?: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutDealInvestmentsInput
    upsert?: InvestorUpsertWithoutDealInvestmentsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutDealInvestmentsInput, InvestorUpdateWithoutDealInvestmentsInput>, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
  }

  export type TenantCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutDocumentsInput = {
    create?: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDocumentsInput
    connect?: SMEWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    connect?: DealWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    upsert?: TenantUpsertWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentsInput, TenantUpdateWithoutDocumentsInput>, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMEUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDocumentsInput
    upsert?: SMEUpsertWithoutDocumentsInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDocumentsInput, SMEUpdateWithoutDocumentsInput>, SMEUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    upsert?: DealUpsertWithoutDocumentsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutDocumentsInput, DealUpdateWithoutDocumentsInput>, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMECreateNestedOneWithoutCertificationsInput = {
    create?: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: SMECreateOrConnectWithoutCertificationsInput
    connect?: SMEWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutCertificationsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type EnumCertificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.CertificationStatus
  }

  export type SMEUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: SMECreateOrConnectWithoutCertificationsInput
    upsert?: SMEUpsertWithoutCertificationsInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutCertificationsInput, SMEUpdateWithoutCertificationsInput>, SMEUncheckedUpdateWithoutCertificationsInput>
  }

  export type AdvisorUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutCertificationsInput
    upsert?: AdvisorUpsertWithoutCertificationsInput
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutCertificationsInput, AdvisorUpdateWithoutCertificationsInput>, AdvisorUncheckedUpdateWithoutCertificationsInput>
  }

  export type TenantCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: SMECreateOrConnectWithoutWorkflowsInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutWorkflowsInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutWorkflowsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: DealCreateOrConnectWithoutWorkflowsInput
    connect?: DealWhereUniqueInput
  }

  export type EnumWorkflowTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowType
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type TenantUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowsInput
    upsert?: TenantUpsertWithoutWorkflowsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWorkflowsInput, TenantUpdateWithoutWorkflowsInput>, TenantUncheckedUpdateWithoutWorkflowsInput>
  }

  export type SMEUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: SMECreateOrConnectWithoutWorkflowsInput
    upsert?: SMEUpsertWithoutWorkflowsInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutWorkflowsInput, SMEUpdateWithoutWorkflowsInput>, SMEUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutWorkflowsInput
    upsert?: InvestorUpsertWithoutWorkflowsInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutWorkflowsInput, InvestorUpdateWithoutWorkflowsInput>, InvestorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AdvisorUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutWorkflowsInput
    upsert?: AdvisorUpsertWithoutWorkflowsInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutWorkflowsInput, AdvisorUpdateWithoutWorkflowsInput>, AdvisorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type DealUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: DealCreateOrConnectWithoutWorkflowsInput
    upsert?: DealUpsertWithoutWorkflowsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutWorkflowsInput, DealUpdateWithoutWorkflowsInput>, DealUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorCreateNestedOneWithoutLeadSyndicatesInput = {
    create?: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutLeadSyndicatesInput
    connect?: InvestorWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutSyndicatesInput = {
    create?: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSyndicatesInput
    connect?: DealWhereUniqueInput
  }

  export type SyndicateMemberCreateNestedManyWithoutSyndicateInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type EnumSyndicateStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyndicateStatus
  }

  export type InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput = {
    create?: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutLeadSyndicatesInput
    upsert?: InvestorUpsertWithoutLeadSyndicatesInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutLeadSyndicatesInput, InvestorUpdateWithoutLeadSyndicatesInput>, InvestorUncheckedUpdateWithoutLeadSyndicatesInput>
  }

  export type DealUpdateOneWithoutSyndicatesNestedInput = {
    create?: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSyndicatesInput
    upsert?: DealUpsertWithoutSyndicatesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutSyndicatesInput, DealUpdateWithoutSyndicatesInput>, DealUncheckedUpdateWithoutSyndicatesInput>
  }

  export type SyndicateMemberUpdateManyWithoutSyndicateNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput | SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput | SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type SyndicateCreateNestedOneWithoutMembersInput = {
    create?: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SyndicateCreateOrConnectWithoutMembersInput
    connect?: SyndicateWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutSyndicateMembershipsInput = {
    create?: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutSyndicateMembershipsInput
    connect?: InvestorWhereUniqueInput
  }

  export type EnumSyndicateMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyndicateMemberStatus
  }

  export type SyndicateUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SyndicateCreateOrConnectWithoutMembersInput
    upsert?: SyndicateUpsertWithoutMembersInput
    connect?: SyndicateWhereUniqueInput
    update?: XOR<XOR<SyndicateUpdateToOneWithWhereWithoutMembersInput, SyndicateUpdateWithoutMembersInput>, SyndicateUncheckedUpdateWithoutMembersInput>
  }

  export type InvestorUpdateOneRequiredWithoutSyndicateMembershipsNestedInput = {
    create?: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutSyndicateMembershipsInput
    upsert?: InvestorUpsertWithoutSyndicateMembershipsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutSyndicateMembershipsInput, InvestorUpdateWithoutSyndicateMembershipsInput>, InvestorUncheckedUpdateWithoutSyndicateMembershipsInput>
  }

  export type DueDiligenceCreatestrengthsInput = {
    set: string[]
  }

  export type DueDiligenceCreateweaknessesInput = {
    set: string[]
  }

  export type DueDiligenceCreaterecommendationsInput = {
    set: string[]
  }

  export type DueDiligenceCreateredFlagsInput = {
    set: string[]
  }

  export type SMECreateNestedOneWithoutDueDiligencesInput = {
    create?: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: SMECreateOrConnectWithoutDueDiligencesInput
    connect?: SMEWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutDueDiligencesInput = {
    create?: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutDueDiligencesInput
    connect?: AdvisorWhereUniqueInput
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type DueDiligenceUpdatestrengthsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DueDiligenceUpdateweaknessesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DueDiligenceUpdaterecommendationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DueDiligenceUpdateredFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumDueDiligenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DueDiligenceStatus
  }

  export type SMEUpdateOneRequiredWithoutDueDiligencesNestedInput = {
    create?: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: SMECreateOrConnectWithoutDueDiligencesInput
    upsert?: SMEUpsertWithoutDueDiligencesInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDueDiligencesInput, SMEUpdateWithoutDueDiligencesInput>, SMEUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type AdvisorUpdateOneWithoutDueDiligencesNestedInput = {
    create?: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutDueDiligencesInput
    upsert?: AdvisorUpsertWithoutDueDiligencesInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutDueDiligencesInput, AdvisorUpdateWithoutDueDiligencesInput>, AdvisorUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumPostCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PostCategory
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommunityPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommunityPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommentsInput
    upsert?: CommunityPostUpsertWithoutCommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<XOR<CommunityPostUpdateToOneWithWhereWithoutCommentsInput, CommunityPostUpdateWithoutCommentsInput>, CommunityPostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SecondaryTradeCreateNestedManyWithoutListingInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type SecondaryTradeUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type SecondaryTradeUpdateManyWithoutListingNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutListingInput | SecondaryTradeUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutListingInput | SecondaryTradeUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutListingInput | SecondaryTradeUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutListingInput | SecondaryTradeUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutListingInput | SecondaryTradeUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutListingInput | SecondaryTradeUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type SecondaryListingCreateNestedOneWithoutTradesInput = {
    create?: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutTradesInput
    connect?: SecondaryListingWhereUniqueInput
  }

  export type EnumTradeStatusFieldUpdateOperationsInput = {
    set?: $Enums.TradeStatus
  }

  export type SecondaryListingUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutTradesInput
    upsert?: SecondaryListingUpsertWithoutTradesInput
    connect?: SecondaryListingWhereUniqueInput
    update?: XOR<XOR<SecondaryListingUpdateToOneWithWhereWithoutTradesInput, SecondaryListingUpdateWithoutTradesInput>, SecondaryListingUncheckedUpdateWithoutTradesInput>
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type NestedEnumSMEStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageFilter<$PrismaModel> | $Enums.SMEStage
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSMEStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusFilter<$PrismaModel> | $Enums.SMEStatus
  }

  export type NestedEnumSMEStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageWithAggregatesFilter<$PrismaModel> | $Enums.SMEStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStageFilter<$PrismaModel>
    _max?: NestedEnumSMEStageFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel> | $Enums.SMEStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStatusFilter<$PrismaModel>
    _max?: NestedEnumSMEStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvestorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeFilter<$PrismaModel> | $Enums.InvestorType
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvestorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestorTypeFilter<$PrismaModel>
    _max?: NestedEnumInvestorTypeFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdvisorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusFilter<$PrismaModel> | $Enums.AdvisorStatus
  }

  export type NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvisorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvisorStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvisorStatusFilter<$PrismaModel>
  }

  export type NestedEnumDealStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusFilter<$PrismaModel> | $Enums.DealStatus
  }

  export type NestedEnumDealStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealStatusFilter<$PrismaModel>
    _max?: NestedEnumDealStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvestmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusFilter<$PrismaModel> | $Enums.InvestmentStatus
  }

  export type NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeFilter<$PrismaModel> | $Enums.WorkflowType
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyndicateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusFilter<$PrismaModel> | $Enums.SyndicateStatus
  }

  export type NestedEnumSyndicateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyndicateMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
  }

  export type NestedEnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedEnumDueDiligenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusFilter<$PrismaModel> | $Enums.DueDiligenceStatus
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type NestedEnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DueDiligenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
    _max?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryFilter<$PrismaModel> | $Enums.PostCategory
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PostCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostCategoryFilter<$PrismaModel>
    _max?: NestedEnumPostCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusFilter<$PrismaModel> | $Enums.TradeStatus
  }

  export type NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SMECreateWithoutTenantInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutTenantInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput>
  }

  export type SMECreateManyTenantInputEnvelope = {
    data: SMECreateManyTenantInput | SMECreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvestorCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput>
  }

  export type InvestorCreateManyTenantInputEnvelope = {
    data: InvestorCreateManyTenantInput | InvestorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AdvisorCreateWithoutTenantInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput>
  }

  export type AdvisorCreateManyTenantInputEnvelope = {
    data: AdvisorCreateManyTenantInput | AdvisorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutTenantInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTenantInput = {
    id?: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTenantInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealCreateManyTenantInputEnvelope = {
    data: DealCreateManyTenantInput | DealCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowCreateManyTenantInputEnvelope = {
    data: WorkflowCreateManyTenantInput | WorkflowCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentCreateManyTenantInputEnvelope = {
    data: DocumentCreateManyTenantInput | DocumentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SMEUpsertWithWhereUniqueWithoutTenantInput = {
    where: SMEWhereUniqueInput
    update: XOR<SMEUpdateWithoutTenantInput, SMEUncheckedUpdateWithoutTenantInput>
    create: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput>
  }

  export type SMEUpdateWithWhereUniqueWithoutTenantInput = {
    where: SMEWhereUniqueInput
    data: XOR<SMEUpdateWithoutTenantInput, SMEUncheckedUpdateWithoutTenantInput>
  }

  export type SMEUpdateManyWithWhereWithoutTenantInput = {
    where: SMEScalarWhereInput
    data: XOR<SMEUpdateManyMutationInput, SMEUncheckedUpdateManyWithoutTenantInput>
  }

  export type SMEScalarWhereInput = {
    AND?: SMEScalarWhereInput | SMEScalarWhereInput[]
    OR?: SMEScalarWhereInput[]
    NOT?: SMEScalarWhereInput | SMEScalarWhereInput[]
    id?: StringFilter<"SME"> | string
    tenantId?: StringFilter<"SME"> | string
    userId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
  }

  export type InvestorUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    update: XOR<InvestorUpdateWithoutTenantInput, InvestorUncheckedUpdateWithoutTenantInput>
    create: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput>
  }

  export type InvestorUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    data: XOR<InvestorUpdateWithoutTenantInput, InvestorUncheckedUpdateWithoutTenantInput>
  }

  export type InvestorUpdateManyWithWhereWithoutTenantInput = {
    where: InvestorScalarWhereInput
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvestorScalarWhereInput = {
    AND?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    OR?: InvestorScalarWhereInput[]
    NOT?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    id?: StringFilter<"Investor"> | string
    tenantId?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
  }

  export type AdvisorUpsertWithWhereUniqueWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    update: XOR<AdvisorUpdateWithoutTenantInput, AdvisorUncheckedUpdateWithoutTenantInput>
    create: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput>
  }

  export type AdvisorUpdateWithWhereUniqueWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    data: XOR<AdvisorUpdateWithoutTenantInput, AdvisorUncheckedUpdateWithoutTenantInput>
  }

  export type AdvisorUpdateManyWithWhereWithoutTenantInput = {
    where: AdvisorScalarWhereInput
    data: XOR<AdvisorUpdateManyMutationInput, AdvisorUncheckedUpdateManyWithoutTenantInput>
  }

  export type AdvisorScalarWhereInput = {
    AND?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
    OR?: AdvisorScalarWhereInput[]
    NOT?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
    id?: StringFilter<"Advisor"> | string
    tenantId?: StringFilter<"Advisor"> | string
    userId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealUpdateWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
  }

  export type DealUpdateManyWithWhereWithoutTenantInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutTenantInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    terms?: StringNullableFilter<"Deal"> | string | null
    isDocumentLocked?: BoolFilter<"Deal"> | boolean
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutTenantInput, WorkflowUncheckedUpdateWithoutTenantInput>
    create: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutTenantInput, WorkflowUncheckedUpdateWithoutTenantInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutTenantInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutTenantInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: StringFilter<"Workflow"> | string
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type SMECreateWithoutUserInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutUserInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
  }

  export type InvestorCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutUserInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
  }

  export type AdvisorCreateWithoutUserInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutUserInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutUserInput = {
    update: XOR<SMEUpdateWithoutUserInput, SMEUncheckedUpdateWithoutUserInput>
    create: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutUserInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutUserInput, SMEUncheckedUpdateWithoutUserInput>
  }

  export type SMEUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutUserInput = {
    update: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type AdvisorUpsertWithoutUserInput = {
    update: XOR<AdvisorUpdateWithoutUserInput, AdvisorUncheckedUpdateWithoutUserInput>
    create: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutUserInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutUserInput, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantCreateWithoutSmesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSmesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSmesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
  }

  export type UserCreateWithoutSmeInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSmeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
  }

  export type DocumentCreateWithoutSmeInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput>
  }

  export type DocumentCreateManySmeInputEnvelope = {
    data: DocumentCreateManySmeInput | DocumentCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutSmeInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSmeInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput>
  }

  export type DealCreateManySmeInputEnvelope = {
    data: DealCreateManySmeInput | DealCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type CertificationCreateWithoutSmeInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor: AdvisorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutSmeInput = {
    id?: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput>
  }

  export type CertificationCreateManySmeInputEnvelope = {
    data: CertificationCreateManySmeInput | CertificationCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutSmeInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput>
  }

  export type WorkflowCreateManySmeInputEnvelope = {
    data: WorkflowCreateManySmeInput | WorkflowCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type DueDiligenceCreateWithoutSmeInput = {
    id?: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor?: AdvisorCreateNestedOneWithoutDueDiligencesInput
  }

  export type DueDiligenceUncheckedCreateWithoutSmeInput = {
    id?: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateOrConnectWithoutSmeInput = {
    where: DueDiligenceWhereUniqueInput
    create: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput>
  }

  export type DueDiligenceCreateManySmeInputEnvelope = {
    data: DueDiligenceCreateManySmeInput | DueDiligenceCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSmesInput = {
    update: XOR<TenantUpdateWithoutSmesInput, TenantUncheckedUpdateWithoutSmesInput>
    create: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSmesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSmesInput, TenantUncheckedUpdateWithoutSmesInput>
  }

  export type TenantUpdateWithoutSmesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSmesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutSmeInput = {
    update: XOR<UserUpdateWithoutSmeInput, UserUncheckedUpdateWithoutSmeInput>
    create: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmeInput, UserUncheckedUpdateWithoutSmeInput>
  }

  export type UserUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutSmeInput, DocumentUncheckedUpdateWithoutSmeInput>
    create: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutSmeInput, DocumentUncheckedUpdateWithoutSmeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutSmeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSmeInput>
  }

  export type DealUpsertWithWhereUniqueWithoutSmeInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutSmeInput, DealUncheckedUpdateWithoutSmeInput>
    create: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput>
  }

  export type DealUpdateWithWhereUniqueWithoutSmeInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutSmeInput, DealUncheckedUpdateWithoutSmeInput>
  }

  export type DealUpdateManyWithWhereWithoutSmeInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutSmeInput>
  }

  export type CertificationUpsertWithWhereUniqueWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutSmeInput, CertificationUncheckedUpdateWithoutSmeInput>
    create: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutSmeInput, CertificationUncheckedUpdateWithoutSmeInput>
  }

  export type CertificationUpdateManyWithWhereWithoutSmeInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutSmeInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutSmeInput, WorkflowUncheckedUpdateWithoutSmeInput>
    create: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutSmeInput, WorkflowUncheckedUpdateWithoutSmeInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutSmeInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutSmeInput>
  }

  export type DueDiligenceUpsertWithWhereUniqueWithoutSmeInput = {
    where: DueDiligenceWhereUniqueInput
    update: XOR<DueDiligenceUpdateWithoutSmeInput, DueDiligenceUncheckedUpdateWithoutSmeInput>
    create: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput>
  }

  export type DueDiligenceUpdateWithWhereUniqueWithoutSmeInput = {
    where: DueDiligenceWhereUniqueInput
    data: XOR<DueDiligenceUpdateWithoutSmeInput, DueDiligenceUncheckedUpdateWithoutSmeInput>
  }

  export type DueDiligenceUpdateManyWithWhereWithoutSmeInput = {
    where: DueDiligenceScalarWhereInput
    data: XOR<DueDiligenceUpdateManyMutationInput, DueDiligenceUncheckedUpdateManyWithoutSmeInput>
  }

  export type DueDiligenceScalarWhereInput = {
    AND?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
    OR?: DueDiligenceScalarWhereInput[]
    NOT?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
    id?: StringFilter<"DueDiligence"> | string
    smeId?: StringFilter<"DueDiligence"> | string
    advisorId?: StringNullableFilter<"DueDiligence"> | string | null
    financialScore?: FloatFilter<"DueDiligence"> | number
    teamScore?: FloatFilter<"DueDiligence"> | number
    marketScore?: FloatFilter<"DueDiligence"> | number
    productScore?: FloatFilter<"DueDiligence"> | number
    legalScore?: FloatFilter<"DueDiligence"> | number
    operationalScore?: FloatFilter<"DueDiligence"> | number
    overallScore?: FloatFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligence"> | Date | string
  }

  export type TenantCreateWithoutInvestorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvestorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvestorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
  }

  export type UserCreateWithoutInvestorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorCreateWithoutInvestorInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
  }

  export type DealInvestorUncheckedCreateWithoutInvestorInput = {
    id?: string
    dealId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorCreateOrConnectWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorCreateManyInvestorInputEnvelope = {
    data: DealInvestorCreateManyInvestorInput | DealInvestorCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutInvestorInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput>
  }

  export type WorkflowCreateManyInvestorInputEnvelope = {
    data: WorkflowCreateManyInvestorInput | WorkflowCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type SyndicateCreateWithoutLeadInvestorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutSyndicatesInput
    members?: SyndicateMemberCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUncheckedCreateWithoutLeadInvestorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateCreateOrConnectWithoutLeadInvestorInput = {
    where: SyndicateWhereUniqueInput
    create: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput>
  }

  export type SyndicateCreateManyLeadInvestorInputEnvelope = {
    data: SyndicateCreateManyLeadInvestorInput | SyndicateCreateManyLeadInvestorInput[]
    skipDuplicates?: boolean
  }

  export type SyndicateMemberCreateWithoutInvestorInput = {
    id?: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
    syndicate: SyndicateCreateNestedOneWithoutMembersInput
  }

  export type SyndicateMemberUncheckedCreateWithoutInvestorInput = {
    id?: string
    syndicateId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberCreateOrConnectWithoutInvestorInput = {
    where: SyndicateMemberWhereUniqueInput
    create: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput>
  }

  export type SyndicateMemberCreateManyInvestorInputEnvelope = {
    data: SyndicateMemberCreateManyInvestorInput | SyndicateMemberCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInvestorsInput = {
    update: XOR<TenantUpdateWithoutInvestorsInput, TenantUncheckedUpdateWithoutInvestorsInput>
    create: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvestorsInput, TenantUncheckedUpdateWithoutInvestorsInput>
  }

  export type TenantUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutInvestorInput = {
    update: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type UserUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealInvestorUpsertWithWhereUniqueWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    update: XOR<DealInvestorUpdateWithoutInvestorInput, DealInvestorUncheckedUpdateWithoutInvestorInput>
    create: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorUpdateWithWhereUniqueWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    data: XOR<DealInvestorUpdateWithoutInvestorInput, DealInvestorUncheckedUpdateWithoutInvestorInput>
  }

  export type DealInvestorUpdateManyWithWhereWithoutInvestorInput = {
    where: DealInvestorScalarWhereInput
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyWithoutInvestorInput>
  }

  export type DealInvestorScalarWhereInput = {
    AND?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
    OR?: DealInvestorScalarWhereInput[]
    NOT?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
    id?: StringFilter<"DealInvestor"> | string
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutInvestorInput, WorkflowUncheckedUpdateWithoutInvestorInput>
    create: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutInvestorInput, WorkflowUncheckedUpdateWithoutInvestorInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutInvestorInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutInvestorInput>
  }

  export type SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput = {
    where: SyndicateWhereUniqueInput
    update: XOR<SyndicateUpdateWithoutLeadInvestorInput, SyndicateUncheckedUpdateWithoutLeadInvestorInput>
    create: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput>
  }

  export type SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput = {
    where: SyndicateWhereUniqueInput
    data: XOR<SyndicateUpdateWithoutLeadInvestorInput, SyndicateUncheckedUpdateWithoutLeadInvestorInput>
  }

  export type SyndicateUpdateManyWithWhereWithoutLeadInvestorInput = {
    where: SyndicateScalarWhereInput
    data: XOR<SyndicateUpdateManyMutationInput, SyndicateUncheckedUpdateManyWithoutLeadInvestorInput>
  }

  export type SyndicateScalarWhereInput = {
    AND?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
    OR?: SyndicateScalarWhereInput[]
    NOT?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
    id?: StringFilter<"Syndicate"> | string
    tenantId?: StringFilter<"Syndicate"> | string
    name?: StringFilter<"Syndicate"> | string
    description?: StringNullableFilter<"Syndicate"> | string | null
    leadInvestorId?: StringFilter<"Syndicate"> | string
    targetAmount?: FloatFilter<"Syndicate"> | number
    minInvestment?: FloatFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableFilter<"Syndicate"> | number | null
    managementFee?: FloatFilter<"Syndicate"> | number
    carryFee?: FloatFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeFilter<"Syndicate"> | Date | string
  }

  export type SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput = {
    where: SyndicateMemberWhereUniqueInput
    update: XOR<SyndicateMemberUpdateWithoutInvestorInput, SyndicateMemberUncheckedUpdateWithoutInvestorInput>
    create: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput>
  }

  export type SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput = {
    where: SyndicateMemberWhereUniqueInput
    data: XOR<SyndicateMemberUpdateWithoutInvestorInput, SyndicateMemberUncheckedUpdateWithoutInvestorInput>
  }

  export type SyndicateMemberUpdateManyWithWhereWithoutInvestorInput = {
    where: SyndicateMemberScalarWhereInput
    data: XOR<SyndicateMemberUpdateManyMutationInput, SyndicateMemberUncheckedUpdateManyWithoutInvestorInput>
  }

  export type SyndicateMemberScalarWhereInput = {
    AND?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
    OR?: SyndicateMemberScalarWhereInput[]
    NOT?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
    id?: StringFilter<"SyndicateMember"> | string
    syndicateId?: StringFilter<"SyndicateMember"> | string
    investorId?: StringFilter<"SyndicateMember"> | string
    amount?: FloatFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFilter<"SyndicateMember"> | Date | string
  }

  export type TenantCreateWithoutAdvisorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAdvisorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAdvisorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
  }

  export type UserCreateWithoutAdvisorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdvisorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationCreateWithoutAdvisorInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutAdvisorInput = {
    id?: string
    smeId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationCreateManyAdvisorInputEnvelope = {
    data: CertificationCreateManyAdvisorInput | CertificationCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutAdvisorInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput>
  }

  export type WorkflowCreateManyAdvisorInputEnvelope = {
    data: WorkflowCreateManyAdvisorInput | WorkflowCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type DueDiligenceCreateWithoutAdvisorInput = {
    id?: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDueDiligencesInput
  }

  export type DueDiligenceUncheckedCreateWithoutAdvisorInput = {
    id?: string
    smeId: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateOrConnectWithoutAdvisorInput = {
    where: DueDiligenceWhereUniqueInput
    create: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput>
  }

  export type DueDiligenceCreateManyAdvisorInputEnvelope = {
    data: DueDiligenceCreateManyAdvisorInput | DueDiligenceCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAdvisorsInput = {
    update: XOR<TenantUpdateWithoutAdvisorsInput, TenantUncheckedUpdateWithoutAdvisorsInput>
    create: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAdvisorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAdvisorsInput, TenantUncheckedUpdateWithoutAdvisorsInput>
  }

  export type TenantUpdateWithoutAdvisorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAdvisorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAdvisorInput = {
    update: XOR<UserUpdateWithoutAdvisorInput, UserUncheckedUpdateWithoutAdvisorInput>
    create: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdvisorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdvisorInput, UserUncheckedUpdateWithoutAdvisorInput>
  }

  export type UserUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CertificationUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutAdvisorInput, CertificationUncheckedUpdateWithoutAdvisorInput>
    create: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutAdvisorInput, CertificationUncheckedUpdateWithoutAdvisorInput>
  }

  export type CertificationUpdateManyWithWhereWithoutAdvisorInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type WorkflowUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutAdvisorInput, WorkflowUncheckedUpdateWithoutAdvisorInput>
    create: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutAdvisorInput, WorkflowUncheckedUpdateWithoutAdvisorInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutAdvisorInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: DueDiligenceWhereUniqueInput
    update: XOR<DueDiligenceUpdateWithoutAdvisorInput, DueDiligenceUncheckedUpdateWithoutAdvisorInput>
    create: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput>
  }

  export type DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: DueDiligenceWhereUniqueInput
    data: XOR<DueDiligenceUpdateWithoutAdvisorInput, DueDiligenceUncheckedUpdateWithoutAdvisorInput>
  }

  export type DueDiligenceUpdateManyWithWhereWithoutAdvisorInput = {
    where: DueDiligenceScalarWhereInput
    data: XOR<DueDiligenceUpdateManyMutationInput, DueDiligenceUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type TenantCreateWithoutDealsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDealsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDealsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
  }

  export type SMECreateWithoutDealsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDealsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDealsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
  }

  export type DealInvestorCreateWithoutDealInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
  }

  export type DealInvestorUncheckedCreateWithoutDealInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorCreateOrConnectWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput>
  }

  export type DealInvestorCreateManyDealInputEnvelope = {
    data: DealInvestorCreateManyDealInput | DealInvestorCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDealInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    sme?: SMECreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutDealInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentCreateManyDealInputEnvelope = {
    data: DocumentCreateManyDealInput | DocumentCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutDealInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput>
  }

  export type WorkflowCreateManyDealInputEnvelope = {
    data: WorkflowCreateManyDealInput | WorkflowCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type SyndicateCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadInvestor: InvestorCreateNestedOneWithoutLeadSyndicatesInput
    members?: SyndicateMemberCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateCreateOrConnectWithoutDealInput = {
    where: SyndicateWhereUniqueInput
    create: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput>
  }

  export type SyndicateCreateManyDealInputEnvelope = {
    data: SyndicateCreateManyDealInput | SyndicateCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutDealsInput = {
    update: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDealsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type TenantUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutDealsInput = {
    update: XOR<SMEUpdateWithoutDealsInput, SMEUncheckedUpdateWithoutDealsInput>
    create: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDealsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDealsInput, SMEUncheckedUpdateWithoutDealsInput>
  }

  export type SMEUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type DealInvestorUpsertWithWhereUniqueWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    update: XOR<DealInvestorUpdateWithoutDealInput, DealInvestorUncheckedUpdateWithoutDealInput>
    create: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput>
  }

  export type DealInvestorUpdateWithWhereUniqueWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    data: XOR<DealInvestorUpdateWithoutDealInput, DealInvestorUncheckedUpdateWithoutDealInput>
  }

  export type DealInvestorUpdateManyWithWhereWithoutDealInput = {
    where: DealInvestorScalarWhereInput
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyWithoutDealInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDealInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDealInput>
  }

  export type WorkflowUpsertWithWhereUniqueWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutDealInput, WorkflowUncheckedUpdateWithoutDealInput>
    create: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutDealInput, WorkflowUncheckedUpdateWithoutDealInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutDealInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutDealInput>
  }

  export type SyndicateUpsertWithWhereUniqueWithoutDealInput = {
    where: SyndicateWhereUniqueInput
    update: XOR<SyndicateUpdateWithoutDealInput, SyndicateUncheckedUpdateWithoutDealInput>
    create: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput>
  }

  export type SyndicateUpdateWithWhereUniqueWithoutDealInput = {
    where: SyndicateWhereUniqueInput
    data: XOR<SyndicateUpdateWithoutDealInput, SyndicateUncheckedUpdateWithoutDealInput>
  }

  export type SyndicateUpdateManyWithWhereWithoutDealInput = {
    where: SyndicateScalarWhereInput
    data: XOR<SyndicateUpdateManyMutationInput, SyndicateUncheckedUpdateManyWithoutDealInput>
  }

  export type DealCreateWithoutInvestorsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutInvestorsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutInvestorsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
  }

  export type InvestorCreateWithoutDealInvestmentsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutDealInvestmentsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutDealInvestmentsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
  }

  export type DealUpsertWithoutInvestorsInput = {
    update: XOR<DealUpdateWithoutInvestorsInput, DealUncheckedUpdateWithoutInvestorsInput>
    create: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutInvestorsInput, DealUncheckedUpdateWithoutInvestorsInput>
  }

  export type DealUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type InvestorUpsertWithoutDealInvestmentsInput = {
    update: XOR<InvestorUpdateWithoutDealInvestmentsInput, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
    create: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutDealInvestmentsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutDealInvestmentsInput, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
  }

  export type InvestorUpdateWithoutDealInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutDealInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type TenantCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
  }

  export type SMECreateWithoutDocumentsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDocumentsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
  }

  export type DealCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutDocumentsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
  }

  export type TenantUpsertWithoutDocumentsInput = {
    update: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type TenantUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutDocumentsInput = {
    update: XOR<SMEUpdateWithoutDocumentsInput, SMEUncheckedUpdateWithoutDocumentsInput>
    create: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDocumentsInput, SMEUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMEUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type DealUpsertWithoutDocumentsInput = {
    update: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SMECreateWithoutCertificationsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutCertificationsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutCertificationsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
  }

  export type AdvisorCreateWithoutCertificationsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutCertificationsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutCertificationsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
  }

  export type SMEUpsertWithoutCertificationsInput = {
    update: XOR<SMEUpdateWithoutCertificationsInput, SMEUncheckedUpdateWithoutCertificationsInput>
    create: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutCertificationsInput, SMEUncheckedUpdateWithoutCertificationsInput>
  }

  export type SMEUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type AdvisorUpsertWithoutCertificationsInput = {
    update: XOR<AdvisorUpdateWithoutCertificationsInput, AdvisorUncheckedUpdateWithoutCertificationsInput>
    create: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutCertificationsInput, AdvisorUncheckedUpdateWithoutCertificationsInput>
  }

  export type AdvisorUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type TenantCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWorkflowsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
  }

  export type SMECreateWithoutWorkflowsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutWorkflowsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
  }

  export type InvestorCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutWorkflowsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
  }

  export type AdvisorCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutWorkflowsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
  }

  export type DealCreateWithoutWorkflowsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutWorkflowsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
  }

  export type TenantUpsertWithoutWorkflowsInput = {
    update: XOR<TenantUpdateWithoutWorkflowsInput, TenantUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWorkflowsInput, TenantUncheckedUpdateWithoutWorkflowsInput>
  }

  export type TenantUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutWorkflowsInput = {
    update: XOR<SMEUpdateWithoutWorkflowsInput, SMEUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutWorkflowsInput, SMEUncheckedUpdateWithoutWorkflowsInput>
  }

  export type SMEUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutWorkflowsInput = {
    update: XOR<InvestorUpdateWithoutWorkflowsInput, InvestorUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutWorkflowsInput, InvestorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type AdvisorUpsertWithoutWorkflowsInput = {
    update: XOR<AdvisorUpdateWithoutWorkflowsInput, AdvisorUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutWorkflowsInput, AdvisorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AdvisorUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type DealUpsertWithoutWorkflowsInput = {
    update: XOR<DealUpdateWithoutWorkflowsInput, DealUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutWorkflowsInput, DealUncheckedUpdateWithoutWorkflowsInput>
  }

  export type DealUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type InvestorCreateWithoutLeadSyndicatesInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutLeadSyndicatesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutLeadSyndicatesInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
  }

  export type DealCreateWithoutSyndicatesInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSyndicatesInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSyndicatesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
  }

  export type SyndicateMemberCreateWithoutSyndicateInput = {
    id?: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutSyndicateMembershipsInput
  }

  export type SyndicateMemberUncheckedCreateWithoutSyndicateInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberCreateOrConnectWithoutSyndicateInput = {
    where: SyndicateMemberWhereUniqueInput
    create: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput>
  }

  export type SyndicateMemberCreateManySyndicateInputEnvelope = {
    data: SyndicateMemberCreateManySyndicateInput | SyndicateMemberCreateManySyndicateInput[]
    skipDuplicates?: boolean
  }

  export type InvestorUpsertWithoutLeadSyndicatesInput = {
    update: XOR<InvestorUpdateWithoutLeadSyndicatesInput, InvestorUncheckedUpdateWithoutLeadSyndicatesInput>
    create: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutLeadSyndicatesInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutLeadSyndicatesInput, InvestorUncheckedUpdateWithoutLeadSyndicatesInput>
  }

  export type InvestorUpdateWithoutLeadSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutLeadSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type DealUpsertWithoutSyndicatesInput = {
    update: XOR<DealUpdateWithoutSyndicatesInput, DealUncheckedUpdateWithoutSyndicatesInput>
    create: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutSyndicatesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutSyndicatesInput, DealUncheckedUpdateWithoutSyndicatesInput>
  }

  export type DealUpdateWithoutSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput = {
    where: SyndicateMemberWhereUniqueInput
    update: XOR<SyndicateMemberUpdateWithoutSyndicateInput, SyndicateMemberUncheckedUpdateWithoutSyndicateInput>
    create: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput>
  }

  export type SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput = {
    where: SyndicateMemberWhereUniqueInput
    data: XOR<SyndicateMemberUpdateWithoutSyndicateInput, SyndicateMemberUncheckedUpdateWithoutSyndicateInput>
  }

  export type SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput = {
    where: SyndicateMemberScalarWhereInput
    data: XOR<SyndicateMemberUpdateManyMutationInput, SyndicateMemberUncheckedUpdateManyWithoutSyndicateInput>
  }

  export type SyndicateCreateWithoutMembersInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadInvestor: InvestorCreateNestedOneWithoutLeadSyndicatesInput
    deal?: DealCreateNestedOneWithoutSyndicatesInput
  }

  export type SyndicateUncheckedCreateWithoutMembersInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateCreateOrConnectWithoutMembersInput = {
    where: SyndicateWhereUniqueInput
    create: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
  }

  export type InvestorCreateWithoutSyndicateMembershipsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
  }

  export type InvestorUncheckedCreateWithoutSyndicateMembershipsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
  }

  export type InvestorCreateOrConnectWithoutSyndicateMembershipsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
  }

  export type SyndicateUpsertWithoutMembersInput = {
    update: XOR<SyndicateUpdateWithoutMembersInput, SyndicateUncheckedUpdateWithoutMembersInput>
    create: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
    where?: SyndicateWhereInput
  }

  export type SyndicateUpdateToOneWithWhereWithoutMembersInput = {
    where?: SyndicateWhereInput
    data: XOR<SyndicateUpdateWithoutMembersInput, SyndicateUncheckedUpdateWithoutMembersInput>
  }

  export type SyndicateUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadInvestor?: InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput
    deal?: DealUpdateOneWithoutSyndicatesNestedInput
  }

  export type SyndicateUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpsertWithoutSyndicateMembershipsInput = {
    update: XOR<InvestorUpdateWithoutSyndicateMembershipsInput, InvestorUncheckedUpdateWithoutSyndicateMembershipsInput>
    create: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutSyndicateMembershipsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutSyndicateMembershipsInput, InvestorUncheckedUpdateWithoutSyndicateMembershipsInput>
  }

  export type InvestorUpdateWithoutSyndicateMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutSyndicateMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
  }

  export type SMECreateWithoutDueDiligencesInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDueDiligencesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDueDiligencesInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
  }

  export type AdvisorCreateWithoutDueDiligencesInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutDueDiligencesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutDueDiligencesInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
  }

  export type SMEUpsertWithoutDueDiligencesInput = {
    update: XOR<SMEUpdateWithoutDueDiligencesInput, SMEUncheckedUpdateWithoutDueDiligencesInput>
    create: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDueDiligencesInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDueDiligencesInput, SMEUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type SMEUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type AdvisorUpsertWithoutDueDiligencesInput = {
    update: XOR<AdvisorUpdateWithoutDueDiligencesInput, AdvisorUncheckedUpdateWithoutDueDiligencesInput>
    create: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutDueDiligencesInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutDueDiligencesInput, AdvisorUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type AdvisorUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    likes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CommunityPostCreateWithoutCommentsInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostCreateOrConnectWithoutCommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CommunityPostUpsertWithoutCommentsInput = {
    update: XOR<CommunityPostUpdateWithoutCommentsInput, CommunityPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    where?: CommunityPostWhereInput
  }

  export type CommunityPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CommunityPostWhereInput
    data: XOR<CommunityPostUpdateWithoutCommentsInput, CommunityPostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommunityPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type SecondaryTradeCreateWithoutListingInput = {
    id?: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUncheckedCreateWithoutListingInput = {
    id?: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeCreateOrConnectWithoutListingInput = {
    where: SecondaryTradeWhereUniqueInput
    create: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput>
  }

  export type SecondaryTradeCreateManyListingInputEnvelope = {
    data: SecondaryTradeCreateManyListingInput | SecondaryTradeCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type SecondaryTradeUpsertWithWhereUniqueWithoutListingInput = {
    where: SecondaryTradeWhereUniqueInput
    update: XOR<SecondaryTradeUpdateWithoutListingInput, SecondaryTradeUncheckedUpdateWithoutListingInput>
    create: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput>
  }

  export type SecondaryTradeUpdateWithWhereUniqueWithoutListingInput = {
    where: SecondaryTradeWhereUniqueInput
    data: XOR<SecondaryTradeUpdateWithoutListingInput, SecondaryTradeUncheckedUpdateWithoutListingInput>
  }

  export type SecondaryTradeUpdateManyWithWhereWithoutListingInput = {
    where: SecondaryTradeScalarWhereInput
    data: XOR<SecondaryTradeUpdateManyMutationInput, SecondaryTradeUncheckedUpdateManyWithoutListingInput>
  }

  export type SecondaryTradeScalarWhereInput = {
    AND?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
    OR?: SecondaryTradeScalarWhereInput[]
    NOT?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
    id?: StringFilter<"SecondaryTrade"> | string
    listingId?: StringFilter<"SecondaryTrade"> | string
    buyerId?: StringFilter<"SecondaryTrade"> | string
    sellerId?: StringFilter<"SecondaryTrade"> | string
    shares?: FloatFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatFilter<"SecondaryTrade"> | number
    totalAmount?: FloatFilter<"SecondaryTrade"> | number
    fee?: FloatFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
  }

  export type SecondaryListingCreateWithoutTradesInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryListingUncheckedCreateWithoutTradesInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryListingCreateOrConnectWithoutTradesInput = {
    where: SecondaryListingWhereUniqueInput
    create: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
  }

  export type SecondaryListingUpsertWithoutTradesInput = {
    update: XOR<SecondaryListingUpdateWithoutTradesInput, SecondaryListingUncheckedUpdateWithoutTradesInput>
    create: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
    where?: SecondaryListingWhereInput
  }

  export type SecondaryListingUpdateToOneWithWhereWithoutTradesInput = {
    where?: SecondaryListingWhereInput
    data: XOR<SecondaryListingUpdateWithoutTradesInput, SecondaryListingUncheckedUpdateWithoutTradesInput>
  }

  export type SecondaryListingUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingUncheckedUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMECreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorCreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisorCreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyTenantInput = {
    id?: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMEUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManySmeInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManySmeInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateManySmeInput = {
    id?: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManySmeInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateManySmeInput = {
    id?: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneWithoutDueDiligencesNestedInput
  }

  export type DueDiligenceUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyInvestorInput = {
    id?: string
    dealId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyInvestorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateCreateManyLeadInvestorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateMemberCreateManyInvestorInput = {
    id?: string
    syndicateId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type DealInvestorUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateUpdateWithoutLeadInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutSyndicatesNestedInput
    members?: SyndicateMemberUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateWithoutLeadInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateManyWithoutLeadInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syndicate?: SyndicateUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SyndicateMemberUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyAdvisorInput = {
    id?: string
    smeId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyAdvisorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateManyAdvisorInput = {
    id?: string
    smeId: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDueDiligencesNestedInput
  }

  export type DueDiligenceUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyDealInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyDealInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyDealInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateCreateManyDealInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadInvestor?: InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput
    members?: SyndicateMemberUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberCreateManySyndicateInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberUpdateWithoutSyndicateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutSyndicateMembershipsNestedInput
  }

  export type SyndicateMemberUncheckedUpdateWithoutSyndicateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutSyndicateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeCreateManyListingInput = {
    id?: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SMECountOutputTypeDefaultArgs instead
     */
    export type SMECountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SMECountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorCountOutputTypeDefaultArgs instead
     */
    export type InvestorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisorCountOutputTypeDefaultArgs instead
     */
    export type AdvisorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealCountOutputTypeDefaultArgs instead
     */
    export type DealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyndicateCountOutputTypeDefaultArgs instead
     */
    export type SyndicateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyndicateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityPostCountOutputTypeDefaultArgs instead
     */
    export type CommunityPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecondaryListingCountOutputTypeDefaultArgs instead
     */
    export type SecondaryListingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecondaryListingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SMEDefaultArgs instead
     */
    export type SMEArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SMEDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorDefaultArgs instead
     */
    export type InvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisorDefaultArgs instead
     */
    export type AdvisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealDefaultArgs instead
     */
    export type DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealInvestorDefaultArgs instead
     */
    export type DealInvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealInvestorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificationDefaultArgs instead
     */
    export type CertificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefaultArgs instead
     */
    export type WorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyndicateDefaultArgs instead
     */
    export type SyndicateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyndicateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyndicateMemberDefaultArgs instead
     */
    export type SyndicateMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyndicateMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DueDiligenceDefaultArgs instead
     */
    export type DueDiligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DueDiligenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityPostDefaultArgs instead
     */
    export type CommunityPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecondaryListingDefaultArgs instead
     */
    export type SecondaryListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecondaryListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecondaryTradeDefaultArgs instead
     */
    export type SecondaryTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecondaryTradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}