
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SME
 * 
 */
export type SME = $Result.DefaultSelection<Prisma.$SMEPayload>
/**
 * Model Investor
 * 
 */
export type Investor = $Result.DefaultSelection<Prisma.$InvestorPayload>
/**
 * Model Advisor
 * 
 */
export type Advisor = $Result.DefaultSelection<Prisma.$AdvisorPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model DealInvestor
 * 
 */
export type DealInvestor = $Result.DefaultSelection<Prisma.$DealInvestorPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model Syndicate
 * 
 */
export type Syndicate = $Result.DefaultSelection<Prisma.$SyndicatePayload>
/**
 * Model SyndicateMember
 * 
 */
export type SyndicateMember = $Result.DefaultSelection<Prisma.$SyndicateMemberPayload>
/**
 * Model DueDiligence
 * 
 */
export type DueDiligence = $Result.DefaultSelection<Prisma.$DueDiligencePayload>
/**
 * Model CommunityPost
 * 
 */
export type CommunityPost = $Result.DefaultSelection<Prisma.$CommunityPostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model SecondaryListing
 * 
 */
export type SecondaryListing = $Result.DefaultSelection<Prisma.$SecondaryListingPayload>
/**
 * Model SecondaryTrade
 * 
 */
export type SecondaryTrade = $Result.DefaultSelection<Prisma.$SecondaryTradePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model AdvisoryService
 * 
 */
export type AdvisoryService = $Result.DefaultSelection<Prisma.$AdvisoryServicePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model MatchInterest
 * 
 */
export type MatchInterest = $Result.DefaultSelection<Prisma.$MatchInterestPayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SME: 'SME',
  INVESTOR: 'INVESTOR',
  ADVISOR: 'ADVISOR',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN',
  SUPPORT: 'SUPPORT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Language: {
  EN: 'EN',
  KM: 'KM',
  ZH: 'ZH'
};

export type Language = (typeof Language)[keyof typeof Language]


export const SMEStage: {
  SEED: 'SEED',
  GROWTH: 'GROWTH',
  EXPANSION: 'EXPANSION',
  MATURE: 'MATURE'
};

export type SMEStage = (typeof SMEStage)[keyof typeof SMEStage]


export const SMEStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  CERTIFIED: 'CERTIFIED',
  REJECTED: 'REJECTED'
};

export type SMEStatus = (typeof SMEStatus)[keyof typeof SMEStatus]


export const InvestorType: {
  ANGEL: 'ANGEL',
  VENTURE_CAPITAL: 'VENTURE_CAPITAL',
  PRIVATE_EQUITY: 'PRIVATE_EQUITY',
  CORPORATE: 'CORPORATE',
  INSTITUTIONAL: 'INSTITUTIONAL'
};

export type InvestorType = (typeof InvestorType)[keyof typeof InvestorType]


export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  UNDER_REVIEW: 'UNDER_REVIEW'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const AdvisorStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type AdvisorStatus = (typeof AdvisorStatus)[keyof typeof AdvisorStatus]


export const DealStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  NEGOTIATION: 'NEGOTIATION',
  FUNDED: 'FUNDED',
  CLOSED: 'CLOSED',
  CANCELLED: 'CANCELLED'
};

export type DealStatus = (typeof DealStatus)[keyof typeof DealStatus]


export const InvestmentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type InvestmentStatus = (typeof InvestmentStatus)[keyof typeof InvestmentStatus]


export const DocumentType: {
  PITCH_DECK: 'PITCH_DECK',
  FINANCIAL_STATEMENT: 'FINANCIAL_STATEMENT',
  BUSINESS_PLAN: 'BUSINESS_PLAN',
  LEGAL_DOCUMENT: 'LEGAL_DOCUMENT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const CertificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type CertificationStatus = (typeof CertificationStatus)[keyof typeof CertificationStatus]


export const WorkflowType: {
  SME_ONBOARDING: 'SME_ONBOARDING',
  SME_CERTIFICATION: 'SME_CERTIFICATION',
  INVESTOR_ONBOARDING: 'INVESTOR_ONBOARDING',
  DEAL_APPROVAL: 'DEAL_APPROVAL',
  KYC_VERIFICATION: 'KYC_VERIFICATION'
};

export type WorkflowType = (typeof WorkflowType)[keyof typeof WorkflowType]


export const WorkflowStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]


export const SyndicateStatus: {
  FORMING: 'FORMING',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  FUNDED: 'FUNDED',
  DISSOLVED: 'DISSOLVED'
};

export type SyndicateStatus = (typeof SyndicateStatus)[keyof typeof SyndicateStatus]


export const SyndicateMemberStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type SyndicateMemberStatus = (typeof SyndicateMemberStatus)[keyof typeof SyndicateMemberStatus]


export const RiskLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  VERY_HIGH: 'VERY_HIGH'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const DueDiligenceStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type DueDiligenceStatus = (typeof DueDiligenceStatus)[keyof typeof DueDiligenceStatus]


export const PostCategory: {
  GENERAL: 'GENERAL',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  DEAL_UPDATE: 'DEAL_UPDATE',
  INVESTOR_INSIGHT: 'INVESTOR_INSIGHT',
  SME_NEWS: 'SME_NEWS',
  QUESTION: 'QUESTION',
  SUCCESS_STORY: 'SUCCESS_STORY'
};

export type PostCategory = (typeof PostCategory)[keyof typeof PostCategory]


export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  HIDDEN: 'HIDDEN',
  DELETED: 'DELETED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const ListingStatus: {
  ACTIVE: 'ACTIVE',
  SOLD: 'SOLD',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const TradeStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type TradeStatus = (typeof TradeStatus)[keyof typeof TradeStatus]


export const NotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  DEAL: 'DEAL',
  SYSTEM: 'SYSTEM',
  MATCH_FOUND: 'MATCH_FOUND',
  INTEREST_RECEIVED: 'INTEREST_RECEIVED',
  DEAL_UPDATE: 'DEAL_UPDATE',
  DOCUMENT_UPLOADED: 'DOCUMENT_UPLOADED',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  MEETING_REMINDER: 'MEETING_REMINDER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const MatchStatus: {
  PENDING: 'PENDING',
  ADVISOR_VERIFIED: 'ADVISOR_VERIFIED',
  REJECTED: 'REJECTED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  ABA_PAYWAY: 'ABA_PAYWAY',
  KHQR: 'KHQR',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type SMEStage = $Enums.SMEStage

export const SMEStage: typeof $Enums.SMEStage

export type SMEStatus = $Enums.SMEStatus

export const SMEStatus: typeof $Enums.SMEStatus

export type InvestorType = $Enums.InvestorType

export const InvestorType: typeof $Enums.InvestorType

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type AdvisorStatus = $Enums.AdvisorStatus

export const AdvisorStatus: typeof $Enums.AdvisorStatus

export type DealStatus = $Enums.DealStatus

export const DealStatus: typeof $Enums.DealStatus

export type InvestmentStatus = $Enums.InvestmentStatus

export const InvestmentStatus: typeof $Enums.InvestmentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type CertificationStatus = $Enums.CertificationStatus

export const CertificationStatus: typeof $Enums.CertificationStatus

export type WorkflowType = $Enums.WorkflowType

export const WorkflowType: typeof $Enums.WorkflowType

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

export type SyndicateStatus = $Enums.SyndicateStatus

export const SyndicateStatus: typeof $Enums.SyndicateStatus

export type SyndicateMemberStatus = $Enums.SyndicateMemberStatus

export const SyndicateMemberStatus: typeof $Enums.SyndicateMemberStatus

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type DueDiligenceStatus = $Enums.DueDiligenceStatus

export const DueDiligenceStatus: typeof $Enums.DueDiligenceStatus

export type PostCategory = $Enums.PostCategory

export const PostCategory: typeof $Enums.PostCategory

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type TradeStatus = $Enums.TradeStatus

export const TradeStatus: typeof $Enums.TradeStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.sME`: Exposes CRUD operations for the **SME** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMES
    * const sMES = await prisma.sME.findMany()
    * ```
    */
  get sME(): Prisma.SMEDelegate<ExtArgs>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **Investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.InvestorDelegate<ExtArgs>;

  /**
   * `prisma.advisor`: Exposes CRUD operations for the **Advisor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advisors
    * const advisors = await prisma.advisor.findMany()
    * ```
    */
  get advisor(): Prisma.AdvisorDelegate<ExtArgs>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs>;

  /**
   * `prisma.dealInvestor`: Exposes CRUD operations for the **DealInvestor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DealInvestors
    * const dealInvestors = await prisma.dealInvestor.findMany()
    * ```
    */
  get dealInvestor(): Prisma.DealInvestorDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs>;

  /**
   * `prisma.syndicate`: Exposes CRUD operations for the **Syndicate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Syndicates
    * const syndicates = await prisma.syndicate.findMany()
    * ```
    */
  get syndicate(): Prisma.SyndicateDelegate<ExtArgs>;

  /**
   * `prisma.syndicateMember`: Exposes CRUD operations for the **SyndicateMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyndicateMembers
    * const syndicateMembers = await prisma.syndicateMember.findMany()
    * ```
    */
  get syndicateMember(): Prisma.SyndicateMemberDelegate<ExtArgs>;

  /**
   * `prisma.dueDiligence`: Exposes CRUD operations for the **DueDiligence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DueDiligences
    * const dueDiligences = await prisma.dueDiligence.findMany()
    * ```
    */
  get dueDiligence(): Prisma.DueDiligenceDelegate<ExtArgs>;

  /**
   * `prisma.communityPost`: Exposes CRUD operations for the **CommunityPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPosts
    * const communityPosts = await prisma.communityPost.findMany()
    * ```
    */
  get communityPost(): Prisma.CommunityPostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.secondaryListing`: Exposes CRUD operations for the **SecondaryListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecondaryListings
    * const secondaryListings = await prisma.secondaryListing.findMany()
    * ```
    */
  get secondaryListing(): Prisma.SecondaryListingDelegate<ExtArgs>;

  /**
   * `prisma.secondaryTrade`: Exposes CRUD operations for the **SecondaryTrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecondaryTrades
    * const secondaryTrades = await prisma.secondaryTrade.findMany()
    * ```
    */
  get secondaryTrade(): Prisma.SecondaryTradeDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.advisoryService`: Exposes CRUD operations for the **AdvisoryService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvisoryServices
    * const advisoryServices = await prisma.advisoryService.findMany()
    * ```
    */
  get advisoryService(): Prisma.AdvisoryServiceDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs>;

  /**
   * `prisma.matchInterest`: Exposes CRUD operations for the **MatchInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchInterests
    * const matchInterests = await prisma.matchInterest.findMany()
    * ```
    */
  get matchInterest(): Prisma.MatchInterestDelegate<ExtArgs>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    SME: 'SME',
    Investor: 'Investor',
    Advisor: 'Advisor',
    Deal: 'Deal',
    DealInvestor: 'DealInvestor',
    Document: 'Document',
    Certification: 'Certification',
    Workflow: 'Workflow',
    Syndicate: 'Syndicate',
    SyndicateMember: 'SyndicateMember',
    DueDiligence: 'DueDiligence',
    CommunityPost: 'CommunityPost',
    Comment: 'Comment',
    SecondaryListing: 'SecondaryListing',
    SecondaryTrade: 'SecondaryTrade',
    Notification: 'Notification',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    AdvisoryService: 'AdvisoryService',
    Booking: 'Booking',
    Match: 'Match',
    MatchInterest: 'MatchInterest',
    PushSubscription: 'PushSubscription',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'tenant' | 'user' | 'sME' | 'investor' | 'advisor' | 'deal' | 'dealInvestor' | 'document' | 'certification' | 'workflow' | 'syndicate' | 'syndicateMember' | 'dueDiligence' | 'communityPost' | 'comment' | 'secondaryListing' | 'secondaryTrade' | 'notification' | 'conversation' | 'conversationParticipant' | 'message' | 'advisoryService' | 'booking' | 'match' | 'matchInterest' | 'pushSubscription' | 'payment'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>,
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SME: {
        payload: Prisma.$SMEPayload<ExtArgs>
        fields: Prisma.SMEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMEFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMEFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          findFirst: {
            args: Prisma.SMEFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMEFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          findMany: {
            args: Prisma.SMEFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>[]
          }
          create: {
            args: Prisma.SMECreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          createMany: {
            args: Prisma.SMECreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SMEDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          update: {
            args: Prisma.SMEUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          deleteMany: {
            args: Prisma.SMEDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SMEUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SMEUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          aggregate: {
            args: Prisma.SMEAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSME>
          }
          groupBy: {
            args: Prisma.SMEGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SMEGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMECountArgs<ExtArgs>,
            result: $Utils.Optional<SMECountAggregateOutputType> | number
          }
        }
      }
      Investor: {
        payload: Prisma.$InvestorPayload<ExtArgs>
        fields: Prisma.InvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findFirst: {
            args: Prisma.InvestorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findMany: {
            args: Prisma.InvestorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          create: {
            args: Prisma.InvestorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          createMany: {
            args: Prisma.InvestorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvestorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          update: {
            args: Prisma.InvestorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          deleteMany: {
            args: Prisma.InvestorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvestorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.InvestorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorCountArgs<ExtArgs>,
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      Advisor: {
        payload: Prisma.$AdvisorPayload<ExtArgs>
        fields: Prisma.AdvisorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvisorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvisorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          findFirst: {
            args: Prisma.AdvisorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvisorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          findMany: {
            args: Prisma.AdvisorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>[]
          }
          create: {
            args: Prisma.AdvisorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          createMany: {
            args: Prisma.AdvisorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdvisorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          update: {
            args: Prisma.AdvisorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          deleteMany: {
            args: Prisma.AdvisorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdvisorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdvisorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          aggregate: {
            args: Prisma.AdvisorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdvisor>
          }
          groupBy: {
            args: Prisma.AdvisorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdvisorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvisorCountArgs<ExtArgs>,
            result: $Utils.Optional<AdvisorCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>,
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      DealInvestor: {
        payload: Prisma.$DealInvestorPayload<ExtArgs>
        fields: Prisma.DealInvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealInvestorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealInvestorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          findFirst: {
            args: Prisma.DealInvestorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealInvestorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          findMany: {
            args: Prisma.DealInvestorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>[]
          }
          create: {
            args: Prisma.DealInvestorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          createMany: {
            args: Prisma.DealInvestorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DealInvestorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          update: {
            args: Prisma.DealInvestorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          deleteMany: {
            args: Prisma.DealInvestorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DealInvestorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DealInvestorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          aggregate: {
            args: Prisma.DealInvestorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDealInvestor>
          }
          groupBy: {
            args: Prisma.DealInvestorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DealInvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealInvestorCountArgs<ExtArgs>,
            result: $Utils.Optional<DealInvestorCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>,
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>,
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      Syndicate: {
        payload: Prisma.$SyndicatePayload<ExtArgs>
        fields: Prisma.SyndicateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyndicateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyndicateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          findFirst: {
            args: Prisma.SyndicateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyndicateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          findMany: {
            args: Prisma.SyndicateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>[]
          }
          create: {
            args: Prisma.SyndicateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          createMany: {
            args: Prisma.SyndicateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SyndicateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          update: {
            args: Prisma.SyndicateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          deleteMany: {
            args: Prisma.SyndicateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SyndicateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SyndicateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicatePayload>
          }
          aggregate: {
            args: Prisma.SyndicateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSyndicate>
          }
          groupBy: {
            args: Prisma.SyndicateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyndicateCountArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateCountAggregateOutputType> | number
          }
        }
      }
      SyndicateMember: {
        payload: Prisma.$SyndicateMemberPayload<ExtArgs>
        fields: Prisma.SyndicateMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyndicateMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyndicateMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          findFirst: {
            args: Prisma.SyndicateMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyndicateMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          findMany: {
            args: Prisma.SyndicateMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>[]
          }
          create: {
            args: Prisma.SyndicateMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          createMany: {
            args: Prisma.SyndicateMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SyndicateMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          update: {
            args: Prisma.SyndicateMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          deleteMany: {
            args: Prisma.SyndicateMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SyndicateMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SyndicateMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SyndicateMemberPayload>
          }
          aggregate: {
            args: Prisma.SyndicateMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSyndicateMember>
          }
          groupBy: {
            args: Prisma.SyndicateMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyndicateMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<SyndicateMemberCountAggregateOutputType> | number
          }
        }
      }
      DueDiligence: {
        payload: Prisma.$DueDiligencePayload<ExtArgs>
        fields: Prisma.DueDiligenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DueDiligenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DueDiligenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          findFirst: {
            args: Prisma.DueDiligenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DueDiligenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          findMany: {
            args: Prisma.DueDiligenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>[]
          }
          create: {
            args: Prisma.DueDiligenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          createMany: {
            args: Prisma.DueDiligenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DueDiligenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          update: {
            args: Prisma.DueDiligenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          deleteMany: {
            args: Prisma.DueDiligenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DueDiligenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DueDiligenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DueDiligencePayload>
          }
          aggregate: {
            args: Prisma.DueDiligenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDueDiligence>
          }
          groupBy: {
            args: Prisma.DueDiligenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DueDiligenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DueDiligenceCountArgs<ExtArgs>,
            result: $Utils.Optional<DueDiligenceCountAggregateOutputType> | number
          }
        }
      }
      CommunityPost: {
        payload: Prisma.$CommunityPostPayload<ExtArgs>
        fields: Prisma.CommunityPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          findFirst: {
            args: Prisma.CommunityPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          findMany: {
            args: Prisma.CommunityPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>[]
          }
          create: {
            args: Prisma.CommunityPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          createMany: {
            args: Prisma.CommunityPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          update: {
            args: Prisma.CommunityPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          deleteMany: {
            args: Prisma.CommunityPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          aggregate: {
            args: Prisma.CommunityPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunityPost>
          }
          groupBy: {
            args: Prisma.CommunityPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityPostCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityPostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      SecondaryListing: {
        payload: Prisma.$SecondaryListingPayload<ExtArgs>
        fields: Prisma.SecondaryListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecondaryListingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecondaryListingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          findFirst: {
            args: Prisma.SecondaryListingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecondaryListingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          findMany: {
            args: Prisma.SecondaryListingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>[]
          }
          create: {
            args: Prisma.SecondaryListingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          createMany: {
            args: Prisma.SecondaryListingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SecondaryListingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          update: {
            args: Prisma.SecondaryListingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          deleteMany: {
            args: Prisma.SecondaryListingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SecondaryListingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SecondaryListingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryListingPayload>
          }
          aggregate: {
            args: Prisma.SecondaryListingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSecondaryListing>
          }
          groupBy: {
            args: Prisma.SecondaryListingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecondaryListingCountArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryListingCountAggregateOutputType> | number
          }
        }
      }
      SecondaryTrade: {
        payload: Prisma.$SecondaryTradePayload<ExtArgs>
        fields: Prisma.SecondaryTradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecondaryTradeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecondaryTradeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          findFirst: {
            args: Prisma.SecondaryTradeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecondaryTradeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          findMany: {
            args: Prisma.SecondaryTradeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>[]
          }
          create: {
            args: Prisma.SecondaryTradeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          createMany: {
            args: Prisma.SecondaryTradeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SecondaryTradeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          update: {
            args: Prisma.SecondaryTradeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          deleteMany: {
            args: Prisma.SecondaryTradeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SecondaryTradeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SecondaryTradeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SecondaryTradePayload>
          }
          aggregate: {
            args: Prisma.SecondaryTradeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSecondaryTrade>
          }
          groupBy: {
            args: Prisma.SecondaryTradeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryTradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecondaryTradeCountArgs<ExtArgs>,
            result: $Utils.Optional<SecondaryTradeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      AdvisoryService: {
        payload: Prisma.$AdvisoryServicePayload<ExtArgs>
        fields: Prisma.AdvisoryServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvisoryServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvisoryServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>
          }
          findFirst: {
            args: Prisma.AdvisoryServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvisoryServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>
          }
          findMany: {
            args: Prisma.AdvisoryServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>[]
          }
          create: {
            args: Prisma.AdvisoryServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>
          }
          createMany: {
            args: Prisma.AdvisoryServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdvisoryServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>
          }
          update: {
            args: Prisma.AdvisoryServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>
          }
          deleteMany: {
            args: Prisma.AdvisoryServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdvisoryServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdvisoryServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvisoryServicePayload>
          }
          aggregate: {
            args: Prisma.AdvisoryServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdvisoryService>
          }
          groupBy: {
            args: Prisma.AdvisoryServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdvisoryServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvisoryServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<AdvisoryServiceCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>,
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>,
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      MatchInterest: {
        payload: Prisma.$MatchInterestPayload<ExtArgs>
        fields: Prisma.MatchInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchInterestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchInterestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>
          }
          findFirst: {
            args: Prisma.MatchInterestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchInterestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>
          }
          findMany: {
            args: Prisma.MatchInterestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>[]
          }
          create: {
            args: Prisma.MatchInterestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>
          }
          createMany: {
            args: Prisma.MatchInterestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MatchInterestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>
          }
          update: {
            args: Prisma.MatchInterestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>
          }
          deleteMany: {
            args: Prisma.MatchInterestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MatchInterestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MatchInterestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MatchInterestPayload>
          }
          aggregate: {
            args: Prisma.MatchInterestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMatchInterest>
          }
          groupBy: {
            args: Prisma.MatchInterestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MatchInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchInterestCountArgs<ExtArgs>,
            result: $Utils.Optional<MatchInterestCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    smes: number
    investors: number
    advisors: number
    deals: number
    workflows: number
    documents: number
    notifications: number
    pushSubscriptions: number
    conversations: number
    matches: number
    payments: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    smes?: boolean | TenantCountOutputTypeCountSmesArgs
    investors?: boolean | TenantCountOutputTypeCountInvestorsArgs
    advisors?: boolean | TenantCountOutputTypeCountAdvisorsArgs
    deals?: boolean | TenantCountOutputTypeCountDealsArgs
    workflows?: boolean | TenantCountOutputTypeCountWorkflowsArgs
    documents?: boolean | TenantCountOutputTypeCountDocumentsArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
    pushSubscriptions?: boolean | TenantCountOutputTypeCountPushSubscriptionsArgs
    conversations?: boolean | TenantCountOutputTypeCountConversationsArgs
    matches?: boolean | TenantCountOutputTypeCountMatchesArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMEWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAdvisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisorWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }


  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    pushSubscriptions: number
    messageParticipants: number
    sentMessages: number
    bookings: number
    matchInterests: number
    payments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs
    messageParticipants?: boolean | UserCountOutputTypeCountMessageParticipantsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    matchInterests?: boolean | UserCountOutputTypeCountMatchInterestsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchInterestWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }



  /**
   * Count Type SMECountOutputType
   */

  export type SMECountOutputType = {
    documents: number
    deals: number
    certifications: number
    workflows: number
    dueDiligences: number
    matches: number
  }

  export type SMECountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | SMECountOutputTypeCountDocumentsArgs
    deals?: boolean | SMECountOutputTypeCountDealsArgs
    certifications?: boolean | SMECountOutputTypeCountCertificationsArgs
    workflows?: boolean | SMECountOutputTypeCountWorkflowsArgs
    dueDiligences?: boolean | SMECountOutputTypeCountDueDiligencesArgs
    matches?: boolean | SMECountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes

  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMECountOutputType
     */
    select?: SMECountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceWhereInput
  }


  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }



  /**
   * Count Type InvestorCountOutputType
   */

  export type InvestorCountOutputType = {
    dealInvestments: number
    workflows: number
    leadSyndicates: number
    syndicateMemberships: number
    secondaryListings: number
    tradesAsBuyer: number
    tradesAsSeller: number
    matches: number
  }

  export type InvestorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dealInvestments?: boolean | InvestorCountOutputTypeCountDealInvestmentsArgs
    workflows?: boolean | InvestorCountOutputTypeCountWorkflowsArgs
    leadSyndicates?: boolean | InvestorCountOutputTypeCountLeadSyndicatesArgs
    syndicateMemberships?: boolean | InvestorCountOutputTypeCountSyndicateMembershipsArgs
    secondaryListings?: boolean | InvestorCountOutputTypeCountSecondaryListingsArgs
    tradesAsBuyer?: boolean | InvestorCountOutputTypeCountTradesAsBuyerArgs
    tradesAsSeller?: boolean | InvestorCountOutputTypeCountTradesAsSellerArgs
    matches?: boolean | InvestorCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorCountOutputType
     */
    select?: InvestorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountDealInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountLeadSyndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountSyndicateMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateMemberWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountSecondaryListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryListingWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountTradesAsBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryTradeWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountTradesAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryTradeWhereInput
  }


  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }



  /**
   * Count Type AdvisorCountOutputType
   */

  export type AdvisorCountOutputType = {
    certifications: number
    workflows: number
    dueDiligences: number
    services: number
    bookings: number
  }

  export type AdvisorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certifications?: boolean | AdvisorCountOutputTypeCountCertificationsArgs
    workflows?: boolean | AdvisorCountOutputTypeCountWorkflowsArgs
    dueDiligences?: boolean | AdvisorCountOutputTypeCountDueDiligencesArgs
    services?: boolean | AdvisorCountOutputTypeCountServicesArgs
    bookings?: boolean | AdvisorCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes

  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisorCountOutputType
     */
    select?: AdvisorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountDueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceWhereInput
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisoryServiceWhereInput
  }


  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }



  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    investors: number
    documents: number
    workflows: number
    syndicates: number
    conversations: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investors?: boolean | DealCountOutputTypeCountInvestorsArgs
    documents?: boolean | DealCountOutputTypeCountDocumentsArgs
    workflows?: boolean | DealCountOutputTypeCountWorkflowsArgs
    syndicates?: boolean | DealCountOutputTypeCountSyndicatesArgs
    conversations?: boolean | DealCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountSyndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateWhereInput
  }


  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }



  /**
   * Count Type DealInvestorCountOutputType
   */

  export type DealInvestorCountOutputType = {
    secondaryListings: number
    payments: number
  }

  export type DealInvestorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    secondaryListings?: boolean | DealInvestorCountOutputTypeCountSecondaryListingsArgs
    payments?: boolean | DealInvestorCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * DealInvestorCountOutputType without action
   */
  export type DealInvestorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestorCountOutputType
     */
    select?: DealInvestorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DealInvestorCountOutputType without action
   */
  export type DealInvestorCountOutputTypeCountSecondaryListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryListingWhereInput
  }


  /**
   * DealInvestorCountOutputType without action
   */
  export type DealInvestorCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }



  /**
   * Count Type SyndicateCountOutputType
   */

  export type SyndicateCountOutputType = {
    members: number
  }

  export type SyndicateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | SyndicateCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes

  /**
   * SyndicateCountOutputType without action
   */
  export type SyndicateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateCountOutputType
     */
    select?: SyndicateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SyndicateCountOutputType without action
   */
  export type SyndicateCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateMemberWhereInput
  }



  /**
   * Count Type CommunityPostCountOutputType
   */

  export type CommunityPostCountOutputType = {
    comments: number
  }

  export type CommunityPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | CommunityPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPostCountOutputType
     */
    select?: CommunityPostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type SecondaryListingCountOutputType
   */

  export type SecondaryListingCountOutputType = {
    trades: number
  }

  export type SecondaryListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trades?: boolean | SecondaryListingCountOutputTypeCountTradesArgs
  }

  // Custom InputTypes

  /**
   * SecondaryListingCountOutputType without action
   */
  export type SecondaryListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListingCountOutputType
     */
    select?: SecondaryListingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SecondaryListingCountOutputType without action
   */
  export type SecondaryListingCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryTradeWhereInput
  }



  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    participants: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }



  /**
   * Count Type AdvisoryServiceCountOutputType
   */

  export type AdvisoryServiceCountOutputType = {
    bookings: number
  }

  export type AdvisoryServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | AdvisoryServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes

  /**
   * AdvisoryServiceCountOutputType without action
   */
  export type AdvisoryServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryServiceCountOutputType
     */
    select?: AdvisoryServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdvisoryServiceCountOutputType without action
   */
  export type AdvisoryServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }



  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payments: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }



  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    interests: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | MatchCountOutputTypeCountInterestsArgs
  }

  // Custom InputTypes

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchInterestWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    smes?: boolean | Tenant$smesArgs<ExtArgs>
    investors?: boolean | Tenant$investorsArgs<ExtArgs>
    advisors?: boolean | Tenant$advisorsArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    workflows?: boolean | Tenant$workflowsArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    pushSubscriptions?: boolean | Tenant$pushSubscriptionsArgs<ExtArgs>
    conversations?: boolean | Tenant$conversationsArgs<ExtArgs>
    matches?: boolean | Tenant$matchesArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    smes?: boolean | Tenant$smesArgs<ExtArgs>
    investors?: boolean | Tenant$investorsArgs<ExtArgs>
    advisors?: boolean | Tenant$advisorsArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    workflows?: boolean | Tenant$workflowsArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    pushSubscriptions?: boolean | Tenant$pushSubscriptionsArgs<ExtArgs>
    conversations?: boolean | Tenant$conversationsArgs<ExtArgs>
    matches?: boolean | Tenant$matchesArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      smes: Prisma.$SMEPayload<ExtArgs>[]
      investors: Prisma.$InvestorPayload<ExtArgs>[]
      advisors: Prisma.$AdvisorPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }


  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TenantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TenantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TenantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
    **/
    create<T extends TenantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TenantCreateArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tenants.
     *     @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     *     @example
     *     // Create many Tenants
     *     const tenant = await prisma.tenant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TenantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
    **/
    delete<T extends TenantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TenantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TenantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TenantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
    **/
    upsert<T extends TenantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>
    ): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    smes<T extends Tenant$smesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$smesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findMany'> | Null>;

    investors<T extends Tenant$investorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findMany'> | Null>;

    advisors<T extends Tenant$advisorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$advisorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findMany'> | Null>;

    deals<T extends Tenant$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Tenant$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    documents<T extends Tenant$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    pushSubscriptions<T extends Tenant$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations<T extends Tenant$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'> | Null>;

    matches<T extends Tenant$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findMany'> | Null>;

    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }


  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }


  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }


  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }


  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }


  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }


  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }


  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }


  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Tenant.smes
   */
  export type Tenant$smesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    cursor?: SMEWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * Tenant.investors
   */
  export type Tenant$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    cursor?: InvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Tenant.advisors
   */
  export type Tenant$advisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    cursor?: AdvisorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Tenant.deals
   */
  export type Tenant$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Tenant.workflows
   */
  export type Tenant$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Tenant.documents
   */
  export type Tenant$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Tenant.pushSubscriptions
   */
  export type Tenant$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }


  /**
   * Tenant.conversations
   */
  export type Tenant$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Tenant.matches
   */
  export type Tenant$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }


  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TenantInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: $Enums.Language | null
    did: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: $Enums.Language | null
    did: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    status: number
    language: number
    did: number
    resetToken: number
    resetTokenExpiry: number
    twoFactorSecret: number
    twoFactorEnabled: number
    twoFactorBackupCodes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    resetToken?: true
    resetTokenExpiry?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    resetToken?: true
    resetTokenExpiry?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    resetToken?: true
    resetTokenExpiry?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorBackupCodes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    language: $Enums.Language
    did: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean
    twoFactorBackupCodes: string[]
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | User$smeArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    advisor?: boolean | User$advisorArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    messageParticipants?: boolean | User$messageParticipantsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    matchInterests?: boolean | User$matchInterestsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | User$smeArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    advisor?: boolean | User$advisorArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    messageParticipants?: boolean | User$messageParticipantsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    matchInterests?: boolean | User$matchInterestsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
      messageParticipants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      matchInterests: Prisma.$MatchInterestPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      language: $Enums.Language
      did: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      twoFactorSecret: string | null
      twoFactorEnabled: boolean
      twoFactorBackupCodes: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends User$smeArgs<ExtArgs> = {}>(args?: Subset<T, User$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    investor<T extends User$investorArgs<ExtArgs> = {}>(args?: Subset<T, User$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    advisor<T extends User$advisorArgs<ExtArgs> = {}>(args?: Subset<T, User$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    messageParticipants<T extends User$messageParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findMany'> | Null>;

    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findMany'> | Null>;

    matchInterests<T extends User$matchInterestsArgs<ExtArgs> = {}>(args?: Subset<T, User$matchInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findMany'> | Null>;

    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly language: FieldRef<"User", 'Language'>
    readonly did: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'String[]'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.sme
   */
  export type User$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }


  /**
   * User.investor
   */
  export type User$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }


  /**
   * User.advisor
   */
  export type User$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }


  /**
   * User.messageParticipants
   */
  export type User$messageParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }


  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }


  /**
   * User.matchInterests
   */
  export type User$matchInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    where?: MatchInterestWhereInput
    orderBy?: MatchInterestOrderByWithRelationInput | MatchInterestOrderByWithRelationInput[]
    cursor?: MatchInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchInterestScalarFieldEnum | MatchInterestScalarFieldEnum[]
  }


  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model SME
   */

  export type AggregateSME = {
    _count: SMECountAggregateOutputType | null
    _avg: SMEAvgAggregateOutputType | null
    _sum: SMESumAggregateOutputType | null
    _min: SMEMinAggregateOutputType | null
    _max: SMEMaxAggregateOutputType | null
  }

  export type SMEAvgAggregateOutputType = {
    fundingRequired: number | null
    score: number | null
  }

  export type SMESumAggregateOutputType = {
    fundingRequired: number | null
    score: number | null
  }

  export type SMEMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    sector: string | null
    stage: $Enums.SMEStage | null
    fundingRequired: number | null
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean | null
    certificationDate: Date | null
    status: $Enums.SMEStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SMEMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    sector: string | null
    stage: $Enums.SMEStage | null
    fundingRequired: number | null
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean | null
    certificationDate: Date | null
    status: $Enums.SMEStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SMECountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    sector: number
    stage: number
    fundingRequired: number
    description: number
    website: number
    location: number
    score: number
    certified: number
    certificationDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SMEAvgAggregateInputType = {
    fundingRequired?: true
    score?: true
  }

  export type SMESumAggregateInputType = {
    fundingRequired?: true
    score?: true
  }

  export type SMEMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SMEMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SMECountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SMEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SME to aggregate.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMES
    **/
    _count?: true | SMECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SMEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SMESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMEMaxAggregateInputType
  }

  export type GetSMEAggregateType<T extends SMEAggregateArgs> = {
        [P in keyof T & keyof AggregateSME]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSME[P]>
      : GetScalarType<T[P], AggregateSME[P]>
  }




  export type SMEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMEWhereInput
    orderBy?: SMEOrderByWithAggregationInput | SMEOrderByWithAggregationInput[]
    by: SMEScalarFieldEnum[] | SMEScalarFieldEnum
    having?: SMEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMECountAggregateInputType | true
    _avg?: SMEAvgAggregateInputType
    _sum?: SMESumAggregateInputType
    _min?: SMEMinAggregateInputType
    _max?: SMEMaxAggregateInputType
  }

  export type SMEGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean
    certificationDate: Date | null
    status: $Enums.SMEStatus
    createdAt: Date
    updatedAt: Date
    _count: SMECountAggregateOutputType | null
    _avg: SMEAvgAggregateOutputType | null
    _sum: SMESumAggregateOutputType | null
    _min: SMEMinAggregateOutputType | null
    _max: SMEMaxAggregateOutputType | null
  }

  type GetSMEGroupByPayload<T extends SMEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMEGroupByOutputType[P]>
            : GetScalarType<T[P], SMEGroupByOutputType[P]>
        }
      >
    >


  export type SMESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | SME$documentsArgs<ExtArgs>
    deals?: boolean | SME$dealsArgs<ExtArgs>
    certifications?: boolean | SME$certificationsArgs<ExtArgs>
    workflows?: boolean | SME$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | SME$dueDiligencesArgs<ExtArgs>
    matches?: boolean | SME$matchesArgs<ExtArgs>
    _count?: boolean | SMECountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sME"]>

  export type SMESelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SMEInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | SME$documentsArgs<ExtArgs>
    deals?: boolean | SME$dealsArgs<ExtArgs>
    certifications?: boolean | SME$certificationsArgs<ExtArgs>
    workflows?: boolean | SME$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | SME$dueDiligencesArgs<ExtArgs>
    matches?: boolean | SME$matchesArgs<ExtArgs>
    _count?: boolean | SMECountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SMEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SME"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      dueDiligences: Prisma.$DueDiligencePayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      sector: string
      stage: $Enums.SMEStage
      fundingRequired: number
      description: string | null
      website: string | null
      location: string | null
      score: number | null
      certified: boolean
      certificationDate: Date | null
      status: $Enums.SMEStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sME"]>
    composites: {}
  }


  type SMEGetPayload<S extends boolean | null | undefined | SMEDefaultArgs> = $Result.GetResult<Prisma.$SMEPayload, S>

  type SMECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SMEFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SMECountAggregateInputType | true
    }

  export interface SMEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SME'], meta: { name: 'SME' } }
    /**
     * Find zero or one SME that matches the filter.
     * @param {SMEFindUniqueArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SMEFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SMEFindUniqueArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SME that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SMEFindUniqueOrThrowArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SMEFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SME that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindFirstArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SMEFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindFirstArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SME that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindFirstOrThrowArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SMEFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SMES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMES
     * const sMES = await prisma.sME.findMany()
     * 
     * // Get first 10 SMES
     * const sMES = await prisma.sME.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMEWithIdOnly = await prisma.sME.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SMEFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SME.
     * @param {SMECreateArgs} args - Arguments to create a SME.
     * @example
     * // Create one SME
     * const SME = await prisma.sME.create({
     *   data: {
     *     // ... data to create a SME
     *   }
     * })
     * 
    **/
    create<T extends SMECreateArgs<ExtArgs>>(
      args: SelectSubset<T, SMECreateArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SMES.
     *     @param {SMECreateManyArgs} args - Arguments to create many SMES.
     *     @example
     *     // Create many SMES
     *     const sME = await prisma.sME.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SMECreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SMECreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SME.
     * @param {SMEDeleteArgs} args - Arguments to delete one SME.
     * @example
     * // Delete one SME
     * const SME = await prisma.sME.delete({
     *   where: {
     *     // ... filter to delete one SME
     *   }
     * })
     * 
    **/
    delete<T extends SMEDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SMEDeleteArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SME.
     * @param {SMEUpdateArgs} args - Arguments to update one SME.
     * @example
     * // Update one SME
     * const sME = await prisma.sME.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SMEUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SMEUpdateArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SMES.
     * @param {SMEDeleteManyArgs} args - Arguments to filter SMES to delete.
     * @example
     * // Delete a few SMES
     * const { count } = await prisma.sME.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SMEDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SMEDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMES
     * const sME = await prisma.sME.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SMEUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SMEUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SME.
     * @param {SMEUpsertArgs} args - Arguments to update or create a SME.
     * @example
     * // Update or create a SME
     * const sME = await prisma.sME.upsert({
     *   create: {
     *     // ... data to create a SME
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SME we want to update
     *   }
     * })
    **/
    upsert<T extends SMEUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SMEUpsertArgs<ExtArgs>>
    ): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMECountArgs} args - Arguments to filter SMES to count.
     * @example
     * // Count the number of SMES
     * const count = await prisma.sME.count({
     *   where: {
     *     // ... the filter for the SMES we want to count
     *   }
     * })
    **/
    count<T extends SMECountArgs>(
      args?: Subset<T, SMECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMEAggregateArgs>(args: Subset<T, SMEAggregateArgs>): Prisma.PrismaPromise<GetSMEAggregateType<T>>

    /**
     * Group by SME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMEGroupByArgs['orderBy'] }
        : { orderBy?: SMEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SME model
   */
  readonly fields: SMEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SME.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    documents<T extends SME$documentsArgs<ExtArgs> = {}>(args?: Subset<T, SME$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    deals<T extends SME$dealsArgs<ExtArgs> = {}>(args?: Subset<T, SME$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findMany'> | Null>;

    certifications<T extends SME$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, SME$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends SME$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, SME$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    dueDiligences<T extends SME$dueDiligencesArgs<ExtArgs> = {}>(args?: Subset<T, SME$dueDiligencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findMany'> | Null>;

    matches<T extends SME$matchesArgs<ExtArgs> = {}>(args?: Subset<T, SME$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SME model
   */ 
  interface SMEFieldRefs {
    readonly id: FieldRef<"SME", 'String'>
    readonly tenantId: FieldRef<"SME", 'String'>
    readonly userId: FieldRef<"SME", 'String'>
    readonly name: FieldRef<"SME", 'String'>
    readonly sector: FieldRef<"SME", 'String'>
    readonly stage: FieldRef<"SME", 'SMEStage'>
    readonly fundingRequired: FieldRef<"SME", 'Float'>
    readonly description: FieldRef<"SME", 'String'>
    readonly website: FieldRef<"SME", 'String'>
    readonly location: FieldRef<"SME", 'String'>
    readonly score: FieldRef<"SME", 'Float'>
    readonly certified: FieldRef<"SME", 'Boolean'>
    readonly certificationDate: FieldRef<"SME", 'DateTime'>
    readonly status: FieldRef<"SME", 'SMEStatus'>
    readonly createdAt: FieldRef<"SME", 'DateTime'>
    readonly updatedAt: FieldRef<"SME", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SME findUnique
   */
  export type SMEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME findUniqueOrThrow
   */
  export type SMEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME findFirst
   */
  export type SMEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMES.
     */
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * SME findFirstOrThrow
   */
  export type SMEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMES.
     */
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * SME findMany
   */
  export type SMEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SMES to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }


  /**
   * SME create
   */
  export type SMECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The data needed to create a SME.
     */
    data: XOR<SMECreateInput, SMEUncheckedCreateInput>
  }


  /**
   * SME createMany
   */
  export type SMECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMES.
     */
    data: SMECreateManyInput | SMECreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SME update
   */
  export type SMEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The data needed to update a SME.
     */
    data: XOR<SMEUpdateInput, SMEUncheckedUpdateInput>
    /**
     * Choose, which SME to update.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME updateMany
   */
  export type SMEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMES.
     */
    data: XOR<SMEUpdateManyMutationInput, SMEUncheckedUpdateManyInput>
    /**
     * Filter which SMES to update
     */
    where?: SMEWhereInput
  }


  /**
   * SME upsert
   */
  export type SMEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The filter to search for the SME to update in case it exists.
     */
    where: SMEWhereUniqueInput
    /**
     * In case the SME found by the `where` argument doesn't exist, create a new SME with this data.
     */
    create: XOR<SMECreateInput, SMEUncheckedCreateInput>
    /**
     * In case the SME was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMEUpdateInput, SMEUncheckedUpdateInput>
  }


  /**
   * SME delete
   */
  export type SMEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter which SME to delete.
     */
    where: SMEWhereUniqueInput
  }


  /**
   * SME deleteMany
   */
  export type SMEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMES to delete
     */
    where?: SMEWhereInput
  }


  /**
   * SME.documents
   */
  export type SME$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * SME.deals
   */
  export type SME$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * SME.certifications
   */
  export type SME$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * SME.workflows
   */
  export type SME$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * SME.dueDiligences
   */
  export type SME$dueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    where?: DueDiligenceWhereInput
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    cursor?: DueDiligenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * SME.matches
   */
  export type SME$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }


  /**
   * SME without action
   */
  export type SMEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
  }



  /**
   * Model Investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    type: $Enums.InvestorType | null
    kycStatus: $Enums.KYCStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    type: $Enums.InvestorType | null
    kycStatus: $Enums.KYCStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    type: number
    kycStatus: number
    preferences: number
    portfolio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    preferences?: true
    portfolio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investor to aggregate.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type InvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithAggregationInput | InvestorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: InvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus: $Enums.KYCStatus
    preferences: JsonValue
    portfolio: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: InvestorCountAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends InvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type InvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestments?: boolean | Investor$dealInvestmentsArgs<ExtArgs>
    workflows?: boolean | Investor$workflowsArgs<ExtArgs>
    leadSyndicates?: boolean | Investor$leadSyndicatesArgs<ExtArgs>
    syndicateMemberships?: boolean | Investor$syndicateMembershipsArgs<ExtArgs>
    secondaryListings?: boolean | Investor$secondaryListingsArgs<ExtArgs>
    tradesAsBuyer?: boolean | Investor$tradesAsBuyerArgs<ExtArgs>
    tradesAsSeller?: boolean | Investor$tradesAsSellerArgs<ExtArgs>
    matches?: boolean | Investor$matchesArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestments?: boolean | Investor$dealInvestmentsArgs<ExtArgs>
    workflows?: boolean | Investor$workflowsArgs<ExtArgs>
    leadSyndicates?: boolean | Investor$leadSyndicatesArgs<ExtArgs>
    syndicateMemberships?: boolean | Investor$syndicateMembershipsArgs<ExtArgs>
    secondaryListings?: boolean | Investor$secondaryListingsArgs<ExtArgs>
    tradesAsBuyer?: boolean | Investor$tradesAsBuyerArgs<ExtArgs>
    tradesAsSeller?: boolean | Investor$tradesAsSellerArgs<ExtArgs>
    matches?: boolean | Investor$matchesArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      dealInvestments: Prisma.$DealInvestorPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      leadSyndicates: Prisma.$SyndicatePayload<ExtArgs>[]
      syndicateMemberships: Prisma.$SyndicateMemberPayload<ExtArgs>[]
      secondaryListings: Prisma.$SecondaryListingPayload<ExtArgs>[]
      tradesAsBuyer: Prisma.$SecondaryTradePayload<ExtArgs>[]
      tradesAsSeller: Prisma.$SecondaryTradePayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      type: $Enums.InvestorType
      kycStatus: $Enums.KYCStatus
      preferences: Prisma.JsonValue
      portfolio: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }


  type InvestorGetPayload<S extends boolean | null | undefined | InvestorDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayload, S>

  type InvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvestorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface InvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investor'], meta: { name: 'Investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {InvestorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvestorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorFindUniqueArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Investor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvestorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvestorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvestorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindFirstArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvestorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvestorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Investor.
     * @param {InvestorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
    **/
    create<T extends InvestorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorCreateArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Investors.
     *     @param {InvestorCreateManyArgs} args - Arguments to create many Investors.
     *     @example
     *     // Create many Investors
     *     const investor = await prisma.investor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvestorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investor.
     * @param {InvestorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
    **/
    delete<T extends InvestorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorDeleteArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Investor.
     * @param {InvestorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvestorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorUpdateArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Investors.
     * @param {InvestorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvestorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvestorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvestorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investor.
     * @param {InvestorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
    **/
    upsert<T extends InvestorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvestorUpsertArgs<ExtArgs>>
    ): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends InvestorCountArgs>(
      args?: Subset<T, InvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investor model
   */
  readonly fields: InvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dealInvestments<T extends Investor$dealInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$dealInvestmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Investor$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    leadSyndicates<T extends Investor$leadSyndicatesArgs<ExtArgs> = {}>(args?: Subset<T, Investor$leadSyndicatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findMany'> | Null>;

    syndicateMemberships<T extends Investor$syndicateMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$syndicateMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    secondaryListings<T extends Investor$secondaryListingsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$secondaryListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    tradesAsBuyer<T extends Investor$tradesAsBuyerArgs<ExtArgs> = {}>(args?: Subset<T, Investor$tradesAsBuyerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findMany'> | Null>;

    tradesAsSeller<T extends Investor$tradesAsSellerArgs<ExtArgs> = {}>(args?: Subset<T, Investor$tradesAsSellerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findMany'> | Null>;

    matches<T extends Investor$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Investor$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Investor model
   */ 
  interface InvestorFieldRefs {
    readonly id: FieldRef<"Investor", 'String'>
    readonly tenantId: FieldRef<"Investor", 'String'>
    readonly userId: FieldRef<"Investor", 'String'>
    readonly name: FieldRef<"Investor", 'String'>
    readonly type: FieldRef<"Investor", 'InvestorType'>
    readonly kycStatus: FieldRef<"Investor", 'KYCStatus'>
    readonly preferences: FieldRef<"Investor", 'Json'>
    readonly portfolio: FieldRef<"Investor", 'Json'>
    readonly createdAt: FieldRef<"Investor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investor", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Investor findUnique
   */
  export type InvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor findUniqueOrThrow
   */
  export type InvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor findFirst
   */
  export type InvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Investor findFirstOrThrow
   */
  export type InvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Investor findMany
   */
  export type InvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investors to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }


  /**
   * Investor create
   */
  export type InvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a Investor.
     */
    data: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
  }


  /**
   * Investor createMany
   */
  export type InvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Investor update
   */
  export type InvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a Investor.
     */
    data: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
    /**
     * Choose, which Investor to update.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor updateMany
   */
  export type InvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
  }


  /**
   * Investor upsert
   */
  export type InvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the Investor to update in case it exists.
     */
    where: InvestorWhereUniqueInput
    /**
     * In case the Investor found by the `where` argument doesn't exist, create a new Investor with this data.
     */
    create: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
    /**
     * In case the Investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
  }


  /**
   * Investor delete
   */
  export type InvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter which Investor to delete.
     */
    where: InvestorWhereUniqueInput
  }


  /**
   * Investor deleteMany
   */
  export type InvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investors to delete
     */
    where?: InvestorWhereInput
  }


  /**
   * Investor.dealInvestments
   */
  export type Investor$dealInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    cursor?: DealInvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * Investor.workflows
   */
  export type Investor$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Investor.leadSyndicates
   */
  export type Investor$leadSyndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    where?: SyndicateWhereInput
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    cursor?: SyndicateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Investor.syndicateMemberships
   */
  export type Investor$syndicateMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    where?: SyndicateMemberWhereInput
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    cursor?: SyndicateMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * Investor.secondaryListings
   */
  export type Investor$secondaryListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    where?: SecondaryListingWhereInput
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    cursor?: SecondaryListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * Investor.tradesAsBuyer
   */
  export type Investor$tradesAsBuyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    where?: SecondaryTradeWhereInput
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    cursor?: SecondaryTradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * Investor.tradesAsSeller
   */
  export type Investor$tradesAsSellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    where?: SecondaryTradeWhereInput
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    cursor?: SecondaryTradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * Investor.matches
   */
  export type Investor$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }


  /**
   * Investor without action
   */
  export type InvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
  }



  /**
   * Model Advisor
   */

  export type AggregateAdvisor = {
    _count: AdvisorCountAggregateOutputType | null
    _min: AdvisorMinAggregateOutputType | null
    _max: AdvisorMaxAggregateOutputType | null
  }

  export type AdvisorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    status: $Enums.AdvisorStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    status: $Enums.AdvisorStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    specialization: number
    certificationList: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdvisorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    specialization?: true
    certificationList?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdvisorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advisor to aggregate.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advisors
    **/
    _count?: true | AdvisorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvisorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvisorMaxAggregateInputType
  }

  export type GetAdvisorAggregateType<T extends AdvisorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvisor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvisor[P]>
      : GetScalarType<T[P], AggregateAdvisor[P]>
  }




  export type AdvisorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisorWhereInput
    orderBy?: AdvisorOrderByWithAggregationInput | AdvisorOrderByWithAggregationInput[]
    by: AdvisorScalarFieldEnum[] | AdvisorScalarFieldEnum
    having?: AdvisorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvisorCountAggregateInputType | true
    _min?: AdvisorMinAggregateInputType
    _max?: AdvisorMaxAggregateInputType
  }

  export type AdvisorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    specialization: string[]
    certificationList: string[]
    status: $Enums.AdvisorStatus
    createdAt: Date
    updatedAt: Date
    _count: AdvisorCountAggregateOutputType | null
    _min: AdvisorMinAggregateOutputType | null
    _max: AdvisorMaxAggregateOutputType | null
  }

  type GetAdvisorGroupByPayload<T extends AdvisorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvisorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvisorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvisorGroupByOutputType[P]>
            : GetScalarType<T[P], AdvisorGroupByOutputType[P]>
        }
      >
    >


  export type AdvisorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    certifications?: boolean | Advisor$certificationsArgs<ExtArgs>
    workflows?: boolean | Advisor$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | Advisor$dueDiligencesArgs<ExtArgs>
    services?: boolean | Advisor$servicesArgs<ExtArgs>
    bookings?: boolean | Advisor$bookingsArgs<ExtArgs>
    _count?: boolean | AdvisorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advisor"]>

  export type AdvisorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdvisorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    certifications?: boolean | Advisor$certificationsArgs<ExtArgs>
    workflows?: boolean | Advisor$workflowsArgs<ExtArgs>
    dueDiligences?: boolean | Advisor$dueDiligencesArgs<ExtArgs>
    services?: boolean | Advisor$servicesArgs<ExtArgs>
    bookings?: boolean | Advisor$bookingsArgs<ExtArgs>
    _count?: boolean | AdvisorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdvisorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advisor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      dueDiligences: Prisma.$DueDiligencePayload<ExtArgs>[]
      services: Prisma.$AdvisoryServicePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      specialization: string[]
      certificationList: string[]
      status: $Enums.AdvisorStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["advisor"]>
    composites: {}
  }


  type AdvisorGetPayload<S extends boolean | null | undefined | AdvisorDefaultArgs> = $Result.GetResult<Prisma.$AdvisorPayload, S>

  type AdvisorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvisorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdvisorCountAggregateInputType | true
    }

  export interface AdvisorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advisor'], meta: { name: 'Advisor' } }
    /**
     * Find zero or one Advisor that matches the filter.
     * @param {AdvisorFindUniqueArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvisorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Advisor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdvisorFindUniqueOrThrowArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdvisorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Advisor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindFirstArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvisorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindFirstArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Advisor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindFirstOrThrowArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdvisorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Advisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advisors
     * const advisors = await prisma.advisor.findMany()
     * 
     * // Get first 10 Advisors
     * const advisors = await prisma.advisor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advisorWithIdOnly = await prisma.advisor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdvisorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Advisor.
     * @param {AdvisorCreateArgs} args - Arguments to create a Advisor.
     * @example
     * // Create one Advisor
     * const Advisor = await prisma.advisor.create({
     *   data: {
     *     // ... data to create a Advisor
     *   }
     * })
     * 
    **/
    create<T extends AdvisorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorCreateArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Advisors.
     *     @param {AdvisorCreateManyArgs} args - Arguments to create many Advisors.
     *     @example
     *     // Create many Advisors
     *     const advisor = await prisma.advisor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvisorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advisor.
     * @param {AdvisorDeleteArgs} args - Arguments to delete one Advisor.
     * @example
     * // Delete one Advisor
     * const Advisor = await prisma.advisor.delete({
     *   where: {
     *     // ... filter to delete one Advisor
     *   }
     * })
     * 
    **/
    delete<T extends AdvisorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorDeleteArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Advisor.
     * @param {AdvisorUpdateArgs} args - Arguments to update one Advisor.
     * @example
     * // Update one Advisor
     * const advisor = await prisma.advisor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvisorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorUpdateArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Advisors.
     * @param {AdvisorDeleteManyArgs} args - Arguments to filter Advisors to delete.
     * @example
     * // Delete a few Advisors
     * const { count } = await prisma.advisor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvisorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advisors
     * const advisor = await prisma.advisor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvisorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advisor.
     * @param {AdvisorUpsertArgs} args - Arguments to update or create a Advisor.
     * @example
     * // Update or create a Advisor
     * const advisor = await prisma.advisor.upsert({
     *   create: {
     *     // ... data to create a Advisor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advisor we want to update
     *   }
     * })
    **/
    upsert<T extends AdvisorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisorUpsertArgs<ExtArgs>>
    ): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Advisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorCountArgs} args - Arguments to filter Advisors to count.
     * @example
     * // Count the number of Advisors
     * const count = await prisma.advisor.count({
     *   where: {
     *     // ... the filter for the Advisors we want to count
     *   }
     * })
    **/
    count<T extends AdvisorCountArgs>(
      args?: Subset<T, AdvisorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvisorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvisorAggregateArgs>(args: Subset<T, AdvisorAggregateArgs>): Prisma.PrismaPromise<GetAdvisorAggregateType<T>>

    /**
     * Group by Advisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvisorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvisorGroupByArgs['orderBy'] }
        : { orderBy?: AdvisorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvisorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvisorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advisor model
   */
  readonly fields: AdvisorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advisor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvisorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    certifications<T extends Advisor$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Advisor$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    dueDiligences<T extends Advisor$dueDiligencesArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$dueDiligencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findMany'> | Null>;

    services<T extends Advisor$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findMany'> | Null>;

    bookings<T extends Advisor$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Advisor model
   */ 
  interface AdvisorFieldRefs {
    readonly id: FieldRef<"Advisor", 'String'>
    readonly tenantId: FieldRef<"Advisor", 'String'>
    readonly userId: FieldRef<"Advisor", 'String'>
    readonly name: FieldRef<"Advisor", 'String'>
    readonly specialization: FieldRef<"Advisor", 'String[]'>
    readonly certificationList: FieldRef<"Advisor", 'String[]'>
    readonly status: FieldRef<"Advisor", 'AdvisorStatus'>
    readonly createdAt: FieldRef<"Advisor", 'DateTime'>
    readonly updatedAt: FieldRef<"Advisor", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Advisor findUnique
   */
  export type AdvisorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor findUniqueOrThrow
   */
  export type AdvisorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor findFirst
   */
  export type AdvisorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advisors.
     */
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Advisor findFirstOrThrow
   */
  export type AdvisorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advisors.
     */
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Advisor findMany
   */
  export type AdvisorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisors to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }


  /**
   * Advisor create
   */
  export type AdvisorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The data needed to create a Advisor.
     */
    data: XOR<AdvisorCreateInput, AdvisorUncheckedCreateInput>
  }


  /**
   * Advisor createMany
   */
  export type AdvisorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advisors.
     */
    data: AdvisorCreateManyInput | AdvisorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Advisor update
   */
  export type AdvisorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The data needed to update a Advisor.
     */
    data: XOR<AdvisorUpdateInput, AdvisorUncheckedUpdateInput>
    /**
     * Choose, which Advisor to update.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor updateMany
   */
  export type AdvisorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advisors.
     */
    data: XOR<AdvisorUpdateManyMutationInput, AdvisorUncheckedUpdateManyInput>
    /**
     * Filter which Advisors to update
     */
    where?: AdvisorWhereInput
  }


  /**
   * Advisor upsert
   */
  export type AdvisorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The filter to search for the Advisor to update in case it exists.
     */
    where: AdvisorWhereUniqueInput
    /**
     * In case the Advisor found by the `where` argument doesn't exist, create a new Advisor with this data.
     */
    create: XOR<AdvisorCreateInput, AdvisorUncheckedCreateInput>
    /**
     * In case the Advisor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvisorUpdateInput, AdvisorUncheckedUpdateInput>
  }


  /**
   * Advisor delete
   */
  export type AdvisorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter which Advisor to delete.
     */
    where: AdvisorWhereUniqueInput
  }


  /**
   * Advisor deleteMany
   */
  export type AdvisorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advisors to delete
     */
    where?: AdvisorWhereInput
  }


  /**
   * Advisor.certifications
   */
  export type Advisor$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Advisor.workflows
   */
  export type Advisor$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Advisor.dueDiligences
   */
  export type Advisor$dueDiligencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    where?: DueDiligenceWhereInput
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    cursor?: DueDiligenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * Advisor.services
   */
  export type Advisor$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    where?: AdvisoryServiceWhereInput
    orderBy?: AdvisoryServiceOrderByWithRelationInput | AdvisoryServiceOrderByWithRelationInput[]
    cursor?: AdvisoryServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvisoryServiceScalarFieldEnum | AdvisoryServiceScalarFieldEnum[]
  }


  /**
   * Advisor.bookings
   */
  export type Advisor$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }


  /**
   * Advisor without action
   */
  export type AdvisorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
  }



  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    amount: number | null
    equity: number | null
    successFee: number | null
  }

  export type DealSumAggregateOutputType = {
    amount: number | null
    equity: number | null
    successFee: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    title: string | null
    description: string | null
    amount: number | null
    equity: number | null
    status: $Enums.DealStatus | null
    successFee: number | null
    terms: string | null
    isDocumentLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    title: string | null
    description: string | null
    amount: number | null
    equity: number | null
    status: $Enums.DealStatus | null
    successFee: number | null
    terms: string | null
    isDocumentLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    tenantId: number
    smeId: number
    title: number
    description: number
    amount: number
    equity: number
    status: number
    successFee: number
    terms: number
    isDocumentLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    amount?: true
    equity?: true
    successFee?: true
  }

  export type DealSumAggregateInputType = {
    amount?: true
    equity?: true
    successFee?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    terms?: true
    isDocumentLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    terms?: true
    isDocumentLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    terms?: true
    isDocumentLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    tenantId: string
    smeId: string
    title: string
    description: string | null
    amount: number
    equity: number | null
    status: $Enums.DealStatus
    successFee: number | null
    terms: string | null
    isDocumentLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    terms?: boolean
    isDocumentLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investors?: boolean | Deal$investorsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    workflows?: boolean | Deal$workflowsArgs<ExtArgs>
    syndicates?: boolean | Deal$syndicatesArgs<ExtArgs>
    conversations?: boolean | Deal$conversationsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    terms?: boolean
    isDocumentLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investors?: boolean | Deal$investorsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    workflows?: boolean | Deal$workflowsArgs<ExtArgs>
    syndicates?: boolean | Deal$syndicatesArgs<ExtArgs>
    conversations?: boolean | Deal$conversationsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs>
      investors: Prisma.$DealInvestorPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      syndicates: Prisma.$SyndicatePayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      smeId: string
      title: string
      description: string | null
      amount: number
      equity: number | null
      status: $Enums.DealStatus
      successFee: number | null
      terms: string | null
      isDocumentLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }


  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DealFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Deal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DealFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DealFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
    **/
    create<T extends DealCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DealCreateArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Deals.
     *     @param {DealCreateManyArgs} args - Arguments to create many Deals.
     *     @example
     *     // Create many Deals
     *     const deal = await prisma.deal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DealCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
    **/
    delete<T extends DealDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DealDeleteArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DealUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DealUpdateArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DealDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DealUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
    **/
    upsert<T extends DealUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DealUpsertArgs<ExtArgs>>
    ): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investors<T extends Deal$investorsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findMany'> | Null>;

    documents<T extends Deal$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    workflows<T extends Deal$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'> | Null>;

    syndicates<T extends Deal$syndicatesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$syndicatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations<T extends Deal$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Deal model
   */ 
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly tenantId: FieldRef<"Deal", 'String'>
    readonly smeId: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly description: FieldRef<"Deal", 'String'>
    readonly amount: FieldRef<"Deal", 'Float'>
    readonly equity: FieldRef<"Deal", 'Float'>
    readonly status: FieldRef<"Deal", 'DealStatus'>
    readonly successFee: FieldRef<"Deal", 'Float'>
    readonly terms: FieldRef<"Deal", 'String'>
    readonly isDocumentLocked: FieldRef<"Deal", 'Boolean'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }


  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }


  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
  }


  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }


  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }


  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
  }


  /**
   * Deal.investors
   */
  export type Deal$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    cursor?: DealInvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * Deal.documents
   */
  export type Deal$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Deal.workflows
   */
  export type Deal$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Deal.syndicates
   */
  export type Deal$syndicatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    where?: SyndicateWhereInput
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    cursor?: SyndicateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Deal.conversations
   */
  export type Deal$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
  }



  /**
   * Model DealInvestor
   */

  export type AggregateDealInvestor = {
    _count: DealInvestorCountAggregateOutputType | null
    _avg: DealInvestorAvgAggregateOutputType | null
    _sum: DealInvestorSumAggregateOutputType | null
    _min: DealInvestorMinAggregateOutputType | null
    _max: DealInvestorMaxAggregateOutputType | null
  }

  export type DealInvestorAvgAggregateOutputType = {
    amount: number | null
  }

  export type DealInvestorSumAggregateOutputType = {
    amount: number | null
  }

  export type DealInvestorMinAggregateOutputType = {
    id: string | null
    dealId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.InvestmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealInvestorMaxAggregateOutputType = {
    id: string | null
    dealId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.InvestmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealInvestorCountAggregateOutputType = {
    id: number
    dealId: number
    investorId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealInvestorAvgAggregateInputType = {
    amount?: true
  }

  export type DealInvestorSumAggregateInputType = {
    amount?: true
  }

  export type DealInvestorMinAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealInvestorMaxAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealInvestorCountAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealInvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealInvestor to aggregate.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DealInvestors
    **/
    _count?: true | DealInvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealInvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealInvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealInvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealInvestorMaxAggregateInputType
  }

  export type GetDealInvestorAggregateType<T extends DealInvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateDealInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealInvestor[P]>
      : GetScalarType<T[P], AggregateDealInvestor[P]>
  }




  export type DealInvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithAggregationInput | DealInvestorOrderByWithAggregationInput[]
    by: DealInvestorScalarFieldEnum[] | DealInvestorScalarFieldEnum
    having?: DealInvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealInvestorCountAggregateInputType | true
    _avg?: DealInvestorAvgAggregateInputType
    _sum?: DealInvestorSumAggregateInputType
    _min?: DealInvestorMinAggregateInputType
    _max?: DealInvestorMaxAggregateInputType
  }

  export type DealInvestorGroupByOutputType = {
    id: string
    dealId: string
    investorId: string
    amount: number
    status: $Enums.InvestmentStatus
    createdAt: Date
    updatedAt: Date
    _count: DealInvestorCountAggregateOutputType | null
    _avg: DealInvestorAvgAggregateOutputType | null
    _sum: DealInvestorSumAggregateOutputType | null
    _min: DealInvestorMinAggregateOutputType | null
    _max: DealInvestorMaxAggregateOutputType | null
  }

  type GetDealInvestorGroupByPayload<T extends DealInvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealInvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealInvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealInvestorGroupByOutputType[P]>
            : GetScalarType<T[P], DealInvestorGroupByOutputType[P]>
        }
      >
    >


  export type DealInvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    secondaryListings?: boolean | DealInvestor$secondaryListingsArgs<ExtArgs>
    payments?: boolean | DealInvestor$paymentsArgs<ExtArgs>
    _count?: boolean | DealInvestorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealInvestor"]>

  export type DealInvestorSelectScalar = {
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealInvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    secondaryListings?: boolean | DealInvestor$secondaryListingsArgs<ExtArgs>
    payments?: boolean | DealInvestor$paymentsArgs<ExtArgs>
    _count?: boolean | DealInvestorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DealInvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DealInvestor"
    objects: {
      deal: Prisma.$DealPayload<ExtArgs>
      investor: Prisma.$InvestorPayload<ExtArgs>
      secondaryListings: Prisma.$SecondaryListingPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dealId: string
      investorId: string
      amount: number
      status: $Enums.InvestmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dealInvestor"]>
    composites: {}
  }


  type DealInvestorGetPayload<S extends boolean | null | undefined | DealInvestorDefaultArgs> = $Result.GetResult<Prisma.$DealInvestorPayload, S>

  type DealInvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealInvestorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DealInvestorCountAggregateInputType | true
    }

  export interface DealInvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DealInvestor'], meta: { name: 'DealInvestor' } }
    /**
     * Find zero or one DealInvestor that matches the filter.
     * @param {DealInvestorFindUniqueArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DealInvestorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorFindUniqueArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DealInvestor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DealInvestorFindUniqueOrThrowArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DealInvestorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DealInvestor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindFirstArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DealInvestorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindFirstArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DealInvestor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindFirstOrThrowArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DealInvestorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DealInvestors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DealInvestors
     * const dealInvestors = await prisma.dealInvestor.findMany()
     * 
     * // Get first 10 DealInvestors
     * const dealInvestors = await prisma.dealInvestor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealInvestorWithIdOnly = await prisma.dealInvestor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DealInvestorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DealInvestor.
     * @param {DealInvestorCreateArgs} args - Arguments to create a DealInvestor.
     * @example
     * // Create one DealInvestor
     * const DealInvestor = await prisma.dealInvestor.create({
     *   data: {
     *     // ... data to create a DealInvestor
     *   }
     * })
     * 
    **/
    create<T extends DealInvestorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorCreateArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DealInvestors.
     *     @param {DealInvestorCreateManyArgs} args - Arguments to create many DealInvestors.
     *     @example
     *     // Create many DealInvestors
     *     const dealInvestor = await prisma.dealInvestor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DealInvestorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DealInvestor.
     * @param {DealInvestorDeleteArgs} args - Arguments to delete one DealInvestor.
     * @example
     * // Delete one DealInvestor
     * const DealInvestor = await prisma.dealInvestor.delete({
     *   where: {
     *     // ... filter to delete one DealInvestor
     *   }
     * })
     * 
    **/
    delete<T extends DealInvestorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorDeleteArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DealInvestor.
     * @param {DealInvestorUpdateArgs} args - Arguments to update one DealInvestor.
     * @example
     * // Update one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DealInvestorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorUpdateArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DealInvestors.
     * @param {DealInvestorDeleteManyArgs} args - Arguments to filter DealInvestors to delete.
     * @example
     * // Delete a few DealInvestors
     * const { count } = await prisma.dealInvestor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DealInvestorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DealInvestorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealInvestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DealInvestors
     * const dealInvestor = await prisma.dealInvestor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DealInvestorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DealInvestor.
     * @param {DealInvestorUpsertArgs} args - Arguments to update or create a DealInvestor.
     * @example
     * // Update or create a DealInvestor
     * const dealInvestor = await prisma.dealInvestor.upsert({
     *   create: {
     *     // ... data to create a DealInvestor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DealInvestor we want to update
     *   }
     * })
    **/
    upsert<T extends DealInvestorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DealInvestorUpsertArgs<ExtArgs>>
    ): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DealInvestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorCountArgs} args - Arguments to filter DealInvestors to count.
     * @example
     * // Count the number of DealInvestors
     * const count = await prisma.dealInvestor.count({
     *   where: {
     *     // ... the filter for the DealInvestors we want to count
     *   }
     * })
    **/
    count<T extends DealInvestorCountArgs>(
      args?: Subset<T, DealInvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealInvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DealInvestor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealInvestorAggregateArgs>(args: Subset<T, DealInvestorAggregateArgs>): Prisma.PrismaPromise<GetDealInvestorAggregateType<T>>

    /**
     * Group by DealInvestor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealInvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealInvestorGroupByArgs['orderBy'] }
        : { orderBy?: DealInvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealInvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DealInvestor model
   */
  readonly fields: DealInvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DealInvestor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealInvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    deal<T extends DealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealDefaultArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    secondaryListings<T extends DealInvestor$secondaryListingsArgs<ExtArgs> = {}>(args?: Subset<T, DealInvestor$secondaryListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    payments<T extends DealInvestor$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, DealInvestor$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DealInvestor model
   */ 
  interface DealInvestorFieldRefs {
    readonly id: FieldRef<"DealInvestor", 'String'>
    readonly dealId: FieldRef<"DealInvestor", 'String'>
    readonly investorId: FieldRef<"DealInvestor", 'String'>
    readonly amount: FieldRef<"DealInvestor", 'Float'>
    readonly status: FieldRef<"DealInvestor", 'InvestmentStatus'>
    readonly createdAt: FieldRef<"DealInvestor", 'DateTime'>
    readonly updatedAt: FieldRef<"DealInvestor", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DealInvestor findUnique
   */
  export type DealInvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor findUniqueOrThrow
   */
  export type DealInvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor findFirst
   */
  export type DealInvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealInvestors.
     */
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * DealInvestor findFirstOrThrow
   */
  export type DealInvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealInvestors.
     */
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * DealInvestor findMany
   */
  export type DealInvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestors to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }


  /**
   * DealInvestor create
   */
  export type DealInvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a DealInvestor.
     */
    data: XOR<DealInvestorCreateInput, DealInvestorUncheckedCreateInput>
  }


  /**
   * DealInvestor createMany
   */
  export type DealInvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DealInvestors.
     */
    data: DealInvestorCreateManyInput | DealInvestorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DealInvestor update
   */
  export type DealInvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a DealInvestor.
     */
    data: XOR<DealInvestorUpdateInput, DealInvestorUncheckedUpdateInput>
    /**
     * Choose, which DealInvestor to update.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor updateMany
   */
  export type DealInvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DealInvestors.
     */
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyInput>
    /**
     * Filter which DealInvestors to update
     */
    where?: DealInvestorWhereInput
  }


  /**
   * DealInvestor upsert
   */
  export type DealInvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the DealInvestor to update in case it exists.
     */
    where: DealInvestorWhereUniqueInput
    /**
     * In case the DealInvestor found by the `where` argument doesn't exist, create a new DealInvestor with this data.
     */
    create: XOR<DealInvestorCreateInput, DealInvestorUncheckedCreateInput>
    /**
     * In case the DealInvestor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealInvestorUpdateInput, DealInvestorUncheckedUpdateInput>
  }


  /**
   * DealInvestor delete
   */
  export type DealInvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter which DealInvestor to delete.
     */
    where: DealInvestorWhereUniqueInput
  }


  /**
   * DealInvestor deleteMany
   */
  export type DealInvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealInvestors to delete
     */
    where?: DealInvestorWhereInput
  }


  /**
   * DealInvestor.secondaryListings
   */
  export type DealInvestor$secondaryListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    where?: SecondaryListingWhereInput
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    cursor?: SecondaryListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * DealInvestor.payments
   */
  export type DealInvestor$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * DealInvestor without action
   */
  export type DealInvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.DocumentType | null
    url: string | null
    size: number | null
    mimeType: string | null
    smeId: string | null
    dealId: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.DocumentType | null
    url: string | null
    size: number | null
    mimeType: string | null
    smeId: string | null
    dealId: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    type: number
    url: number
    size: number
    mimeType: number
    smeId: number
    dealId: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId: string | null
    dealId: string | null
    uploadedBy: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      type: $Enums.DocumentType
      url: string
      size: number
      mimeType: string
      smeId: string | null
      dealId: string | null
      uploadedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends Document$smeArgs<ExtArgs> = {}>(args?: Subset<T, Document$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    deal<T extends Document$dealArgs<ExtArgs> = {}>(args?: Subset<T, Document$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly tenantId: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly url: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly smeId: FieldRef<"Document", 'String'>
    readonly dealId: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.sme
   */
  export type Document$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }


  /**
   * Document.deal
   */
  export type Document$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _avg: CertificationAvgAggregateOutputType | null
    _sum: CertificationSumAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationAvgAggregateOutputType = {
    score: number | null
  }

  export type CertificationSumAggregateOutputType = {
    score: number | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    status: $Enums.CertificationStatus | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    status: $Enums.CertificationStatus | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    smeId: number
    advisorId: number
    status: number
    score: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificationAvgAggregateInputType = {
    score?: true
  }

  export type CertificationSumAggregateInputType = {
    score?: true
  }

  export type CertificationMinAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _avg?: CertificationAvgAggregateInputType
    _sum?: CertificationSumAggregateInputType
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    smeId: string
    advisorId: string
    status: $Enums.CertificationStatus
    score: number | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificationCountAggregateOutputType | null
    _avg: CertificationAvgAggregateOutputType | null
    _sum: CertificationSumAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }


  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      sme: Prisma.$SMEPayload<ExtArgs>
      advisor: Prisma.$AdvisorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      smeId: string
      advisorId: string
      status: $Enums.CertificationStatus
      score: number | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }


  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CertificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Certification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CertificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CertificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
    **/
    create<T extends CertificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Certifications.
     *     @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     *     @example
     *     // Create many Certifications
     *     const certification = await prisma.certification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CertificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
    **/
    delete<T extends CertificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CertificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CertificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CertificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
    **/
    upsert<T extends CertificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>
    ): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    advisor<T extends AdvisorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvisorDefaultArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Certification model
   */ 
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly smeId: FieldRef<"Certification", 'String'>
    readonly advisorId: FieldRef<"Certification", 'String'>
    readonly status: FieldRef<"Certification", 'CertificationStatus'>
    readonly score: FieldRef<"Certification", 'Float'>
    readonly comments: FieldRef<"Certification", 'String'>
    readonly createdAt: FieldRef<"Certification", 'DateTime'>
    readonly updatedAt: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }


  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }


  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
  }


  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }


  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }


  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
  }


  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CertificationInclude<ExtArgs> | null
  }



  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.WorkflowType | null
    status: $Enums.WorkflowStatus | null
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.WorkflowType | null
    status: $Enums.WorkflowStatus | null
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    status: number
    data: number
    smeId: number
    investorId: number
    advisorId: number
    dealId: number
    didWorkflowId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    data?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.WorkflowType
    status: $Enums.WorkflowStatus
    data: JsonValue
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }


  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.WorkflowType
      status: $Enums.WorkflowStatus
      data: Prisma.JsonValue
      smeId: string | null
      investorId: string | null
      advisorId: string | null
      dealId: string | null
      didWorkflowId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }


  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkflowFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Workflow that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkflowFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkflowFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
    **/
    create<T extends WorkflowCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Workflows.
     *     @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     *     @example
     *     // Create many Workflows
     *     const workflow = await prisma.workflow.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkflowCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
    **/
    delete<T extends WorkflowDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkflowUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkflowDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkflowUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
    **/
    upsert<T extends WorkflowUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>
    ): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends Workflow$smeArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    investor<T extends Workflow$investorArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    advisor<T extends Workflow$advisorArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    deal<T extends Workflow$dealArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Workflow model
   */ 
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly tenantId: FieldRef<"Workflow", 'String'>
    readonly type: FieldRef<"Workflow", 'WorkflowType'>
    readonly status: FieldRef<"Workflow", 'WorkflowStatus'>
    readonly data: FieldRef<"Workflow", 'Json'>
    readonly smeId: FieldRef<"Workflow", 'String'>
    readonly investorId: FieldRef<"Workflow", 'String'>
    readonly advisorId: FieldRef<"Workflow", 'String'>
    readonly dealId: FieldRef<"Workflow", 'String'>
    readonly didWorkflowId: FieldRef<"Workflow", 'String'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }


  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }


  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
  }


  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }


  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }


  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
  }


  /**
   * Workflow.sme
   */
  export type Workflow$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }


  /**
   * Workflow.investor
   */
  export type Workflow$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }


  /**
   * Workflow.advisor
   */
  export type Workflow$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * Workflow.deal
   */
  export type Workflow$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkflowInclude<ExtArgs> | null
  }



  /**
   * Model Syndicate
   */

  export type AggregateSyndicate = {
    _count: SyndicateCountAggregateOutputType | null
    _avg: SyndicateAvgAggregateOutputType | null
    _sum: SyndicateSumAggregateOutputType | null
    _min: SyndicateMinAggregateOutputType | null
    _max: SyndicateMaxAggregateOutputType | null
  }

  export type SyndicateAvgAggregateOutputType = {
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
  }

  export type SyndicateSumAggregateOutputType = {
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
  }

  export type SyndicateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    leadInvestorId: string | null
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
    status: $Enums.SyndicateStatus | null
    dealId: string | null
    closingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyndicateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    leadInvestorId: string | null
    targetAmount: number | null
    minInvestment: number | null
    maxInvestment: number | null
    managementFee: number | null
    carryFee: number | null
    status: $Enums.SyndicateStatus | null
    dealId: string | null
    closingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyndicateCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    leadInvestorId: number
    targetAmount: number
    minInvestment: number
    maxInvestment: number
    managementFee: number
    carryFee: number
    status: number
    dealId: number
    closingDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SyndicateAvgAggregateInputType = {
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
  }

  export type SyndicateSumAggregateInputType = {
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
  }

  export type SyndicateMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    leadInvestorId?: true
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
    status?: true
    dealId?: true
    closingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyndicateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    leadInvestorId?: true
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
    status?: true
    dealId?: true
    closingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyndicateCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    leadInvestorId?: true
    targetAmount?: true
    minInvestment?: true
    maxInvestment?: true
    managementFee?: true
    carryFee?: true
    status?: true
    dealId?: true
    closingDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SyndicateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syndicate to aggregate.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Syndicates
    **/
    _count?: true | SyndicateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyndicateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyndicateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyndicateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyndicateMaxAggregateInputType
  }

  export type GetSyndicateAggregateType<T extends SyndicateAggregateArgs> = {
        [P in keyof T & keyof AggregateSyndicate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyndicate[P]>
      : GetScalarType<T[P], AggregateSyndicate[P]>
  }




  export type SyndicateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateWhereInput
    orderBy?: SyndicateOrderByWithAggregationInput | SyndicateOrderByWithAggregationInput[]
    by: SyndicateScalarFieldEnum[] | SyndicateScalarFieldEnum
    having?: SyndicateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyndicateCountAggregateInputType | true
    _avg?: SyndicateAvgAggregateInputType
    _sum?: SyndicateSumAggregateInputType
    _min?: SyndicateMinAggregateInputType
    _max?: SyndicateMaxAggregateInputType
  }

  export type SyndicateGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment: number
    maxInvestment: number | null
    managementFee: number
    carryFee: number
    status: $Enums.SyndicateStatus
    dealId: string | null
    closingDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SyndicateCountAggregateOutputType | null
    _avg: SyndicateAvgAggregateOutputType | null
    _sum: SyndicateSumAggregateOutputType | null
    _min: SyndicateMinAggregateOutputType | null
    _max: SyndicateMaxAggregateOutputType | null
  }

  type GetSyndicateGroupByPayload<T extends SyndicateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyndicateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyndicateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyndicateGroupByOutputType[P]>
            : GetScalarType<T[P], SyndicateGroupByOutputType[P]>
        }
      >
    >


  export type SyndicateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    leadInvestorId?: boolean
    targetAmount?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    managementFee?: boolean
    carryFee?: boolean
    status?: boolean
    dealId?: boolean
    closingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leadInvestor?: boolean | InvestorDefaultArgs<ExtArgs>
    deal?: boolean | Syndicate$dealArgs<ExtArgs>
    members?: boolean | Syndicate$membersArgs<ExtArgs>
    _count?: boolean | SyndicateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syndicate"]>

  export type SyndicateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    leadInvestorId?: boolean
    targetAmount?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    managementFee?: boolean
    carryFee?: boolean
    status?: boolean
    dealId?: boolean
    closingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SyndicateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leadInvestor?: boolean | InvestorDefaultArgs<ExtArgs>
    deal?: boolean | Syndicate$dealArgs<ExtArgs>
    members?: boolean | Syndicate$membersArgs<ExtArgs>
    _count?: boolean | SyndicateCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SyndicatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Syndicate"
    objects: {
      leadInvestor: Prisma.$InvestorPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      members: Prisma.$SyndicateMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      leadInvestorId: string
      targetAmount: number
      minInvestment: number
      maxInvestment: number | null
      managementFee: number
      carryFee: number
      status: $Enums.SyndicateStatus
      dealId: string | null
      closingDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["syndicate"]>
    composites: {}
  }


  type SyndicateGetPayload<S extends boolean | null | undefined | SyndicateDefaultArgs> = $Result.GetResult<Prisma.$SyndicatePayload, S>

  type SyndicateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyndicateFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SyndicateCountAggregateInputType | true
    }

  export interface SyndicateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Syndicate'], meta: { name: 'Syndicate' } }
    /**
     * Find zero or one Syndicate that matches the filter.
     * @param {SyndicateFindUniqueArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SyndicateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateFindUniqueArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Syndicate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SyndicateFindUniqueOrThrowArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SyndicateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Syndicate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateFindFirstArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SyndicateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindFirstArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Syndicate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateFindFirstOrThrowArgs} args - Arguments to find a Syndicate
     * @example
     * // Get one Syndicate
     * const syndicate = await prisma.syndicate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SyndicateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Syndicates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Syndicates
     * const syndicates = await prisma.syndicate.findMany()
     * 
     * // Get first 10 Syndicates
     * const syndicates = await prisma.syndicate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syndicateWithIdOnly = await prisma.syndicate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SyndicateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Syndicate.
     * @param {SyndicateCreateArgs} args - Arguments to create a Syndicate.
     * @example
     * // Create one Syndicate
     * const Syndicate = await prisma.syndicate.create({
     *   data: {
     *     // ... data to create a Syndicate
     *   }
     * })
     * 
    **/
    create<T extends SyndicateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateCreateArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Syndicates.
     *     @param {SyndicateCreateManyArgs} args - Arguments to create many Syndicates.
     *     @example
     *     // Create many Syndicates
     *     const syndicate = await prisma.syndicate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SyndicateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Syndicate.
     * @param {SyndicateDeleteArgs} args - Arguments to delete one Syndicate.
     * @example
     * // Delete one Syndicate
     * const Syndicate = await prisma.syndicate.delete({
     *   where: {
     *     // ... filter to delete one Syndicate
     *   }
     * })
     * 
    **/
    delete<T extends SyndicateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateDeleteArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Syndicate.
     * @param {SyndicateUpdateArgs} args - Arguments to update one Syndicate.
     * @example
     * // Update one Syndicate
     * const syndicate = await prisma.syndicate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SyndicateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateUpdateArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Syndicates.
     * @param {SyndicateDeleteManyArgs} args - Arguments to filter Syndicates to delete.
     * @example
     * // Delete a few Syndicates
     * const { count } = await prisma.syndicate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SyndicateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syndicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Syndicates
     * const syndicate = await prisma.syndicate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SyndicateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Syndicate.
     * @param {SyndicateUpsertArgs} args - Arguments to update or create a Syndicate.
     * @example
     * // Update or create a Syndicate
     * const syndicate = await prisma.syndicate.upsert({
     *   create: {
     *     // ... data to create a Syndicate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Syndicate we want to update
     *   }
     * })
    **/
    upsert<T extends SyndicateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateUpsertArgs<ExtArgs>>
    ): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Syndicates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateCountArgs} args - Arguments to filter Syndicates to count.
     * @example
     * // Count the number of Syndicates
     * const count = await prisma.syndicate.count({
     *   where: {
     *     // ... the filter for the Syndicates we want to count
     *   }
     * })
    **/
    count<T extends SyndicateCountArgs>(
      args?: Subset<T, SyndicateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyndicateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Syndicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyndicateAggregateArgs>(args: Subset<T, SyndicateAggregateArgs>): Prisma.PrismaPromise<GetSyndicateAggregateType<T>>

    /**
     * Group by Syndicate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyndicateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyndicateGroupByArgs['orderBy'] }
        : { orderBy?: SyndicateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyndicateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyndicateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Syndicate model
   */
  readonly fields: SyndicateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Syndicate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyndicateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    leadInvestor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    deal<T extends Syndicate$dealArgs<ExtArgs> = {}>(args?: Subset<T, Syndicate$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    members<T extends Syndicate$membersArgs<ExtArgs> = {}>(args?: Subset<T, Syndicate$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Syndicate model
   */ 
  interface SyndicateFieldRefs {
    readonly id: FieldRef<"Syndicate", 'String'>
    readonly tenantId: FieldRef<"Syndicate", 'String'>
    readonly name: FieldRef<"Syndicate", 'String'>
    readonly description: FieldRef<"Syndicate", 'String'>
    readonly leadInvestorId: FieldRef<"Syndicate", 'String'>
    readonly targetAmount: FieldRef<"Syndicate", 'Float'>
    readonly minInvestment: FieldRef<"Syndicate", 'Float'>
    readonly maxInvestment: FieldRef<"Syndicate", 'Float'>
    readonly managementFee: FieldRef<"Syndicate", 'Float'>
    readonly carryFee: FieldRef<"Syndicate", 'Float'>
    readonly status: FieldRef<"Syndicate", 'SyndicateStatus'>
    readonly dealId: FieldRef<"Syndicate", 'String'>
    readonly closingDate: FieldRef<"Syndicate", 'DateTime'>
    readonly createdAt: FieldRef<"Syndicate", 'DateTime'>
    readonly updatedAt: FieldRef<"Syndicate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Syndicate findUnique
   */
  export type SyndicateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate findUniqueOrThrow
   */
  export type SyndicateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate findFirst
   */
  export type SyndicateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syndicates.
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syndicates.
     */
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Syndicate findFirstOrThrow
   */
  export type SyndicateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicate to fetch.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syndicates.
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syndicates.
     */
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Syndicate findMany
   */
  export type SyndicateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter, which Syndicates to fetch.
     */
    where?: SyndicateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syndicates to fetch.
     */
    orderBy?: SyndicateOrderByWithRelationInput | SyndicateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Syndicates.
     */
    cursor?: SyndicateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syndicates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syndicates.
     */
    skip?: number
    distinct?: SyndicateScalarFieldEnum | SyndicateScalarFieldEnum[]
  }


  /**
   * Syndicate create
   */
  export type SyndicateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * The data needed to create a Syndicate.
     */
    data: XOR<SyndicateCreateInput, SyndicateUncheckedCreateInput>
  }


  /**
   * Syndicate createMany
   */
  export type SyndicateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Syndicates.
     */
    data: SyndicateCreateManyInput | SyndicateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Syndicate update
   */
  export type SyndicateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * The data needed to update a Syndicate.
     */
    data: XOR<SyndicateUpdateInput, SyndicateUncheckedUpdateInput>
    /**
     * Choose, which Syndicate to update.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate updateMany
   */
  export type SyndicateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Syndicates.
     */
    data: XOR<SyndicateUpdateManyMutationInput, SyndicateUncheckedUpdateManyInput>
    /**
     * Filter which Syndicates to update
     */
    where?: SyndicateWhereInput
  }


  /**
   * Syndicate upsert
   */
  export type SyndicateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * The filter to search for the Syndicate to update in case it exists.
     */
    where: SyndicateWhereUniqueInput
    /**
     * In case the Syndicate found by the `where` argument doesn't exist, create a new Syndicate with this data.
     */
    create: XOR<SyndicateCreateInput, SyndicateUncheckedCreateInput>
    /**
     * In case the Syndicate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyndicateUpdateInput, SyndicateUncheckedUpdateInput>
  }


  /**
   * Syndicate delete
   */
  export type SyndicateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
    /**
     * Filter which Syndicate to delete.
     */
    where: SyndicateWhereUniqueInput
  }


  /**
   * Syndicate deleteMany
   */
  export type SyndicateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syndicates to delete
     */
    where?: SyndicateWhereInput
  }


  /**
   * Syndicate.deal
   */
  export type Syndicate$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Syndicate.members
   */
  export type Syndicate$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    where?: SyndicateMemberWhereInput
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    cursor?: SyndicateMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * Syndicate without action
   */
  export type SyndicateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syndicate
     */
    select?: SyndicateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateInclude<ExtArgs> | null
  }



  /**
   * Model SyndicateMember
   */

  export type AggregateSyndicateMember = {
    _count: SyndicateMemberCountAggregateOutputType | null
    _avg: SyndicateMemberAvgAggregateOutputType | null
    _sum: SyndicateMemberSumAggregateOutputType | null
    _min: SyndicateMemberMinAggregateOutputType | null
    _max: SyndicateMemberMaxAggregateOutputType | null
  }

  export type SyndicateMemberAvgAggregateOutputType = {
    amount: number | null
  }

  export type SyndicateMemberSumAggregateOutputType = {
    amount: number | null
  }

  export type SyndicateMemberMinAggregateOutputType = {
    id: string | null
    syndicateId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.SyndicateMemberStatus | null
    joinedAt: Date | null
  }

  export type SyndicateMemberMaxAggregateOutputType = {
    id: string | null
    syndicateId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.SyndicateMemberStatus | null
    joinedAt: Date | null
  }

  export type SyndicateMemberCountAggregateOutputType = {
    id: number
    syndicateId: number
    investorId: number
    amount: number
    status: number
    joinedAt: number
    _all: number
  }


  export type SyndicateMemberAvgAggregateInputType = {
    amount?: true
  }

  export type SyndicateMemberSumAggregateInputType = {
    amount?: true
  }

  export type SyndicateMemberMinAggregateInputType = {
    id?: true
    syndicateId?: true
    investorId?: true
    amount?: true
    status?: true
    joinedAt?: true
  }

  export type SyndicateMemberMaxAggregateInputType = {
    id?: true
    syndicateId?: true
    investorId?: true
    amount?: true
    status?: true
    joinedAt?: true
  }

  export type SyndicateMemberCountAggregateInputType = {
    id?: true
    syndicateId?: true
    investorId?: true
    amount?: true
    status?: true
    joinedAt?: true
    _all?: true
  }

  export type SyndicateMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyndicateMember to aggregate.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyndicateMembers
    **/
    _count?: true | SyndicateMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyndicateMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyndicateMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyndicateMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyndicateMemberMaxAggregateInputType
  }

  export type GetSyndicateMemberAggregateType<T extends SyndicateMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateSyndicateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyndicateMember[P]>
      : GetScalarType<T[P], AggregateSyndicateMember[P]>
  }




  export type SyndicateMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyndicateMemberWhereInput
    orderBy?: SyndicateMemberOrderByWithAggregationInput | SyndicateMemberOrderByWithAggregationInput[]
    by: SyndicateMemberScalarFieldEnum[] | SyndicateMemberScalarFieldEnum
    having?: SyndicateMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyndicateMemberCountAggregateInputType | true
    _avg?: SyndicateMemberAvgAggregateInputType
    _sum?: SyndicateMemberSumAggregateInputType
    _min?: SyndicateMemberMinAggregateInputType
    _max?: SyndicateMemberMaxAggregateInputType
  }

  export type SyndicateMemberGroupByOutputType = {
    id: string
    syndicateId: string
    investorId: string
    amount: number
    status: $Enums.SyndicateMemberStatus
    joinedAt: Date
    _count: SyndicateMemberCountAggregateOutputType | null
    _avg: SyndicateMemberAvgAggregateOutputType | null
    _sum: SyndicateMemberSumAggregateOutputType | null
    _min: SyndicateMemberMinAggregateOutputType | null
    _max: SyndicateMemberMaxAggregateOutputType | null
  }

  type GetSyndicateMemberGroupByPayload<T extends SyndicateMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyndicateMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyndicateMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyndicateMemberGroupByOutputType[P]>
            : GetScalarType<T[P], SyndicateMemberGroupByOutputType[P]>
        }
      >
    >


  export type SyndicateMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syndicateId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    joinedAt?: boolean
    syndicate?: boolean | SyndicateDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syndicateMember"]>

  export type SyndicateMemberSelectScalar = {
    id?: boolean
    syndicateId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    joinedAt?: boolean
  }

  export type SyndicateMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syndicate?: boolean | SyndicateDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }


  export type $SyndicateMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyndicateMember"
    objects: {
      syndicate: Prisma.$SyndicatePayload<ExtArgs>
      investor: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syndicateId: string
      investorId: string
      amount: number
      status: $Enums.SyndicateMemberStatus
      joinedAt: Date
    }, ExtArgs["result"]["syndicateMember"]>
    composites: {}
  }


  type SyndicateMemberGetPayload<S extends boolean | null | undefined | SyndicateMemberDefaultArgs> = $Result.GetResult<Prisma.$SyndicateMemberPayload, S>

  type SyndicateMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyndicateMemberFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SyndicateMemberCountAggregateInputType | true
    }

  export interface SyndicateMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyndicateMember'], meta: { name: 'SyndicateMember' } }
    /**
     * Find zero or one SyndicateMember that matches the filter.
     * @param {SyndicateMemberFindUniqueArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SyndicateMemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SyndicateMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SyndicateMemberFindUniqueOrThrowArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SyndicateMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SyndicateMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberFindFirstArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SyndicateMemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindFirstArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SyndicateMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberFindFirstOrThrowArgs} args - Arguments to find a SyndicateMember
     * @example
     * // Get one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SyndicateMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SyndicateMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyndicateMembers
     * const syndicateMembers = await prisma.syndicateMember.findMany()
     * 
     * // Get first 10 SyndicateMembers
     * const syndicateMembers = await prisma.syndicateMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syndicateMemberWithIdOnly = await prisma.syndicateMember.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SyndicateMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SyndicateMember.
     * @param {SyndicateMemberCreateArgs} args - Arguments to create a SyndicateMember.
     * @example
     * // Create one SyndicateMember
     * const SyndicateMember = await prisma.syndicateMember.create({
     *   data: {
     *     // ... data to create a SyndicateMember
     *   }
     * })
     * 
    **/
    create<T extends SyndicateMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberCreateArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SyndicateMembers.
     *     @param {SyndicateMemberCreateManyArgs} args - Arguments to create many SyndicateMembers.
     *     @example
     *     // Create many SyndicateMembers
     *     const syndicateMember = await prisma.syndicateMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SyndicateMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyndicateMember.
     * @param {SyndicateMemberDeleteArgs} args - Arguments to delete one SyndicateMember.
     * @example
     * // Delete one SyndicateMember
     * const SyndicateMember = await prisma.syndicateMember.delete({
     *   where: {
     *     // ... filter to delete one SyndicateMember
     *   }
     * })
     * 
    **/
    delete<T extends SyndicateMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberDeleteArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SyndicateMember.
     * @param {SyndicateMemberUpdateArgs} args - Arguments to update one SyndicateMember.
     * @example
     * // Update one SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SyndicateMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberUpdateArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SyndicateMembers.
     * @param {SyndicateMemberDeleteManyArgs} args - Arguments to filter SyndicateMembers to delete.
     * @example
     * // Delete a few SyndicateMembers
     * const { count } = await prisma.syndicateMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SyndicateMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyndicateMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyndicateMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyndicateMembers
     * const syndicateMember = await prisma.syndicateMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SyndicateMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyndicateMember.
     * @param {SyndicateMemberUpsertArgs} args - Arguments to update or create a SyndicateMember.
     * @example
     * // Update or create a SyndicateMember
     * const syndicateMember = await prisma.syndicateMember.upsert({
     *   create: {
     *     // ... data to create a SyndicateMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyndicateMember we want to update
     *   }
     * })
    **/
    upsert<T extends SyndicateMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SyndicateMemberUpsertArgs<ExtArgs>>
    ): Prisma__SyndicateMemberClient<$Result.GetResult<Prisma.$SyndicateMemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SyndicateMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberCountArgs} args - Arguments to filter SyndicateMembers to count.
     * @example
     * // Count the number of SyndicateMembers
     * const count = await prisma.syndicateMember.count({
     *   where: {
     *     // ... the filter for the SyndicateMembers we want to count
     *   }
     * })
    **/
    count<T extends SyndicateMemberCountArgs>(
      args?: Subset<T, SyndicateMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyndicateMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyndicateMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyndicateMemberAggregateArgs>(args: Subset<T, SyndicateMemberAggregateArgs>): Prisma.PrismaPromise<GetSyndicateMemberAggregateType<T>>

    /**
     * Group by SyndicateMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyndicateMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyndicateMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyndicateMemberGroupByArgs['orderBy'] }
        : { orderBy?: SyndicateMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyndicateMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyndicateMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyndicateMember model
   */
  readonly fields: SyndicateMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyndicateMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyndicateMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    syndicate<T extends SyndicateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyndicateDefaultArgs<ExtArgs>>): Prisma__SyndicateClient<$Result.GetResult<Prisma.$SyndicatePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SyndicateMember model
   */ 
  interface SyndicateMemberFieldRefs {
    readonly id: FieldRef<"SyndicateMember", 'String'>
    readonly syndicateId: FieldRef<"SyndicateMember", 'String'>
    readonly investorId: FieldRef<"SyndicateMember", 'String'>
    readonly amount: FieldRef<"SyndicateMember", 'Float'>
    readonly status: FieldRef<"SyndicateMember", 'SyndicateMemberStatus'>
    readonly joinedAt: FieldRef<"SyndicateMember", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SyndicateMember findUnique
   */
  export type SyndicateMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember findUniqueOrThrow
   */
  export type SyndicateMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember findFirst
   */
  export type SyndicateMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyndicateMembers.
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyndicateMembers.
     */
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * SyndicateMember findFirstOrThrow
   */
  export type SyndicateMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMember to fetch.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyndicateMembers.
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyndicateMembers.
     */
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * SyndicateMember findMany
   */
  export type SyndicateMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter, which SyndicateMembers to fetch.
     */
    where?: SyndicateMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyndicateMembers to fetch.
     */
    orderBy?: SyndicateMemberOrderByWithRelationInput | SyndicateMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyndicateMembers.
     */
    cursor?: SyndicateMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyndicateMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyndicateMembers.
     */
    skip?: number
    distinct?: SyndicateMemberScalarFieldEnum | SyndicateMemberScalarFieldEnum[]
  }


  /**
   * SyndicateMember create
   */
  export type SyndicateMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a SyndicateMember.
     */
    data: XOR<SyndicateMemberCreateInput, SyndicateMemberUncheckedCreateInput>
  }


  /**
   * SyndicateMember createMany
   */
  export type SyndicateMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyndicateMembers.
     */
    data: SyndicateMemberCreateManyInput | SyndicateMemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SyndicateMember update
   */
  export type SyndicateMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a SyndicateMember.
     */
    data: XOR<SyndicateMemberUpdateInput, SyndicateMemberUncheckedUpdateInput>
    /**
     * Choose, which SyndicateMember to update.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember updateMany
   */
  export type SyndicateMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyndicateMembers.
     */
    data: XOR<SyndicateMemberUpdateManyMutationInput, SyndicateMemberUncheckedUpdateManyInput>
    /**
     * Filter which SyndicateMembers to update
     */
    where?: SyndicateMemberWhereInput
  }


  /**
   * SyndicateMember upsert
   */
  export type SyndicateMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the SyndicateMember to update in case it exists.
     */
    where: SyndicateMemberWhereUniqueInput
    /**
     * In case the SyndicateMember found by the `where` argument doesn't exist, create a new SyndicateMember with this data.
     */
    create: XOR<SyndicateMemberCreateInput, SyndicateMemberUncheckedCreateInput>
    /**
     * In case the SyndicateMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyndicateMemberUpdateInput, SyndicateMemberUncheckedUpdateInput>
  }


  /**
   * SyndicateMember delete
   */
  export type SyndicateMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
    /**
     * Filter which SyndicateMember to delete.
     */
    where: SyndicateMemberWhereUniqueInput
  }


  /**
   * SyndicateMember deleteMany
   */
  export type SyndicateMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyndicateMembers to delete
     */
    where?: SyndicateMemberWhereInput
  }


  /**
   * SyndicateMember without action
   */
  export type SyndicateMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyndicateMember
     */
    select?: SyndicateMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SyndicateMemberInclude<ExtArgs> | null
  }



  /**
   * Model DueDiligence
   */

  export type AggregateDueDiligence = {
    _count: DueDiligenceCountAggregateOutputType | null
    _avg: DueDiligenceAvgAggregateOutputType | null
    _sum: DueDiligenceSumAggregateOutputType | null
    _min: DueDiligenceMinAggregateOutputType | null
    _max: DueDiligenceMaxAggregateOutputType | null
  }

  export type DueDiligenceAvgAggregateOutputType = {
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
  }

  export type DueDiligenceSumAggregateOutputType = {
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
  }

  export type DueDiligenceMinAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
    riskLevel: $Enums.RiskLevel | null
    status: $Enums.DueDiligenceStatus | null
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DueDiligenceMaxAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    productScore: number | null
    legalScore: number | null
    operationalScore: number | null
    overallScore: number | null
    riskLevel: $Enums.RiskLevel | null
    status: $Enums.DueDiligenceStatus | null
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DueDiligenceCountAggregateOutputType = {
    id: number
    smeId: number
    advisorId: number
    financialScore: number
    teamScore: number
    marketScore: number
    productScore: number
    legalScore: number
    operationalScore: number
    overallScore: number
    riskLevel: number
    strengths: number
    weaknesses: number
    recommendations: number
    redFlags: number
    status: number
    completedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DueDiligenceAvgAggregateInputType = {
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
  }

  export type DueDiligenceSumAggregateInputType = {
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
  }

  export type DueDiligenceMinAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
    riskLevel?: true
    status?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DueDiligenceMaxAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
    riskLevel?: true
    status?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DueDiligenceCountAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    productScore?: true
    legalScore?: true
    operationalScore?: true
    overallScore?: true
    riskLevel?: true
    strengths?: true
    weaknesses?: true
    recommendations?: true
    redFlags?: true
    status?: true
    completedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DueDiligenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DueDiligence to aggregate.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DueDiligences
    **/
    _count?: true | DueDiligenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DueDiligenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DueDiligenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DueDiligenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DueDiligenceMaxAggregateInputType
  }

  export type GetDueDiligenceAggregateType<T extends DueDiligenceAggregateArgs> = {
        [P in keyof T & keyof AggregateDueDiligence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDueDiligence[P]>
      : GetScalarType<T[P], AggregateDueDiligence[P]>
  }




  export type DueDiligenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceWhereInput
    orderBy?: DueDiligenceOrderByWithAggregationInput | DueDiligenceOrderByWithAggregationInput[]
    by: DueDiligenceScalarFieldEnum[] | DueDiligenceScalarFieldEnum
    having?: DueDiligenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DueDiligenceCountAggregateInputType | true
    _avg?: DueDiligenceAvgAggregateInputType
    _sum?: DueDiligenceSumAggregateInputType
    _min?: DueDiligenceMinAggregateInputType
    _max?: DueDiligenceMaxAggregateInputType
  }

  export type DueDiligenceGroupByOutputType = {
    id: string
    smeId: string
    advisorId: string | null
    financialScore: number
    teamScore: number
    marketScore: number
    productScore: number
    legalScore: number
    operationalScore: number
    overallScore: number
    riskLevel: $Enums.RiskLevel
    strengths: string[]
    weaknesses: string[]
    recommendations: string[]
    redFlags: string[]
    status: $Enums.DueDiligenceStatus
    completedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DueDiligenceCountAggregateOutputType | null
    _avg: DueDiligenceAvgAggregateOutputType | null
    _sum: DueDiligenceSumAggregateOutputType | null
    _min: DueDiligenceMinAggregateOutputType | null
    _max: DueDiligenceMaxAggregateOutputType | null
  }

  type GetDueDiligenceGroupByPayload<T extends DueDiligenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DueDiligenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DueDiligenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DueDiligenceGroupByOutputType[P]>
            : GetScalarType<T[P], DueDiligenceGroupByOutputType[P]>
        }
      >
    >


  export type DueDiligenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    productScore?: boolean
    legalScore?: boolean
    operationalScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    redFlags?: boolean
    status?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | DueDiligence$advisorArgs<ExtArgs>
  }, ExtArgs["result"]["dueDiligence"]>

  export type DueDiligenceSelectScalar = {
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    productScore?: boolean
    legalScore?: boolean
    operationalScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    redFlags?: boolean
    status?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DueDiligenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | DueDiligence$advisorArgs<ExtArgs>
  }


  export type $DueDiligencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DueDiligence"
    objects: {
      sme: Prisma.$SMEPayload<ExtArgs>
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      smeId: string
      advisorId: string | null
      financialScore: number
      teamScore: number
      marketScore: number
      productScore: number
      legalScore: number
      operationalScore: number
      overallScore: number
      riskLevel: $Enums.RiskLevel
      strengths: string[]
      weaknesses: string[]
      recommendations: string[]
      redFlags: string[]
      status: $Enums.DueDiligenceStatus
      completedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dueDiligence"]>
    composites: {}
  }


  type DueDiligenceGetPayload<S extends boolean | null | undefined | DueDiligenceDefaultArgs> = $Result.GetResult<Prisma.$DueDiligencePayload, S>

  type DueDiligenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DueDiligenceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DueDiligenceCountAggregateInputType | true
    }

  export interface DueDiligenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DueDiligence'], meta: { name: 'DueDiligence' } }
    /**
     * Find zero or one DueDiligence that matches the filter.
     * @param {DueDiligenceFindUniqueArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DueDiligenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceFindUniqueArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DueDiligence that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DueDiligenceFindUniqueOrThrowArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DueDiligenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DueDiligence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceFindFirstArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DueDiligenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindFirstArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DueDiligence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceFindFirstOrThrowArgs} args - Arguments to find a DueDiligence
     * @example
     * // Get one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DueDiligenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DueDiligences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DueDiligences
     * const dueDiligences = await prisma.dueDiligence.findMany()
     * 
     * // Get first 10 DueDiligences
     * const dueDiligences = await prisma.dueDiligence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dueDiligenceWithIdOnly = await prisma.dueDiligence.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DueDiligenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DueDiligence.
     * @param {DueDiligenceCreateArgs} args - Arguments to create a DueDiligence.
     * @example
     * // Create one DueDiligence
     * const DueDiligence = await prisma.dueDiligence.create({
     *   data: {
     *     // ... data to create a DueDiligence
     *   }
     * })
     * 
    **/
    create<T extends DueDiligenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceCreateArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DueDiligences.
     *     @param {DueDiligenceCreateManyArgs} args - Arguments to create many DueDiligences.
     *     @example
     *     // Create many DueDiligences
     *     const dueDiligence = await prisma.dueDiligence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DueDiligenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DueDiligence.
     * @param {DueDiligenceDeleteArgs} args - Arguments to delete one DueDiligence.
     * @example
     * // Delete one DueDiligence
     * const DueDiligence = await prisma.dueDiligence.delete({
     *   where: {
     *     // ... filter to delete one DueDiligence
     *   }
     * })
     * 
    **/
    delete<T extends DueDiligenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceDeleteArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DueDiligence.
     * @param {DueDiligenceUpdateArgs} args - Arguments to update one DueDiligence.
     * @example
     * // Update one DueDiligence
     * const dueDiligence = await prisma.dueDiligence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DueDiligenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceUpdateArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DueDiligences.
     * @param {DueDiligenceDeleteManyArgs} args - Arguments to filter DueDiligences to delete.
     * @example
     * // Delete a few DueDiligences
     * const { count } = await prisma.dueDiligence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DueDiligenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DueDiligenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DueDiligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DueDiligences
     * const dueDiligence = await prisma.dueDiligence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DueDiligenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DueDiligence.
     * @param {DueDiligenceUpsertArgs} args - Arguments to update or create a DueDiligence.
     * @example
     * // Update or create a DueDiligence
     * const dueDiligence = await prisma.dueDiligence.upsert({
     *   create: {
     *     // ... data to create a DueDiligence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DueDiligence we want to update
     *   }
     * })
    **/
    upsert<T extends DueDiligenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DueDiligenceUpsertArgs<ExtArgs>>
    ): Prisma__DueDiligenceClient<$Result.GetResult<Prisma.$DueDiligencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DueDiligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceCountArgs} args - Arguments to filter DueDiligences to count.
     * @example
     * // Count the number of DueDiligences
     * const count = await prisma.dueDiligence.count({
     *   where: {
     *     // ... the filter for the DueDiligences we want to count
     *   }
     * })
    **/
    count<T extends DueDiligenceCountArgs>(
      args?: Subset<T, DueDiligenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DueDiligenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DueDiligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DueDiligenceAggregateArgs>(args: Subset<T, DueDiligenceAggregateArgs>): Prisma.PrismaPromise<GetDueDiligenceAggregateType<T>>

    /**
     * Group by DueDiligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DueDiligenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DueDiligenceGroupByArgs['orderBy'] }
        : { orderBy?: DueDiligenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DueDiligenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDueDiligenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DueDiligence model
   */
  readonly fields: DueDiligenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DueDiligence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DueDiligenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    advisor<T extends DueDiligence$advisorArgs<ExtArgs> = {}>(args?: Subset<T, DueDiligence$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DueDiligence model
   */ 
  interface DueDiligenceFieldRefs {
    readonly id: FieldRef<"DueDiligence", 'String'>
    readonly smeId: FieldRef<"DueDiligence", 'String'>
    readonly advisorId: FieldRef<"DueDiligence", 'String'>
    readonly financialScore: FieldRef<"DueDiligence", 'Float'>
    readonly teamScore: FieldRef<"DueDiligence", 'Float'>
    readonly marketScore: FieldRef<"DueDiligence", 'Float'>
    readonly productScore: FieldRef<"DueDiligence", 'Float'>
    readonly legalScore: FieldRef<"DueDiligence", 'Float'>
    readonly operationalScore: FieldRef<"DueDiligence", 'Float'>
    readonly overallScore: FieldRef<"DueDiligence", 'Float'>
    readonly riskLevel: FieldRef<"DueDiligence", 'RiskLevel'>
    readonly strengths: FieldRef<"DueDiligence", 'String[]'>
    readonly weaknesses: FieldRef<"DueDiligence", 'String[]'>
    readonly recommendations: FieldRef<"DueDiligence", 'String[]'>
    readonly redFlags: FieldRef<"DueDiligence", 'String[]'>
    readonly status: FieldRef<"DueDiligence", 'DueDiligenceStatus'>
    readonly completedAt: FieldRef<"DueDiligence", 'DateTime'>
    readonly expiresAt: FieldRef<"DueDiligence", 'DateTime'>
    readonly createdAt: FieldRef<"DueDiligence", 'DateTime'>
    readonly updatedAt: FieldRef<"DueDiligence", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DueDiligence findUnique
   */
  export type DueDiligenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence findUniqueOrThrow
   */
  export type DueDiligenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence findFirst
   */
  export type DueDiligenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDiligences.
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDiligences.
     */
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * DueDiligence findFirstOrThrow
   */
  export type DueDiligenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligence to fetch.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDiligences.
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDiligences.
     */
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * DueDiligence findMany
   */
  export type DueDiligenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligences to fetch.
     */
    where?: DueDiligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligences to fetch.
     */
    orderBy?: DueDiligenceOrderByWithRelationInput | DueDiligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DueDiligences.
     */
    cursor?: DueDiligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligences.
     */
    skip?: number
    distinct?: DueDiligenceScalarFieldEnum | DueDiligenceScalarFieldEnum[]
  }


  /**
   * DueDiligence create
   */
  export type DueDiligenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * The data needed to create a DueDiligence.
     */
    data: XOR<DueDiligenceCreateInput, DueDiligenceUncheckedCreateInput>
  }


  /**
   * DueDiligence createMany
   */
  export type DueDiligenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DueDiligences.
     */
    data: DueDiligenceCreateManyInput | DueDiligenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DueDiligence update
   */
  export type DueDiligenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * The data needed to update a DueDiligence.
     */
    data: XOR<DueDiligenceUpdateInput, DueDiligenceUncheckedUpdateInput>
    /**
     * Choose, which DueDiligence to update.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence updateMany
   */
  export type DueDiligenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DueDiligences.
     */
    data: XOR<DueDiligenceUpdateManyMutationInput, DueDiligenceUncheckedUpdateManyInput>
    /**
     * Filter which DueDiligences to update
     */
    where?: DueDiligenceWhereInput
  }


  /**
   * DueDiligence upsert
   */
  export type DueDiligenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * The filter to search for the DueDiligence to update in case it exists.
     */
    where: DueDiligenceWhereUniqueInput
    /**
     * In case the DueDiligence found by the `where` argument doesn't exist, create a new DueDiligence with this data.
     */
    create: XOR<DueDiligenceCreateInput, DueDiligenceUncheckedCreateInput>
    /**
     * In case the DueDiligence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DueDiligenceUpdateInput, DueDiligenceUncheckedUpdateInput>
  }


  /**
   * DueDiligence delete
   */
  export type DueDiligenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
    /**
     * Filter which DueDiligence to delete.
     */
    where: DueDiligenceWhereUniqueInput
  }


  /**
   * DueDiligence deleteMany
   */
  export type DueDiligenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DueDiligences to delete
     */
    where?: DueDiligenceWhereInput
  }


  /**
   * DueDiligence.advisor
   */
  export type DueDiligence$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * DueDiligence without action
   */
  export type DueDiligenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligence
     */
    select?: DueDiligenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DueDiligenceInclude<ExtArgs> | null
  }



  /**
   * Model CommunityPost
   */

  export type AggregateCommunityPost = {
    _count: CommunityPostCountAggregateOutputType | null
    _avg: CommunityPostAvgAggregateOutputType | null
    _sum: CommunityPostSumAggregateOutputType | null
    _min: CommunityPostMinAggregateOutputType | null
    _max: CommunityPostMaxAggregateOutputType | null
  }

  export type CommunityPostAvgAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type CommunityPostSumAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type CommunityPostMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    category: $Enums.PostCategory | null
    smeId: string | null
    dealId: string | null
    syndicateId: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    isAnnouncement: boolean | null
    status: $Enums.PostStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityPostMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    category: $Enums.PostCategory | null
    smeId: string | null
    dealId: string | null
    syndicateId: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    isAnnouncement: boolean | null
    status: $Enums.PostStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityPostCountAggregateOutputType = {
    id: number
    tenantId: number
    authorId: number
    title: number
    content: number
    category: number
    smeId: number
    dealId: number
    syndicateId: number
    likes: number
    views: number
    isPinned: number
    isAnnouncement: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityPostAvgAggregateInputType = {
    likes?: true
    views?: true
  }

  export type CommunityPostSumAggregateInputType = {
    likes?: true
    views?: true
  }

  export type CommunityPostMinAggregateInputType = {
    id?: true
    tenantId?: true
    authorId?: true
    title?: true
    content?: true
    category?: true
    smeId?: true
    dealId?: true
    syndicateId?: true
    likes?: true
    views?: true
    isPinned?: true
    isAnnouncement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityPostMaxAggregateInputType = {
    id?: true
    tenantId?: true
    authorId?: true
    title?: true
    content?: true
    category?: true
    smeId?: true
    dealId?: true
    syndicateId?: true
    likes?: true
    views?: true
    isPinned?: true
    isAnnouncement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityPostCountAggregateInputType = {
    id?: true
    tenantId?: true
    authorId?: true
    title?: true
    content?: true
    category?: true
    smeId?: true
    dealId?: true
    syndicateId?: true
    likes?: true
    views?: true
    isPinned?: true
    isAnnouncement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPost to aggregate.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPosts
    **/
    _count?: true | CommunityPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityPostMaxAggregateInputType
  }

  export type GetCommunityPostAggregateType<T extends CommunityPostAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPost[P]>
      : GetScalarType<T[P], AggregateCommunityPost[P]>
  }




  export type CommunityPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPostWhereInput
    orderBy?: CommunityPostOrderByWithAggregationInput | CommunityPostOrderByWithAggregationInput[]
    by: CommunityPostScalarFieldEnum[] | CommunityPostScalarFieldEnum
    having?: CommunityPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityPostCountAggregateInputType | true
    _avg?: CommunityPostAvgAggregateInputType
    _sum?: CommunityPostSumAggregateInputType
    _min?: CommunityPostMinAggregateInputType
    _max?: CommunityPostMaxAggregateInputType
  }

  export type CommunityPostGroupByOutputType = {
    id: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category: $Enums.PostCategory
    smeId: string | null
    dealId: string | null
    syndicateId: string | null
    likes: number
    views: number
    isPinned: boolean
    isAnnouncement: boolean
    status: $Enums.PostStatus
    createdAt: Date
    updatedAt: Date
    _count: CommunityPostCountAggregateOutputType | null
    _avg: CommunityPostAvgAggregateOutputType | null
    _sum: CommunityPostSumAggregateOutputType | null
    _min: CommunityPostMinAggregateOutputType | null
    _max: CommunityPostMaxAggregateOutputType | null
  }

  type GetCommunityPostGroupByPayload<T extends CommunityPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
        }
      >
    >


  export type CommunityPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    smeId?: boolean
    dealId?: boolean
    syndicateId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | CommunityPost$commentsArgs<ExtArgs>
    _count?: boolean | CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityPost"]>

  export type CommunityPostSelectScalar = {
    id?: boolean
    tenantId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    smeId?: boolean
    dealId?: boolean
    syndicateId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | CommunityPost$commentsArgs<ExtArgs>
    _count?: boolean | CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommunityPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityPost"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      authorId: string
      title: string
      content: string
      category: $Enums.PostCategory
      smeId: string | null
      dealId: string | null
      syndicateId: string | null
      likes: number
      views: number
      isPinned: boolean
      isAnnouncement: boolean
      status: $Enums.PostStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityPost"]>
    composites: {}
  }


  type CommunityPostGetPayload<S extends boolean | null | undefined | CommunityPostDefaultArgs> = $Result.GetResult<Prisma.$CommunityPostPayload, S>

  type CommunityPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityPostFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CommunityPostCountAggregateInputType | true
    }

  export interface CommunityPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityPost'], meta: { name: 'CommunityPost' } }
    /**
     * Find zero or one CommunityPost that matches the filter.
     * @param {CommunityPostFindUniqueArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CommunityPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityPostFindUniqueOrThrowArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CommunityPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CommunityPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstOrThrowArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CommunityPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany()
     * 
     * // Get first 10 CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CommunityPost.
     * @param {CommunityPostCreateArgs} args - Arguments to create a CommunityPost.
     * @example
     * // Create one CommunityPost
     * const CommunityPost = await prisma.communityPost.create({
     *   data: {
     *     // ... data to create a CommunityPost
     *   }
     * })
     * 
    **/
    create<T extends CommunityPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostCreateArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CommunityPosts.
     *     @param {CommunityPostCreateManyArgs} args - Arguments to create many CommunityPosts.
     *     @example
     *     // Create many CommunityPosts
     *     const communityPost = await prisma.communityPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityPost.
     * @param {CommunityPostDeleteArgs} args - Arguments to delete one CommunityPost.
     * @example
     * // Delete one CommunityPost
     * const CommunityPost = await prisma.communityPost.delete({
     *   where: {
     *     // ... filter to delete one CommunityPost
     *   }
     * })
     * 
    **/
    delete<T extends CommunityPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostDeleteArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CommunityPost.
     * @param {CommunityPostUpdateArgs} args - Arguments to update one CommunityPost.
     * @example
     * // Update one CommunityPost
     * const communityPost = await prisma.communityPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostUpdateArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CommunityPosts.
     * @param {CommunityPostDeleteManyArgs} args - Arguments to filter CommunityPosts to delete.
     * @example
     * // Delete a few CommunityPosts
     * const { count } = await prisma.communityPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPosts
     * const communityPost = await prisma.communityPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityPost.
     * @param {CommunityPostUpsertArgs} args - Arguments to update or create a CommunityPost.
     * @example
     * // Update or create a CommunityPost
     * const communityPost = await prisma.communityPost.upsert({
     *   create: {
     *     // ... data to create a CommunityPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPost we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityPostUpsertArgs<ExtArgs>>
    ): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostCountArgs} args - Arguments to filter CommunityPosts to count.
     * @example
     * // Count the number of CommunityPosts
     * const count = await prisma.communityPost.count({
     *   where: {
     *     // ... the filter for the CommunityPosts we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostCountArgs>(
      args?: Subset<T, CommunityPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostAggregateArgs>(args: Subset<T, CommunityPostAggregateArgs>): Prisma.PrismaPromise<GetCommunityPostAggregateType<T>>

    /**
     * Group by CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPostGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityPost model
   */
  readonly fields: CommunityPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    comments<T extends CommunityPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CommunityPost model
   */ 
  interface CommunityPostFieldRefs {
    readonly id: FieldRef<"CommunityPost", 'String'>
    readonly tenantId: FieldRef<"CommunityPost", 'String'>
    readonly authorId: FieldRef<"CommunityPost", 'String'>
    readonly title: FieldRef<"CommunityPost", 'String'>
    readonly content: FieldRef<"CommunityPost", 'String'>
    readonly category: FieldRef<"CommunityPost", 'PostCategory'>
    readonly smeId: FieldRef<"CommunityPost", 'String'>
    readonly dealId: FieldRef<"CommunityPost", 'String'>
    readonly syndicateId: FieldRef<"CommunityPost", 'String'>
    readonly likes: FieldRef<"CommunityPost", 'Int'>
    readonly views: FieldRef<"CommunityPost", 'Int'>
    readonly isPinned: FieldRef<"CommunityPost", 'Boolean'>
    readonly isAnnouncement: FieldRef<"CommunityPost", 'Boolean'>
    readonly status: FieldRef<"CommunityPost", 'PostStatus'>
    readonly createdAt: FieldRef<"CommunityPost", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityPost", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CommunityPost findUnique
   */
  export type CommunityPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost findUniqueOrThrow
   */
  export type CommunityPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost findFirst
   */
  export type CommunityPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
     */
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }


  /**
   * CommunityPost findFirstOrThrow
   */
  export type CommunityPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
     */
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }


  /**
   * CommunityPost findMany
   */
  export type CommunityPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPosts to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }


  /**
   * CommunityPost create
   */
  export type CommunityPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityPost.
     */
    data: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
  }


  /**
   * CommunityPost createMany
   */
  export type CommunityPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityPosts.
     */
    data: CommunityPostCreateManyInput | CommunityPostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CommunityPost update
   */
  export type CommunityPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityPost.
     */
    data: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
    /**
     * Choose, which CommunityPost to update.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost updateMany
   */
  export type CommunityPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityPosts.
     */
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyInput>
    /**
     * Filter which CommunityPosts to update
     */
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost upsert
   */
  export type CommunityPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityPost to update in case it exists.
     */
    where: CommunityPostWhereUniqueInput
    /**
     * In case the CommunityPost found by the `where` argument doesn't exist, create a new CommunityPost with this data.
     */
    create: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
    /**
     * In case the CommunityPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
  }


  /**
   * CommunityPost delete
   */
  export type CommunityPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter which CommunityPost to delete.
     */
    where: CommunityPostWhereUniqueInput
  }


  /**
   * CommunityPost deleteMany
   */
  export type CommunityPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPosts to delete
     */
    where?: CommunityPostWhereInput
  }


  /**
   * CommunityPost.comments
   */
  export type CommunityPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * CommunityPost without action
   */
  export type CommunityPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommunityPostInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    likes: number | null
  }

  export type CommentSumAggregateOutputType = {
    likes: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    parentId: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    parentId: string | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    parentId: number
    likes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    likes?: true
  }

  export type CommentSumAggregateInputType = {
    likes?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    parentId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    parentId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    parentId?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    content: string
    parentId: string | null
    likes: number
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    parentId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    parentId?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$CommunityPostPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      authorId: string
      content: string
      parentId: string | null
      likes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    post<T extends CommunityPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPostDefaultArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly likes: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }


  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model SecondaryListing
   */

  export type AggregateSecondaryListing = {
    _count: SecondaryListingCountAggregateOutputType | null
    _avg: SecondaryListingAvgAggregateOutputType | null
    _sum: SecondaryListingSumAggregateOutputType | null
    _min: SecondaryListingMinAggregateOutputType | null
    _max: SecondaryListingMaxAggregateOutputType | null
  }

  export type SecondaryListingAvgAggregateOutputType = {
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
  }

  export type SecondaryListingSumAggregateOutputType = {
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
  }

  export type SecondaryListingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sellerId: string | null
    dealInvestorId: string | null
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
    status: $Enums.ListingStatus | null
    listedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryListingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sellerId: string | null
    dealInvestorId: string | null
    sharesAvailable: number | null
    pricePerShare: number | null
    minPurchase: number | null
    status: $Enums.ListingStatus | null
    listedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryListingCountAggregateOutputType = {
    id: number
    tenantId: number
    sellerId: number
    dealInvestorId: number
    sharesAvailable: number
    pricePerShare: number
    minPurchase: number
    status: number
    listedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecondaryListingAvgAggregateInputType = {
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
  }

  export type SecondaryListingSumAggregateInputType = {
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
  }

  export type SecondaryListingMinAggregateInputType = {
    id?: true
    tenantId?: true
    sellerId?: true
    dealInvestorId?: true
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
    status?: true
    listedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryListingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    sellerId?: true
    dealInvestorId?: true
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
    status?: true
    listedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryListingCountAggregateInputType = {
    id?: true
    tenantId?: true
    sellerId?: true
    dealInvestorId?: true
    sharesAvailable?: true
    pricePerShare?: true
    minPurchase?: true
    status?: true
    listedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecondaryListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryListing to aggregate.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecondaryListings
    **/
    _count?: true | SecondaryListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecondaryListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecondaryListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecondaryListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecondaryListingMaxAggregateInputType
  }

  export type GetSecondaryListingAggregateType<T extends SecondaryListingAggregateArgs> = {
        [P in keyof T & keyof AggregateSecondaryListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecondaryListing[P]>
      : GetScalarType<T[P], AggregateSecondaryListing[P]>
  }




  export type SecondaryListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryListingWhereInput
    orderBy?: SecondaryListingOrderByWithAggregationInput | SecondaryListingOrderByWithAggregationInput[]
    by: SecondaryListingScalarFieldEnum[] | SecondaryListingScalarFieldEnum
    having?: SecondaryListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecondaryListingCountAggregateInputType | true
    _avg?: SecondaryListingAvgAggregateInputType
    _sum?: SecondaryListingSumAggregateInputType
    _min?: SecondaryListingMinAggregateInputType
    _max?: SecondaryListingMaxAggregateInputType
  }

  export type SecondaryListingGroupByOutputType = {
    id: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase: number
    status: $Enums.ListingStatus
    listedAt: Date
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SecondaryListingCountAggregateOutputType | null
    _avg: SecondaryListingAvgAggregateOutputType | null
    _sum: SecondaryListingSumAggregateOutputType | null
    _min: SecondaryListingMinAggregateOutputType | null
    _max: SecondaryListingMaxAggregateOutputType | null
  }

  type GetSecondaryListingGroupByPayload<T extends SecondaryListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecondaryListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecondaryListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecondaryListingGroupByOutputType[P]>
            : GetScalarType<T[P], SecondaryListingGroupByOutputType[P]>
        }
      >
    >


  export type SecondaryListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    sellerId?: boolean
    dealInvestorId?: boolean
    sharesAvailable?: boolean
    pricePerShare?: boolean
    minPurchase?: boolean
    status?: boolean
    listedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | InvestorDefaultArgs<ExtArgs>
    dealInvestor?: boolean | DealInvestorDefaultArgs<ExtArgs>
    trades?: boolean | SecondaryListing$tradesArgs<ExtArgs>
    _count?: boolean | SecondaryListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secondaryListing"]>

  export type SecondaryListingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    sellerId?: boolean
    dealInvestorId?: boolean
    sharesAvailable?: boolean
    pricePerShare?: boolean
    minPurchase?: boolean
    status?: boolean
    listedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecondaryListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | InvestorDefaultArgs<ExtArgs>
    dealInvestor?: boolean | DealInvestorDefaultArgs<ExtArgs>
    trades?: boolean | SecondaryListing$tradesArgs<ExtArgs>
    _count?: boolean | SecondaryListingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SecondaryListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecondaryListing"
    objects: {
      seller: Prisma.$InvestorPayload<ExtArgs>
      dealInvestor: Prisma.$DealInvestorPayload<ExtArgs>
      trades: Prisma.$SecondaryTradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      sellerId: string
      dealInvestorId: string
      sharesAvailable: number
      pricePerShare: number
      minPurchase: number
      status: $Enums.ListingStatus
      listedAt: Date
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["secondaryListing"]>
    composites: {}
  }


  type SecondaryListingGetPayload<S extends boolean | null | undefined | SecondaryListingDefaultArgs> = $Result.GetResult<Prisma.$SecondaryListingPayload, S>

  type SecondaryListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecondaryListingFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SecondaryListingCountAggregateInputType | true
    }

  export interface SecondaryListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecondaryListing'], meta: { name: 'SecondaryListing' } }
    /**
     * Find zero or one SecondaryListing that matches the filter.
     * @param {SecondaryListingFindUniqueArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecondaryListingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingFindUniqueArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SecondaryListing that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SecondaryListingFindUniqueOrThrowArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecondaryListingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SecondaryListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingFindFirstArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecondaryListingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindFirstArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SecondaryListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingFindFirstOrThrowArgs} args - Arguments to find a SecondaryListing
     * @example
     * // Get one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecondaryListingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SecondaryListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecondaryListings
     * const secondaryListings = await prisma.secondaryListing.findMany()
     * 
     * // Get first 10 SecondaryListings
     * const secondaryListings = await prisma.secondaryListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const secondaryListingWithIdOnly = await prisma.secondaryListing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecondaryListingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SecondaryListing.
     * @param {SecondaryListingCreateArgs} args - Arguments to create a SecondaryListing.
     * @example
     * // Create one SecondaryListing
     * const SecondaryListing = await prisma.secondaryListing.create({
     *   data: {
     *     // ... data to create a SecondaryListing
     *   }
     * })
     * 
    **/
    create<T extends SecondaryListingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingCreateArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SecondaryListings.
     *     @param {SecondaryListingCreateManyArgs} args - Arguments to create many SecondaryListings.
     *     @example
     *     // Create many SecondaryListings
     *     const secondaryListing = await prisma.secondaryListing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecondaryListingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecondaryListing.
     * @param {SecondaryListingDeleteArgs} args - Arguments to delete one SecondaryListing.
     * @example
     * // Delete one SecondaryListing
     * const SecondaryListing = await prisma.secondaryListing.delete({
     *   where: {
     *     // ... filter to delete one SecondaryListing
     *   }
     * })
     * 
    **/
    delete<T extends SecondaryListingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingDeleteArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SecondaryListing.
     * @param {SecondaryListingUpdateArgs} args - Arguments to update one SecondaryListing.
     * @example
     * // Update one SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecondaryListingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingUpdateArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SecondaryListings.
     * @param {SecondaryListingDeleteManyArgs} args - Arguments to filter SecondaryListings to delete.
     * @example
     * // Delete a few SecondaryListings
     * const { count } = await prisma.secondaryListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecondaryListingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryListingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecondaryListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecondaryListings
     * const secondaryListing = await prisma.secondaryListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecondaryListingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecondaryListing.
     * @param {SecondaryListingUpsertArgs} args - Arguments to update or create a SecondaryListing.
     * @example
     * // Update or create a SecondaryListing
     * const secondaryListing = await prisma.secondaryListing.upsert({
     *   create: {
     *     // ... data to create a SecondaryListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecondaryListing we want to update
     *   }
     * })
    **/
    upsert<T extends SecondaryListingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryListingUpsertArgs<ExtArgs>>
    ): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SecondaryListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingCountArgs} args - Arguments to filter SecondaryListings to count.
     * @example
     * // Count the number of SecondaryListings
     * const count = await prisma.secondaryListing.count({
     *   where: {
     *     // ... the filter for the SecondaryListings we want to count
     *   }
     * })
    **/
    count<T extends SecondaryListingCountArgs>(
      args?: Subset<T, SecondaryListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecondaryListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecondaryListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecondaryListingAggregateArgs>(args: Subset<T, SecondaryListingAggregateArgs>): Prisma.PrismaPromise<GetSecondaryListingAggregateType<T>>

    /**
     * Group by SecondaryListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecondaryListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecondaryListingGroupByArgs['orderBy'] }
        : { orderBy?: SecondaryListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecondaryListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecondaryListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecondaryListing model
   */
  readonly fields: SecondaryListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecondaryListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecondaryListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    seller<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dealInvestor<T extends DealInvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealInvestorDefaultArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    trades<T extends SecondaryListing$tradesArgs<ExtArgs> = {}>(args?: Subset<T, SecondaryListing$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SecondaryListing model
   */ 
  interface SecondaryListingFieldRefs {
    readonly id: FieldRef<"SecondaryListing", 'String'>
    readonly tenantId: FieldRef<"SecondaryListing", 'String'>
    readonly sellerId: FieldRef<"SecondaryListing", 'String'>
    readonly dealInvestorId: FieldRef<"SecondaryListing", 'String'>
    readonly sharesAvailable: FieldRef<"SecondaryListing", 'Float'>
    readonly pricePerShare: FieldRef<"SecondaryListing", 'Float'>
    readonly minPurchase: FieldRef<"SecondaryListing", 'Float'>
    readonly status: FieldRef<"SecondaryListing", 'ListingStatus'>
    readonly listedAt: FieldRef<"SecondaryListing", 'DateTime'>
    readonly expiresAt: FieldRef<"SecondaryListing", 'DateTime'>
    readonly createdAt: FieldRef<"SecondaryListing", 'DateTime'>
    readonly updatedAt: FieldRef<"SecondaryListing", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SecondaryListing findUnique
   */
  export type SecondaryListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing findUniqueOrThrow
   */
  export type SecondaryListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing findFirst
   */
  export type SecondaryListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryListings.
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryListings.
     */
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * SecondaryListing findFirstOrThrow
   */
  export type SecondaryListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListing to fetch.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryListings.
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryListings.
     */
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * SecondaryListing findMany
   */
  export type SecondaryListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryListings to fetch.
     */
    where?: SecondaryListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryListings to fetch.
     */
    orderBy?: SecondaryListingOrderByWithRelationInput | SecondaryListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecondaryListings.
     */
    cursor?: SecondaryListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryListings.
     */
    skip?: number
    distinct?: SecondaryListingScalarFieldEnum | SecondaryListingScalarFieldEnum[]
  }


  /**
   * SecondaryListing create
   */
  export type SecondaryListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * The data needed to create a SecondaryListing.
     */
    data: XOR<SecondaryListingCreateInput, SecondaryListingUncheckedCreateInput>
  }


  /**
   * SecondaryListing createMany
   */
  export type SecondaryListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecondaryListings.
     */
    data: SecondaryListingCreateManyInput | SecondaryListingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SecondaryListing update
   */
  export type SecondaryListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * The data needed to update a SecondaryListing.
     */
    data: XOR<SecondaryListingUpdateInput, SecondaryListingUncheckedUpdateInput>
    /**
     * Choose, which SecondaryListing to update.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing updateMany
   */
  export type SecondaryListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecondaryListings.
     */
    data: XOR<SecondaryListingUpdateManyMutationInput, SecondaryListingUncheckedUpdateManyInput>
    /**
     * Filter which SecondaryListings to update
     */
    where?: SecondaryListingWhereInput
  }


  /**
   * SecondaryListing upsert
   */
  export type SecondaryListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * The filter to search for the SecondaryListing to update in case it exists.
     */
    where: SecondaryListingWhereUniqueInput
    /**
     * In case the SecondaryListing found by the `where` argument doesn't exist, create a new SecondaryListing with this data.
     */
    create: XOR<SecondaryListingCreateInput, SecondaryListingUncheckedCreateInput>
    /**
     * In case the SecondaryListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecondaryListingUpdateInput, SecondaryListingUncheckedUpdateInput>
  }


  /**
   * SecondaryListing delete
   */
  export type SecondaryListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
    /**
     * Filter which SecondaryListing to delete.
     */
    where: SecondaryListingWhereUniqueInput
  }


  /**
   * SecondaryListing deleteMany
   */
  export type SecondaryListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryListings to delete
     */
    where?: SecondaryListingWhereInput
  }


  /**
   * SecondaryListing.trades
   */
  export type SecondaryListing$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    where?: SecondaryTradeWhereInput
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    cursor?: SecondaryTradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryListing without action
   */
  export type SecondaryListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryListing
     */
    select?: SecondaryListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryListingInclude<ExtArgs> | null
  }



  /**
   * Model SecondaryTrade
   */

  export type AggregateSecondaryTrade = {
    _count: SecondaryTradeCountAggregateOutputType | null
    _avg: SecondaryTradeAvgAggregateOutputType | null
    _sum: SecondaryTradeSumAggregateOutputType | null
    _min: SecondaryTradeMinAggregateOutputType | null
    _max: SecondaryTradeMaxAggregateOutputType | null
  }

  export type SecondaryTradeAvgAggregateOutputType = {
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
  }

  export type SecondaryTradeSumAggregateOutputType = {
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
  }

  export type SecondaryTradeMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    buyerId: string | null
    sellerId: string | null
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
    status: $Enums.TradeStatus | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryTradeMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    buyerId: string | null
    sellerId: string | null
    shares: number | null
    pricePerShare: number | null
    totalAmount: number | null
    fee: number | null
    status: $Enums.TradeStatus | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecondaryTradeCountAggregateOutputType = {
    id: number
    listingId: number
    buyerId: number
    sellerId: number
    shares: number
    pricePerShare: number
    totalAmount: number
    fee: number
    status: number
    executedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecondaryTradeAvgAggregateInputType = {
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
  }

  export type SecondaryTradeSumAggregateInputType = {
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
  }

  export type SecondaryTradeMinAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryTradeMaxAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecondaryTradeCountAggregateInputType = {
    id?: true
    listingId?: true
    buyerId?: true
    sellerId?: true
    shares?: true
    pricePerShare?: true
    totalAmount?: true
    fee?: true
    status?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecondaryTradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryTrade to aggregate.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecondaryTrades
    **/
    _count?: true | SecondaryTradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecondaryTradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecondaryTradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecondaryTradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecondaryTradeMaxAggregateInputType
  }

  export type GetSecondaryTradeAggregateType<T extends SecondaryTradeAggregateArgs> = {
        [P in keyof T & keyof AggregateSecondaryTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecondaryTrade[P]>
      : GetScalarType<T[P], AggregateSecondaryTrade[P]>
  }




  export type SecondaryTradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecondaryTradeWhereInput
    orderBy?: SecondaryTradeOrderByWithAggregationInput | SecondaryTradeOrderByWithAggregationInput[]
    by: SecondaryTradeScalarFieldEnum[] | SecondaryTradeScalarFieldEnum
    having?: SecondaryTradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecondaryTradeCountAggregateInputType | true
    _avg?: SecondaryTradeAvgAggregateInputType
    _sum?: SecondaryTradeSumAggregateInputType
    _min?: SecondaryTradeMinAggregateInputType
    _max?: SecondaryTradeMaxAggregateInputType
  }

  export type SecondaryTradeGroupByOutputType = {
    id: string
    listingId: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee: number
    status: $Enums.TradeStatus
    executedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SecondaryTradeCountAggregateOutputType | null
    _avg: SecondaryTradeAvgAggregateOutputType | null
    _sum: SecondaryTradeSumAggregateOutputType | null
    _min: SecondaryTradeMinAggregateOutputType | null
    _max: SecondaryTradeMaxAggregateOutputType | null
  }

  type GetSecondaryTradeGroupByPayload<T extends SecondaryTradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecondaryTradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecondaryTradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecondaryTradeGroupByOutputType[P]>
            : GetScalarType<T[P], SecondaryTradeGroupByOutputType[P]>
        }
      >
    >


  export type SecondaryTradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    shares?: boolean
    pricePerShare?: boolean
    totalAmount?: boolean
    fee?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listing?: boolean | SecondaryListingDefaultArgs<ExtArgs>
    buyer?: boolean | InvestorDefaultArgs<ExtArgs>
    seller?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["secondaryTrade"]>

  export type SecondaryTradeSelectScalar = {
    id?: boolean
    listingId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    shares?: boolean
    pricePerShare?: boolean
    totalAmount?: boolean
    fee?: boolean
    status?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SecondaryTradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | SecondaryListingDefaultArgs<ExtArgs>
    buyer?: boolean | InvestorDefaultArgs<ExtArgs>
    seller?: boolean | InvestorDefaultArgs<ExtArgs>
  }


  export type $SecondaryTradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecondaryTrade"
    objects: {
      listing: Prisma.$SecondaryListingPayload<ExtArgs>
      buyer: Prisma.$InvestorPayload<ExtArgs>
      seller: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      buyerId: string
      sellerId: string
      shares: number
      pricePerShare: number
      totalAmount: number
      fee: number
      status: $Enums.TradeStatus
      executedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["secondaryTrade"]>
    composites: {}
  }


  type SecondaryTradeGetPayload<S extends boolean | null | undefined | SecondaryTradeDefaultArgs> = $Result.GetResult<Prisma.$SecondaryTradePayload, S>

  type SecondaryTradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecondaryTradeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SecondaryTradeCountAggregateInputType | true
    }

  export interface SecondaryTradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecondaryTrade'], meta: { name: 'SecondaryTrade' } }
    /**
     * Find zero or one SecondaryTrade that matches the filter.
     * @param {SecondaryTradeFindUniqueArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecondaryTradeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeFindUniqueArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SecondaryTrade that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SecondaryTradeFindUniqueOrThrowArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecondaryTradeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SecondaryTrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeFindFirstArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecondaryTradeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindFirstArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SecondaryTrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeFindFirstOrThrowArgs} args - Arguments to find a SecondaryTrade
     * @example
     * // Get one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecondaryTradeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SecondaryTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecondaryTrades
     * const secondaryTrades = await prisma.secondaryTrade.findMany()
     * 
     * // Get first 10 SecondaryTrades
     * const secondaryTrades = await prisma.secondaryTrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const secondaryTradeWithIdOnly = await prisma.secondaryTrade.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecondaryTradeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SecondaryTrade.
     * @param {SecondaryTradeCreateArgs} args - Arguments to create a SecondaryTrade.
     * @example
     * // Create one SecondaryTrade
     * const SecondaryTrade = await prisma.secondaryTrade.create({
     *   data: {
     *     // ... data to create a SecondaryTrade
     *   }
     * })
     * 
    **/
    create<T extends SecondaryTradeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeCreateArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SecondaryTrades.
     *     @param {SecondaryTradeCreateManyArgs} args - Arguments to create many SecondaryTrades.
     *     @example
     *     // Create many SecondaryTrades
     *     const secondaryTrade = await prisma.secondaryTrade.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecondaryTradeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SecondaryTrade.
     * @param {SecondaryTradeDeleteArgs} args - Arguments to delete one SecondaryTrade.
     * @example
     * // Delete one SecondaryTrade
     * const SecondaryTrade = await prisma.secondaryTrade.delete({
     *   where: {
     *     // ... filter to delete one SecondaryTrade
     *   }
     * })
     * 
    **/
    delete<T extends SecondaryTradeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeDeleteArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SecondaryTrade.
     * @param {SecondaryTradeUpdateArgs} args - Arguments to update one SecondaryTrade.
     * @example
     * // Update one SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecondaryTradeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeUpdateArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SecondaryTrades.
     * @param {SecondaryTradeDeleteManyArgs} args - Arguments to filter SecondaryTrades to delete.
     * @example
     * // Delete a few SecondaryTrades
     * const { count } = await prisma.secondaryTrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecondaryTradeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SecondaryTradeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecondaryTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecondaryTrades
     * const secondaryTrade = await prisma.secondaryTrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecondaryTradeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecondaryTrade.
     * @param {SecondaryTradeUpsertArgs} args - Arguments to update or create a SecondaryTrade.
     * @example
     * // Update or create a SecondaryTrade
     * const secondaryTrade = await prisma.secondaryTrade.upsert({
     *   create: {
     *     // ... data to create a SecondaryTrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecondaryTrade we want to update
     *   }
     * })
    **/
    upsert<T extends SecondaryTradeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SecondaryTradeUpsertArgs<ExtArgs>>
    ): Prisma__SecondaryTradeClient<$Result.GetResult<Prisma.$SecondaryTradePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SecondaryTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeCountArgs} args - Arguments to filter SecondaryTrades to count.
     * @example
     * // Count the number of SecondaryTrades
     * const count = await prisma.secondaryTrade.count({
     *   where: {
     *     // ... the filter for the SecondaryTrades we want to count
     *   }
     * })
    **/
    count<T extends SecondaryTradeCountArgs>(
      args?: Subset<T, SecondaryTradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecondaryTradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecondaryTrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecondaryTradeAggregateArgs>(args: Subset<T, SecondaryTradeAggregateArgs>): Prisma.PrismaPromise<GetSecondaryTradeAggregateType<T>>

    /**
     * Group by SecondaryTrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecondaryTradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecondaryTradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecondaryTradeGroupByArgs['orderBy'] }
        : { orderBy?: SecondaryTradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecondaryTradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecondaryTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecondaryTrade model
   */
  readonly fields: SecondaryTradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecondaryTrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecondaryTradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    listing<T extends SecondaryListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SecondaryListingDefaultArgs<ExtArgs>>): Prisma__SecondaryListingClient<$Result.GetResult<Prisma.$SecondaryListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    buyer<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    seller<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SecondaryTrade model
   */ 
  interface SecondaryTradeFieldRefs {
    readonly id: FieldRef<"SecondaryTrade", 'String'>
    readonly listingId: FieldRef<"SecondaryTrade", 'String'>
    readonly buyerId: FieldRef<"SecondaryTrade", 'String'>
    readonly sellerId: FieldRef<"SecondaryTrade", 'String'>
    readonly shares: FieldRef<"SecondaryTrade", 'Float'>
    readonly pricePerShare: FieldRef<"SecondaryTrade", 'Float'>
    readonly totalAmount: FieldRef<"SecondaryTrade", 'Float'>
    readonly fee: FieldRef<"SecondaryTrade", 'Float'>
    readonly status: FieldRef<"SecondaryTrade", 'TradeStatus'>
    readonly executedAt: FieldRef<"SecondaryTrade", 'DateTime'>
    readonly createdAt: FieldRef<"SecondaryTrade", 'DateTime'>
    readonly updatedAt: FieldRef<"SecondaryTrade", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SecondaryTrade findUnique
   */
  export type SecondaryTradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade findUniqueOrThrow
   */
  export type SecondaryTradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade findFirst
   */
  export type SecondaryTradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryTrades.
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryTrades.
     */
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryTrade findFirstOrThrow
   */
  export type SecondaryTradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrade to fetch.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecondaryTrades.
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecondaryTrades.
     */
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryTrade findMany
   */
  export type SecondaryTradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter, which SecondaryTrades to fetch.
     */
    where?: SecondaryTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecondaryTrades to fetch.
     */
    orderBy?: SecondaryTradeOrderByWithRelationInput | SecondaryTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecondaryTrades.
     */
    cursor?: SecondaryTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecondaryTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecondaryTrades.
     */
    skip?: number
    distinct?: SecondaryTradeScalarFieldEnum | SecondaryTradeScalarFieldEnum[]
  }


  /**
   * SecondaryTrade create
   */
  export type SecondaryTradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * The data needed to create a SecondaryTrade.
     */
    data: XOR<SecondaryTradeCreateInput, SecondaryTradeUncheckedCreateInput>
  }


  /**
   * SecondaryTrade createMany
   */
  export type SecondaryTradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecondaryTrades.
     */
    data: SecondaryTradeCreateManyInput | SecondaryTradeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SecondaryTrade update
   */
  export type SecondaryTradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * The data needed to update a SecondaryTrade.
     */
    data: XOR<SecondaryTradeUpdateInput, SecondaryTradeUncheckedUpdateInput>
    /**
     * Choose, which SecondaryTrade to update.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade updateMany
   */
  export type SecondaryTradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecondaryTrades.
     */
    data: XOR<SecondaryTradeUpdateManyMutationInput, SecondaryTradeUncheckedUpdateManyInput>
    /**
     * Filter which SecondaryTrades to update
     */
    where?: SecondaryTradeWhereInput
  }


  /**
   * SecondaryTrade upsert
   */
  export type SecondaryTradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * The filter to search for the SecondaryTrade to update in case it exists.
     */
    where: SecondaryTradeWhereUniqueInput
    /**
     * In case the SecondaryTrade found by the `where` argument doesn't exist, create a new SecondaryTrade with this data.
     */
    create: XOR<SecondaryTradeCreateInput, SecondaryTradeUncheckedCreateInput>
    /**
     * In case the SecondaryTrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecondaryTradeUpdateInput, SecondaryTradeUncheckedUpdateInput>
  }


  /**
   * SecondaryTrade delete
   */
  export type SecondaryTradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
    /**
     * Filter which SecondaryTrade to delete.
     */
    where: SecondaryTradeWhereUniqueInput
  }


  /**
   * SecondaryTrade deleteMany
   */
  export type SecondaryTradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecondaryTrades to delete
     */
    where?: SecondaryTradeWhereInput
  }


  /**
   * SecondaryTrade without action
   */
  export type SecondaryTradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecondaryTrade
     */
    select?: SecondaryTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SecondaryTradeInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    type: number
    title: number
    message: number
    read: number
    actionUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read: boolean
    actionUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      read: boolean
      actionUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    dealId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    dealId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    tenantId: number
    dealId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    tenantId?: true
    dealId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    dealId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    tenantId?: true
    dealId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    tenantId: string
    dealId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    dealId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    deal?: boolean | Conversation$dealArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    dealId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    deal?: boolean | Conversation$dealArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      messages: Prisma.$MessagePayload<ExtArgs>[]
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      dealId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }


  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
    **/
    create<T extends ConversationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations.
     *     @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversation = await prisma.conversation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
    **/
    delete<T extends ConversationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    deal<T extends Conversation$dealArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly tenantId: FieldRef<"Conversation", 'String'>
    readonly dealId: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }


  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }


  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation.deal
   */
  export type Conversation$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }


  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }


  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
  }



  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    lastReadAt: number
    joinedAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    lastReadAt?: true
    joinedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    lastReadAt: Date
    joinedAt: Date
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
  }

  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      lastReadAt: Date
      joinedAt: Date
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }


  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationParticipantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationParticipantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationParticipantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
    **/
    create<T extends ConversationParticipantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConversationParticipants.
     *     @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     *     @example
     *     // Create many ConversationParticipants
     *     const conversationParticipant = await prisma.conversationParticipant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationParticipantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
    **/
    delete<T extends ConversationParticipantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationParticipantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationParticipantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationParticipantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationParticipantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>
    ): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ConversationParticipant model
   */ 
  interface ConversationParticipantFieldRefs {
    readonly id: FieldRef<"ConversationParticipant", 'String'>
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly userId: FieldRef<"ConversationParticipant", 'String'>
    readonly lastReadAt: FieldRef<"ConversationParticipant", 'DateTime'>
    readonly joinedAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }


  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }


  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }


  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }


  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }


  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }


  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }


  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
  }


  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }


  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }


  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
  }


  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Model AdvisoryService
   */

  export type AggregateAdvisoryService = {
    _count: AdvisoryServiceCountAggregateOutputType | null
    _avg: AdvisoryServiceAvgAggregateOutputType | null
    _sum: AdvisoryServiceSumAggregateOutputType | null
    _min: AdvisoryServiceMinAggregateOutputType | null
    _max: AdvisoryServiceMaxAggregateOutputType | null
  }

  export type AdvisoryServiceAvgAggregateOutputType = {
    price: number | null
  }

  export type AdvisoryServiceSumAggregateOutputType = {
    price: number | null
  }

  export type AdvisoryServiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    advisorId: string | null
    name: string | null
    category: string | null
    description: string | null
    price: number | null
    duration: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisoryServiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    advisorId: string | null
    name: string | null
    category: string | null
    description: string | null
    price: number | null
    duration: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisoryServiceCountAggregateOutputType = {
    id: number
    tenantId: number
    advisorId: number
    name: number
    category: number
    description: number
    price: number
    duration: number
    features: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdvisoryServiceAvgAggregateInputType = {
    price?: true
  }

  export type AdvisoryServiceSumAggregateInputType = {
    price?: true
  }

  export type AdvisoryServiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    advisorId?: true
    name?: true
    category?: true
    description?: true
    price?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisoryServiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    advisorId?: true
    name?: true
    category?: true
    description?: true
    price?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisoryServiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    advisorId?: true
    name?: true
    category?: true
    description?: true
    price?: true
    duration?: true
    features?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdvisoryServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvisoryService to aggregate.
     */
    where?: AdvisoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvisoryServices to fetch.
     */
    orderBy?: AdvisoryServiceOrderByWithRelationInput | AdvisoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvisoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvisoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvisoryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvisoryServices
    **/
    _count?: true | AdvisoryServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvisoryServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvisoryServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvisoryServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvisoryServiceMaxAggregateInputType
  }

  export type GetAdvisoryServiceAggregateType<T extends AdvisoryServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvisoryService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvisoryService[P]>
      : GetScalarType<T[P], AggregateAdvisoryService[P]>
  }




  export type AdvisoryServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisoryServiceWhereInput
    orderBy?: AdvisoryServiceOrderByWithAggregationInput | AdvisoryServiceOrderByWithAggregationInput[]
    by: AdvisoryServiceScalarFieldEnum[] | AdvisoryServiceScalarFieldEnum
    having?: AdvisoryServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvisoryServiceCountAggregateInputType | true
    _avg?: AdvisoryServiceAvgAggregateInputType
    _sum?: AdvisoryServiceSumAggregateInputType
    _min?: AdvisoryServiceMinAggregateInputType
    _max?: AdvisoryServiceMaxAggregateInputType
  }

  export type AdvisoryServiceGroupByOutputType = {
    id: string
    tenantId: string
    advisorId: string
    name: string
    category: string
    description: string | null
    price: number
    duration: string
    features: string[]
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AdvisoryServiceCountAggregateOutputType | null
    _avg: AdvisoryServiceAvgAggregateOutputType | null
    _sum: AdvisoryServiceSumAggregateOutputType | null
    _min: AdvisoryServiceMinAggregateOutputType | null
    _max: AdvisoryServiceMaxAggregateOutputType | null
  }

  type GetAdvisoryServiceGroupByPayload<T extends AdvisoryServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvisoryServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvisoryServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvisoryServiceGroupByOutputType[P]>
            : GetScalarType<T[P], AdvisoryServiceGroupByOutputType[P]>
        }
      >
    >


  export type AdvisoryServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    advisorId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
    bookings?: boolean | AdvisoryService$bookingsArgs<ExtArgs>
    _count?: boolean | AdvisoryServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advisoryService"]>

  export type AdvisoryServiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    advisorId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdvisoryServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
    bookings?: boolean | AdvisoryService$bookingsArgs<ExtArgs>
    _count?: boolean | AdvisoryServiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdvisoryServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvisoryService"
    objects: {
      advisor: Prisma.$AdvisorPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      advisorId: string
      name: string
      category: string
      description: string | null
      price: number
      duration: string
      features: string[]
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["advisoryService"]>
    composites: {}
  }


  type AdvisoryServiceGetPayload<S extends boolean | null | undefined | AdvisoryServiceDefaultArgs> = $Result.GetResult<Prisma.$AdvisoryServicePayload, S>

  type AdvisoryServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvisoryServiceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdvisoryServiceCountAggregateInputType | true
    }

  export interface AdvisoryServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvisoryService'], meta: { name: 'AdvisoryService' } }
    /**
     * Find zero or one AdvisoryService that matches the filter.
     * @param {AdvisoryServiceFindUniqueArgs} args - Arguments to find a AdvisoryService
     * @example
     * // Get one AdvisoryService
     * const advisoryService = await prisma.advisoryService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvisoryServiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisoryServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdvisoryService that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdvisoryServiceFindUniqueOrThrowArgs} args - Arguments to find a AdvisoryService
     * @example
     * // Get one AdvisoryService
     * const advisoryService = await prisma.advisoryService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdvisoryServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisoryServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdvisoryService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceFindFirstArgs} args - Arguments to find a AdvisoryService
     * @example
     * // Get one AdvisoryService
     * const advisoryService = await prisma.advisoryService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvisoryServiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisoryServiceFindFirstArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdvisoryService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceFindFirstOrThrowArgs} args - Arguments to find a AdvisoryService
     * @example
     * // Get one AdvisoryService
     * const advisoryService = await prisma.advisoryService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdvisoryServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisoryServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdvisoryServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvisoryServices
     * const advisoryServices = await prisma.advisoryService.findMany()
     * 
     * // Get first 10 AdvisoryServices
     * const advisoryServices = await prisma.advisoryService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advisoryServiceWithIdOnly = await prisma.advisoryService.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdvisoryServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisoryServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdvisoryService.
     * @param {AdvisoryServiceCreateArgs} args - Arguments to create a AdvisoryService.
     * @example
     * // Create one AdvisoryService
     * const AdvisoryService = await prisma.advisoryService.create({
     *   data: {
     *     // ... data to create a AdvisoryService
     *   }
     * })
     * 
    **/
    create<T extends AdvisoryServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisoryServiceCreateArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdvisoryServices.
     *     @param {AdvisoryServiceCreateManyArgs} args - Arguments to create many AdvisoryServices.
     *     @example
     *     // Create many AdvisoryServices
     *     const advisoryService = await prisma.advisoryService.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvisoryServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisoryServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdvisoryService.
     * @param {AdvisoryServiceDeleteArgs} args - Arguments to delete one AdvisoryService.
     * @example
     * // Delete one AdvisoryService
     * const AdvisoryService = await prisma.advisoryService.delete({
     *   where: {
     *     // ... filter to delete one AdvisoryService
     *   }
     * })
     * 
    **/
    delete<T extends AdvisoryServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisoryServiceDeleteArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdvisoryService.
     * @param {AdvisoryServiceUpdateArgs} args - Arguments to update one AdvisoryService.
     * @example
     * // Update one AdvisoryService
     * const advisoryService = await prisma.advisoryService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvisoryServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisoryServiceUpdateArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdvisoryServices.
     * @param {AdvisoryServiceDeleteManyArgs} args - Arguments to filter AdvisoryServices to delete.
     * @example
     * // Delete a few AdvisoryServices
     * const { count } = await prisma.advisoryService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvisoryServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvisoryServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvisoryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvisoryServices
     * const advisoryService = await prisma.advisoryService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvisoryServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisoryServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdvisoryService.
     * @param {AdvisoryServiceUpsertArgs} args - Arguments to update or create a AdvisoryService.
     * @example
     * // Update or create a AdvisoryService
     * const advisoryService = await prisma.advisoryService.upsert({
     *   create: {
     *     // ... data to create a AdvisoryService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvisoryService we want to update
     *   }
     * })
    **/
    upsert<T extends AdvisoryServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdvisoryServiceUpsertArgs<ExtArgs>>
    ): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AdvisoryServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceCountArgs} args - Arguments to filter AdvisoryServices to count.
     * @example
     * // Count the number of AdvisoryServices
     * const count = await prisma.advisoryService.count({
     *   where: {
     *     // ... the filter for the AdvisoryServices we want to count
     *   }
     * })
    **/
    count<T extends AdvisoryServiceCountArgs>(
      args?: Subset<T, AdvisoryServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvisoryServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvisoryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvisoryServiceAggregateArgs>(args: Subset<T, AdvisoryServiceAggregateArgs>): Prisma.PrismaPromise<GetAdvisoryServiceAggregateType<T>>

    /**
     * Group by AdvisoryService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisoryServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvisoryServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvisoryServiceGroupByArgs['orderBy'] }
        : { orderBy?: AdvisoryServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvisoryServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvisoryServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvisoryService model
   */
  readonly fields: AdvisoryServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvisoryService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvisoryServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    advisor<T extends AdvisorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvisorDefaultArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bookings<T extends AdvisoryService$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, AdvisoryService$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdvisoryService model
   */ 
  interface AdvisoryServiceFieldRefs {
    readonly id: FieldRef<"AdvisoryService", 'String'>
    readonly tenantId: FieldRef<"AdvisoryService", 'String'>
    readonly advisorId: FieldRef<"AdvisoryService", 'String'>
    readonly name: FieldRef<"AdvisoryService", 'String'>
    readonly category: FieldRef<"AdvisoryService", 'String'>
    readonly description: FieldRef<"AdvisoryService", 'String'>
    readonly price: FieldRef<"AdvisoryService", 'Float'>
    readonly duration: FieldRef<"AdvisoryService", 'String'>
    readonly features: FieldRef<"AdvisoryService", 'String[]'>
    readonly status: FieldRef<"AdvisoryService", 'String'>
    readonly createdAt: FieldRef<"AdvisoryService", 'DateTime'>
    readonly updatedAt: FieldRef<"AdvisoryService", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AdvisoryService findUnique
   */
  export type AdvisoryServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which AdvisoryService to fetch.
     */
    where: AdvisoryServiceWhereUniqueInput
  }


  /**
   * AdvisoryService findUniqueOrThrow
   */
  export type AdvisoryServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which AdvisoryService to fetch.
     */
    where: AdvisoryServiceWhereUniqueInput
  }


  /**
   * AdvisoryService findFirst
   */
  export type AdvisoryServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which AdvisoryService to fetch.
     */
    where?: AdvisoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvisoryServices to fetch.
     */
    orderBy?: AdvisoryServiceOrderByWithRelationInput | AdvisoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvisoryServices.
     */
    cursor?: AdvisoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvisoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvisoryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvisoryServices.
     */
    distinct?: AdvisoryServiceScalarFieldEnum | AdvisoryServiceScalarFieldEnum[]
  }


  /**
   * AdvisoryService findFirstOrThrow
   */
  export type AdvisoryServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which AdvisoryService to fetch.
     */
    where?: AdvisoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvisoryServices to fetch.
     */
    orderBy?: AdvisoryServiceOrderByWithRelationInput | AdvisoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvisoryServices.
     */
    cursor?: AdvisoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvisoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvisoryServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvisoryServices.
     */
    distinct?: AdvisoryServiceScalarFieldEnum | AdvisoryServiceScalarFieldEnum[]
  }


  /**
   * AdvisoryService findMany
   */
  export type AdvisoryServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * Filter, which AdvisoryServices to fetch.
     */
    where?: AdvisoryServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvisoryServices to fetch.
     */
    orderBy?: AdvisoryServiceOrderByWithRelationInput | AdvisoryServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvisoryServices.
     */
    cursor?: AdvisoryServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvisoryServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvisoryServices.
     */
    skip?: number
    distinct?: AdvisoryServiceScalarFieldEnum | AdvisoryServiceScalarFieldEnum[]
  }


  /**
   * AdvisoryService create
   */
  export type AdvisoryServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a AdvisoryService.
     */
    data: XOR<AdvisoryServiceCreateInput, AdvisoryServiceUncheckedCreateInput>
  }


  /**
   * AdvisoryService createMany
   */
  export type AdvisoryServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvisoryServices.
     */
    data: AdvisoryServiceCreateManyInput | AdvisoryServiceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AdvisoryService update
   */
  export type AdvisoryServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a AdvisoryService.
     */
    data: XOR<AdvisoryServiceUpdateInput, AdvisoryServiceUncheckedUpdateInput>
    /**
     * Choose, which AdvisoryService to update.
     */
    where: AdvisoryServiceWhereUniqueInput
  }


  /**
   * AdvisoryService updateMany
   */
  export type AdvisoryServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvisoryServices.
     */
    data: XOR<AdvisoryServiceUpdateManyMutationInput, AdvisoryServiceUncheckedUpdateManyInput>
    /**
     * Filter which AdvisoryServices to update
     */
    where?: AdvisoryServiceWhereInput
  }


  /**
   * AdvisoryService upsert
   */
  export type AdvisoryServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the AdvisoryService to update in case it exists.
     */
    where: AdvisoryServiceWhereUniqueInput
    /**
     * In case the AdvisoryService found by the `where` argument doesn't exist, create a new AdvisoryService with this data.
     */
    create: XOR<AdvisoryServiceCreateInput, AdvisoryServiceUncheckedCreateInput>
    /**
     * In case the AdvisoryService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvisoryServiceUpdateInput, AdvisoryServiceUncheckedUpdateInput>
  }


  /**
   * AdvisoryService delete
   */
  export type AdvisoryServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    /**
     * Filter which AdvisoryService to delete.
     */
    where: AdvisoryServiceWhereUniqueInput
  }


  /**
   * AdvisoryService deleteMany
   */
  export type AdvisoryServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvisoryServices to delete
     */
    where?: AdvisoryServiceWhereInput
  }


  /**
   * AdvisoryService.bookings
   */
  export type AdvisoryService$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }


  /**
   * AdvisoryService without action
   */
  export type AdvisoryServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
  }



  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    amount: number | null
  }

  export type BookingSumAggregateOutputType = {
    amount: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    advisorId: string | null
    serviceId: string | null
    preferredDate: Date | null
    notes: string | null
    status: $Enums.BookingStatus | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    advisorId: string | null
    serviceId: string | null
    preferredDate: Date | null
    notes: string | null
    status: $Enums.BookingStatus | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    advisorId: number
    serviceId: number
    preferredDate: number
    notes: number
    status: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    amount?: true
  }

  export type BookingSumAggregateInputType = {
    amount?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    advisorId?: true
    serviceId?: true
    preferredDate?: true
    notes?: true
    status?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    advisorId?: true
    serviceId?: true
    preferredDate?: true
    notes?: true
    status?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    advisorId?: true
    serviceId?: true
    preferredDate?: true
    notes?: true
    status?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    advisorId: string | null
    serviceId: string | null
    preferredDate: Date
    notes: string | null
    status: $Enums.BookingStatus
    amount: number | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    advisorId?: boolean
    serviceId?: boolean
    preferredDate?: boolean
    notes?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    advisor?: boolean | Booking$advisorArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    advisorId?: boolean
    serviceId?: boolean
    preferredDate?: boolean
    notes?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    advisor?: boolean | Booking$advisorArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
      service: Prisma.$AdvisoryServicePayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      advisorId: string | null
      serviceId: string | null
      preferredDate: Date
      notes: string | null
      status: $Enums.BookingStatus
      amount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }


  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
    **/
    create<T extends BookingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BookingCreateArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bookings.
     *     @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     *     @example
     *     // Create many Bookings
     *     const booking = await prisma.booking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
    **/
    delete<T extends BookingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
    **/
    upsert<T extends BookingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>
    ): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    advisor<T extends Booking$advisorArgs<ExtArgs> = {}>(args?: Subset<T, Booking$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    service<T extends Booking$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$serviceArgs<ExtArgs>>): Prisma__AdvisoryServiceClient<$Result.GetResult<Prisma.$AdvisoryServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly tenantId: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly advisorId: FieldRef<"Booking", 'String'>
    readonly serviceId: FieldRef<"Booking", 'String'>
    readonly preferredDate: FieldRef<"Booking", 'DateTime'>
    readonly notes: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly amount: FieldRef<"Booking", 'Float'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }


  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }


  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }


  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }


  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }


  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }


  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }


  /**
   * Booking.advisor
   */
  export type Booking$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }


  /**
   * Booking.service
   */
  export type Booking$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisoryService
     */
    select?: AdvisoryServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvisoryServiceInclude<ExtArgs> | null
    where?: AdvisoryServiceWhereInput
  }


  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
  }



  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    score: number | null
  }

  export type MatchSumAggregateOutputType = {
    score: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    investorId: string | null
    score: number | null
    status: $Enums.MatchStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    investorId: string | null
    score: number | null
    status: $Enums.MatchStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    tenantId: number
    smeId: number
    investorId: number
    score: number
    factors: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    score?: true
  }

  export type MatchSumAggregateInputType = {
    score?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    investorId?: true
    score?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    investorId?: true
    score?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    investorId?: true
    score?: true
    factors?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    tenantId: string
    smeId: string
    investorId: string
    score: number
    factors: JsonValue | null
    status: $Enums.MatchStatus
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    investorId?: boolean
    score?: boolean
    factors?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    interests?: boolean | Match$interestsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    investorId?: boolean
    score?: boolean
    factors?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    interests?: boolean | Match$interestsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs>
      investor: Prisma.$InvestorPayload<ExtArgs>
      interests: Prisma.$MatchInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      smeId: string
      investorId: string
      score: number
      factors: Prisma.JsonValue | null
      status: $Enums.MatchStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }


  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MatchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Match that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MatchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MatchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
    **/
    create<T extends MatchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MatchCreateArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Matches.
     *     @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     *     @example
     *     // Create many Matches
     *     const match = await prisma.match.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MatchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
    **/
    delete<T extends MatchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MatchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MatchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MatchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
    **/
    upsert<T extends MatchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>
    ): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    interests<T extends Match$interestsArgs<ExtArgs> = {}>(args?: Subset<T, Match$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Match model
   */ 
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly tenantId: FieldRef<"Match", 'String'>
    readonly smeId: FieldRef<"Match", 'String'>
    readonly investorId: FieldRef<"Match", 'String'>
    readonly score: FieldRef<"Match", 'Int'>
    readonly factors: FieldRef<"Match", 'Json'>
    readonly status: FieldRef<"Match", 'MatchStatus'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }


  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }


  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }


  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }


  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }


  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }


  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }


  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
  }


  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }


  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }


  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
  }


  /**
   * Match.interests
   */
  export type Match$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    where?: MatchInterestWhereInput
    orderBy?: MatchInterestOrderByWithRelationInput | MatchInterestOrderByWithRelationInput[]
    cursor?: MatchInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchInterestScalarFieldEnum | MatchInterestScalarFieldEnum[]
  }


  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInclude<ExtArgs> | null
  }



  /**
   * Model MatchInterest
   */

  export type AggregateMatchInterest = {
    _count: MatchInterestCountAggregateOutputType | null
    _min: MatchInterestMinAggregateOutputType | null
    _max: MatchInterestMaxAggregateOutputType | null
  }

  export type MatchInterestMinAggregateOutputType = {
    id: string | null
    matchId: string | null
    userId: string | null
    interest: boolean | null
    createdAt: Date | null
  }

  export type MatchInterestMaxAggregateOutputType = {
    id: string | null
    matchId: string | null
    userId: string | null
    interest: boolean | null
    createdAt: Date | null
  }

  export type MatchInterestCountAggregateOutputType = {
    id: number
    matchId: number
    userId: number
    interest: number
    createdAt: number
    _all: number
  }


  export type MatchInterestMinAggregateInputType = {
    id?: true
    matchId?: true
    userId?: true
    interest?: true
    createdAt?: true
  }

  export type MatchInterestMaxAggregateInputType = {
    id?: true
    matchId?: true
    userId?: true
    interest?: true
    createdAt?: true
  }

  export type MatchInterestCountAggregateInputType = {
    id?: true
    matchId?: true
    userId?: true
    interest?: true
    createdAt?: true
    _all?: true
  }

  export type MatchInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchInterest to aggregate.
     */
    where?: MatchInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchInterests to fetch.
     */
    orderBy?: MatchInterestOrderByWithRelationInput | MatchInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchInterests
    **/
    _count?: true | MatchInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchInterestMaxAggregateInputType
  }

  export type GetMatchInterestAggregateType<T extends MatchInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchInterest[P]>
      : GetScalarType<T[P], AggregateMatchInterest[P]>
  }




  export type MatchInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchInterestWhereInput
    orderBy?: MatchInterestOrderByWithAggregationInput | MatchInterestOrderByWithAggregationInput[]
    by: MatchInterestScalarFieldEnum[] | MatchInterestScalarFieldEnum
    having?: MatchInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchInterestCountAggregateInputType | true
    _min?: MatchInterestMinAggregateInputType
    _max?: MatchInterestMaxAggregateInputType
  }

  export type MatchInterestGroupByOutputType = {
    id: string
    matchId: string
    userId: string
    interest: boolean
    createdAt: Date
    _count: MatchInterestCountAggregateOutputType | null
    _min: MatchInterestMinAggregateOutputType | null
    _max: MatchInterestMaxAggregateOutputType | null
  }

  type GetMatchInterestGroupByPayload<T extends MatchInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchInterestGroupByOutputType[P]>
            : GetScalarType<T[P], MatchInterestGroupByOutputType[P]>
        }
      >
    >


  export type MatchInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    userId?: boolean
    interest?: boolean
    createdAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchInterest"]>

  export type MatchInterestSelectScalar = {
    id?: boolean
    matchId?: boolean
    userId?: boolean
    interest?: boolean
    createdAt?: boolean
  }

  export type MatchInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $MatchInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchInterest"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matchId: string
      userId: string
      interest: boolean
      createdAt: Date
    }, ExtArgs["result"]["matchInterest"]>
    composites: {}
  }


  type MatchInterestGetPayload<S extends boolean | null | undefined | MatchInterestDefaultArgs> = $Result.GetResult<Prisma.$MatchInterestPayload, S>

  type MatchInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchInterestFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MatchInterestCountAggregateInputType | true
    }

  export interface MatchInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchInterest'], meta: { name: 'MatchInterest' } }
    /**
     * Find zero or one MatchInterest that matches the filter.
     * @param {MatchInterestFindUniqueArgs} args - Arguments to find a MatchInterest
     * @example
     * // Get one MatchInterest
     * const matchInterest = await prisma.matchInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MatchInterestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MatchInterestFindUniqueArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MatchInterest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MatchInterestFindUniqueOrThrowArgs} args - Arguments to find a MatchInterest
     * @example
     * // Get one MatchInterest
     * const matchInterest = await prisma.matchInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MatchInterestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchInterestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MatchInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestFindFirstArgs} args - Arguments to find a MatchInterest
     * @example
     * // Get one MatchInterest
     * const matchInterest = await prisma.matchInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MatchInterestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchInterestFindFirstArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MatchInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestFindFirstOrThrowArgs} args - Arguments to find a MatchInterest
     * @example
     * // Get one MatchInterest
     * const matchInterest = await prisma.matchInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MatchInterestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchInterestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MatchInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchInterests
     * const matchInterests = await prisma.matchInterest.findMany()
     * 
     * // Get first 10 MatchInterests
     * const matchInterests = await prisma.matchInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchInterestWithIdOnly = await prisma.matchInterest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MatchInterestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchInterestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MatchInterest.
     * @param {MatchInterestCreateArgs} args - Arguments to create a MatchInterest.
     * @example
     * // Create one MatchInterest
     * const MatchInterest = await prisma.matchInterest.create({
     *   data: {
     *     // ... data to create a MatchInterest
     *   }
     * })
     * 
    **/
    create<T extends MatchInterestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MatchInterestCreateArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MatchInterests.
     *     @param {MatchInterestCreateManyArgs} args - Arguments to create many MatchInterests.
     *     @example
     *     // Create many MatchInterests
     *     const matchInterest = await prisma.matchInterest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MatchInterestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchInterestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MatchInterest.
     * @param {MatchInterestDeleteArgs} args - Arguments to delete one MatchInterest.
     * @example
     * // Delete one MatchInterest
     * const MatchInterest = await prisma.matchInterest.delete({
     *   where: {
     *     // ... filter to delete one MatchInterest
     *   }
     * })
     * 
    **/
    delete<T extends MatchInterestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MatchInterestDeleteArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MatchInterest.
     * @param {MatchInterestUpdateArgs} args - Arguments to update one MatchInterest.
     * @example
     * // Update one MatchInterest
     * const matchInterest = await prisma.matchInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MatchInterestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MatchInterestUpdateArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MatchInterests.
     * @param {MatchInterestDeleteManyArgs} args - Arguments to filter MatchInterests to delete.
     * @example
     * // Delete a few MatchInterests
     * const { count } = await prisma.matchInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MatchInterestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatchInterestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchInterests
     * const matchInterest = await prisma.matchInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MatchInterestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MatchInterestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchInterest.
     * @param {MatchInterestUpsertArgs} args - Arguments to update or create a MatchInterest.
     * @example
     * // Update or create a MatchInterest
     * const matchInterest = await prisma.matchInterest.upsert({
     *   create: {
     *     // ... data to create a MatchInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchInterest we want to update
     *   }
     * })
    **/
    upsert<T extends MatchInterestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MatchInterestUpsertArgs<ExtArgs>>
    ): Prisma__MatchInterestClient<$Result.GetResult<Prisma.$MatchInterestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MatchInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestCountArgs} args - Arguments to filter MatchInterests to count.
     * @example
     * // Count the number of MatchInterests
     * const count = await prisma.matchInterest.count({
     *   where: {
     *     // ... the filter for the MatchInterests we want to count
     *   }
     * })
    **/
    count<T extends MatchInterestCountArgs>(
      args?: Subset<T, MatchInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchInterestAggregateArgs>(args: Subset<T, MatchInterestAggregateArgs>): Prisma.PrismaPromise<GetMatchInterestAggregateType<T>>

    /**
     * Group by MatchInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchInterestGroupByArgs['orderBy'] }
        : { orderBy?: MatchInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchInterest model
   */
  readonly fields: MatchInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MatchInterest model
   */ 
  interface MatchInterestFieldRefs {
    readonly id: FieldRef<"MatchInterest", 'String'>
    readonly matchId: FieldRef<"MatchInterest", 'String'>
    readonly userId: FieldRef<"MatchInterest", 'String'>
    readonly interest: FieldRef<"MatchInterest", 'Boolean'>
    readonly createdAt: FieldRef<"MatchInterest", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MatchInterest findUnique
   */
  export type MatchInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * Filter, which MatchInterest to fetch.
     */
    where: MatchInterestWhereUniqueInput
  }


  /**
   * MatchInterest findUniqueOrThrow
   */
  export type MatchInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * Filter, which MatchInterest to fetch.
     */
    where: MatchInterestWhereUniqueInput
  }


  /**
   * MatchInterest findFirst
   */
  export type MatchInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * Filter, which MatchInterest to fetch.
     */
    where?: MatchInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchInterests to fetch.
     */
    orderBy?: MatchInterestOrderByWithRelationInput | MatchInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchInterests.
     */
    cursor?: MatchInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchInterests.
     */
    distinct?: MatchInterestScalarFieldEnum | MatchInterestScalarFieldEnum[]
  }


  /**
   * MatchInterest findFirstOrThrow
   */
  export type MatchInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * Filter, which MatchInterest to fetch.
     */
    where?: MatchInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchInterests to fetch.
     */
    orderBy?: MatchInterestOrderByWithRelationInput | MatchInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchInterests.
     */
    cursor?: MatchInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchInterests.
     */
    distinct?: MatchInterestScalarFieldEnum | MatchInterestScalarFieldEnum[]
  }


  /**
   * MatchInterest findMany
   */
  export type MatchInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * Filter, which MatchInterests to fetch.
     */
    where?: MatchInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchInterests to fetch.
     */
    orderBy?: MatchInterestOrderByWithRelationInput | MatchInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchInterests.
     */
    cursor?: MatchInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchInterests.
     */
    skip?: number
    distinct?: MatchInterestScalarFieldEnum | MatchInterestScalarFieldEnum[]
  }


  /**
   * MatchInterest create
   */
  export type MatchInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchInterest.
     */
    data: XOR<MatchInterestCreateInput, MatchInterestUncheckedCreateInput>
  }


  /**
   * MatchInterest createMany
   */
  export type MatchInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchInterests.
     */
    data: MatchInterestCreateManyInput | MatchInterestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MatchInterest update
   */
  export type MatchInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchInterest.
     */
    data: XOR<MatchInterestUpdateInput, MatchInterestUncheckedUpdateInput>
    /**
     * Choose, which MatchInterest to update.
     */
    where: MatchInterestWhereUniqueInput
  }


  /**
   * MatchInterest updateMany
   */
  export type MatchInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchInterests.
     */
    data: XOR<MatchInterestUpdateManyMutationInput, MatchInterestUncheckedUpdateManyInput>
    /**
     * Filter which MatchInterests to update
     */
    where?: MatchInterestWhereInput
  }


  /**
   * MatchInterest upsert
   */
  export type MatchInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchInterest to update in case it exists.
     */
    where: MatchInterestWhereUniqueInput
    /**
     * In case the MatchInterest found by the `where` argument doesn't exist, create a new MatchInterest with this data.
     */
    create: XOR<MatchInterestCreateInput, MatchInterestUncheckedCreateInput>
    /**
     * In case the MatchInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchInterestUpdateInput, MatchInterestUncheckedUpdateInput>
  }


  /**
   * MatchInterest delete
   */
  export type MatchInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
    /**
     * Filter which MatchInterest to delete.
     */
    where: MatchInterestWhereUniqueInput
  }


  /**
   * MatchInterest deleteMany
   */
  export type MatchInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchInterests to delete
     */
    where?: MatchInterestWhereInput
  }


  /**
   * MatchInterest without action
   */
  export type MatchInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchInterest
     */
    select?: MatchInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatchInterestInclude<ExtArgs> | null
  }



  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    endpoint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    endpoint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    endpoint: number
    keys: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    endpoint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    endpoint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    endpoint?: true
    keys?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    endpoint: string
    keys: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    endpoint?: boolean
    keys?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    endpoint?: boolean
    keys?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      endpoint: string
      keys: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }


  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PushSubscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PushSubscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PushSubscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PushSubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
    **/
    create<T extends PushSubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PushSubscriptions.
     *     @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     *     @example
     *     // Create many PushSubscriptions
     *     const pushSubscription = await prisma.pushSubscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PushSubscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
    **/
    delete<T extends PushSubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PushSubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PushSubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PushSubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
    **/
    upsert<T extends PushSubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PushSubscription model
   */ 
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly tenantId: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly keys: FieldRef<"PushSubscription", 'Json'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }


  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }


  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }


  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }


  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }


  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }


  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }


  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
  }


  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }


  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }


  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
  }


  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    provider: string | null
    providerTxId: string | null
    status: $Enums.PaymentStatus | null
    description: string | null
    dealInvestorId: string | null
    bookingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    provider: string | null
    providerTxId: string | null
    status: $Enums.PaymentStatus | null
    description: string | null
    dealInvestorId: string | null
    bookingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    amount: number
    currency: number
    method: number
    provider: number
    providerTxId: number
    status: number
    description: number
    metadata: number
    dealInvestorId: number
    bookingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    amount?: true
    currency?: true
    method?: true
    provider?: true
    providerTxId?: true
    status?: true
    description?: true
    dealInvestorId?: true
    bookingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    amount?: true
    currency?: true
    method?: true
    provider?: true
    providerTxId?: true
    status?: true
    description?: true
    dealInvestorId?: true
    bookingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    amount?: true
    currency?: true
    method?: true
    provider?: true
    providerTxId?: true
    status?: true
    description?: true
    metadata?: true
    dealInvestorId?: true
    bookingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    amount: number
    currency: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId: string | null
    status: $Enums.PaymentStatus
    description: string | null
    metadata: JsonValue | null
    dealInvestorId: string | null
    bookingId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    provider?: boolean
    providerTxId?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    dealInvestorId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestment?: boolean | Payment$dealInvestmentArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    provider?: boolean
    providerTxId?: boolean
    status?: boolean
    description?: boolean
    metadata?: boolean
    dealInvestorId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestment?: boolean | Payment$dealInvestmentArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }


  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      dealInvestment: Prisma.$DealInvestorPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      amount: number
      currency: string
      method: $Enums.PaymentMethod
      provider: string
      providerTxId: string | null
      status: $Enums.PaymentStatus
      description: string | null
      metadata: Prisma.JsonValue | null
      dealInvestorId: string | null
      bookingId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dealInvestment<T extends Payment$dealInvestmentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$dealInvestmentArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    booking<T extends Payment$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Payment$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly providerTxId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly dealInvestorId: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment.dealInvestment
   */
  export type Payment$dealInvestmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
  }


  /**
   * Payment.booking
   */
  export type Payment$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    language: 'language',
    did: 'did',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SMEScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    sector: 'sector',
    stage: 'stage',
    fundingRequired: 'fundingRequired',
    description: 'description',
    website: 'website',
    location: 'location',
    score: 'score',
    certified: 'certified',
    certificationDate: 'certificationDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SMEScalarFieldEnum = (typeof SMEScalarFieldEnum)[keyof typeof SMEScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    type: 'type',
    kycStatus: 'kycStatus',
    preferences: 'preferences',
    portfolio: 'portfolio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const AdvisorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    specialization: 'specialization',
    certificationList: 'certificationList',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdvisorScalarFieldEnum = (typeof AdvisorScalarFieldEnum)[keyof typeof AdvisorScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    smeId: 'smeId',
    title: 'title',
    description: 'description',
    amount: 'amount',
    equity: 'equity',
    status: 'status',
    successFee: 'successFee',
    terms: 'terms',
    isDocumentLocked: 'isDocumentLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const DealInvestorScalarFieldEnum: {
    id: 'id',
    dealId: 'dealId',
    investorId: 'investorId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealInvestorScalarFieldEnum = (typeof DealInvestorScalarFieldEnum)[keyof typeof DealInvestorScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    type: 'type',
    url: 'url',
    size: 'size',
    mimeType: 'mimeType',
    smeId: 'smeId',
    dealId: 'dealId',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    smeId: 'smeId',
    advisorId: 'advisorId',
    status: 'status',
    score: 'score',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    status: 'status',
    data: 'data',
    smeId: 'smeId',
    investorId: 'investorId',
    advisorId: 'advisorId',
    dealId: 'dealId',
    didWorkflowId: 'didWorkflowId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const SyndicateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    leadInvestorId: 'leadInvestorId',
    targetAmount: 'targetAmount',
    minInvestment: 'minInvestment',
    maxInvestment: 'maxInvestment',
    managementFee: 'managementFee',
    carryFee: 'carryFee',
    status: 'status',
    dealId: 'dealId',
    closingDate: 'closingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SyndicateScalarFieldEnum = (typeof SyndicateScalarFieldEnum)[keyof typeof SyndicateScalarFieldEnum]


  export const SyndicateMemberScalarFieldEnum: {
    id: 'id',
    syndicateId: 'syndicateId',
    investorId: 'investorId',
    amount: 'amount',
    status: 'status',
    joinedAt: 'joinedAt'
  };

  export type SyndicateMemberScalarFieldEnum = (typeof SyndicateMemberScalarFieldEnum)[keyof typeof SyndicateMemberScalarFieldEnum]


  export const DueDiligenceScalarFieldEnum: {
    id: 'id',
    smeId: 'smeId',
    advisorId: 'advisorId',
    financialScore: 'financialScore',
    teamScore: 'teamScore',
    marketScore: 'marketScore',
    productScore: 'productScore',
    legalScore: 'legalScore',
    operationalScore: 'operationalScore',
    overallScore: 'overallScore',
    riskLevel: 'riskLevel',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    recommendations: 'recommendations',
    redFlags: 'redFlags',
    status: 'status',
    completedAt: 'completedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DueDiligenceScalarFieldEnum = (typeof DueDiligenceScalarFieldEnum)[keyof typeof DueDiligenceScalarFieldEnum]


  export const CommunityPostScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    authorId: 'authorId',
    title: 'title',
    content: 'content',
    category: 'category',
    smeId: 'smeId',
    dealId: 'dealId',
    syndicateId: 'syndicateId',
    likes: 'likes',
    views: 'views',
    isPinned: 'isPinned',
    isAnnouncement: 'isAnnouncement',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityPostScalarFieldEnum = (typeof CommunityPostScalarFieldEnum)[keyof typeof CommunityPostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    parentId: 'parentId',
    likes: 'likes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SecondaryListingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    sellerId: 'sellerId',
    dealInvestorId: 'dealInvestorId',
    sharesAvailable: 'sharesAvailable',
    pricePerShare: 'pricePerShare',
    minPurchase: 'minPurchase',
    status: 'status',
    listedAt: 'listedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecondaryListingScalarFieldEnum = (typeof SecondaryListingScalarFieldEnum)[keyof typeof SecondaryListingScalarFieldEnum]


  export const SecondaryTradeScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    buyerId: 'buyerId',
    sellerId: 'sellerId',
    shares: 'shares',
    pricePerShare: 'pricePerShare',
    totalAmount: 'totalAmount',
    fee: 'fee',
    status: 'status',
    executedAt: 'executedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecondaryTradeScalarFieldEnum = (typeof SecondaryTradeScalarFieldEnum)[keyof typeof SecondaryTradeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    actionUrl: 'actionUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    dealId: 'dealId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    lastReadAt: 'lastReadAt',
    joinedAt: 'joinedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const AdvisoryServiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    advisorId: 'advisorId',
    name: 'name',
    category: 'category',
    description: 'description',
    price: 'price',
    duration: 'duration',
    features: 'features',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdvisoryServiceScalarFieldEnum = (typeof AdvisoryServiceScalarFieldEnum)[keyof typeof AdvisoryServiceScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    advisorId: 'advisorId',
    serviceId: 'serviceId',
    preferredDate: 'preferredDate',
    notes: 'notes',
    status: 'status',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    smeId: 'smeId',
    investorId: 'investorId',
    score: 'score',
    factors: 'factors',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const MatchInterestScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    userId: 'userId',
    interest: 'interest',
    createdAt: 'createdAt'
  };

  export type MatchInterestScalarFieldEnum = (typeof MatchInterestScalarFieldEnum)[keyof typeof MatchInterestScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    endpoint: 'endpoint',
    keys: 'keys',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    provider: 'provider',
    providerTxId: 'providerTxId',
    status: 'status',
    description: 'description',
    metadata: 'metadata',
    dealInvestorId: 'dealInvestorId',
    bookingId: 'bookingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SMEStage'
   */
  export type EnumSMEStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStage'>
    


  /**
   * Reference to a field of type 'SMEStage[]'
   */
  export type ListEnumSMEStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStage[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SMEStatus'
   */
  export type EnumSMEStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStatus'>
    


  /**
   * Reference to a field of type 'SMEStatus[]'
   */
  export type ListEnumSMEStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStatus[]'>
    


  /**
   * Reference to a field of type 'InvestorType'
   */
  export type EnumInvestorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestorType'>
    


  /**
   * Reference to a field of type 'InvestorType[]'
   */
  export type ListEnumInvestorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestorType[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'AdvisorStatus'
   */
  export type EnumAdvisorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvisorStatus'>
    


  /**
   * Reference to a field of type 'AdvisorStatus[]'
   */
  export type ListEnumAdvisorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvisorStatus[]'>
    


  /**
   * Reference to a field of type 'DealStatus'
   */
  export type EnumDealStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealStatus'>
    


  /**
   * Reference to a field of type 'DealStatus[]'
   */
  export type ListEnumDealStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealStatus[]'>
    


  /**
   * Reference to a field of type 'InvestmentStatus'
   */
  export type EnumInvestmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestmentStatus'>
    


  /**
   * Reference to a field of type 'InvestmentStatus[]'
   */
  export type ListEnumInvestmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestmentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CertificationStatus'
   */
  export type EnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus'>
    


  /**
   * Reference to a field of type 'CertificationStatus[]'
   */
  export type ListEnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowType'
   */
  export type EnumWorkflowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowType'>
    


  /**
   * Reference to a field of type 'WorkflowType[]'
   */
  export type ListEnumWorkflowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowType[]'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


  /**
   * Reference to a field of type 'SyndicateStatus'
   */
  export type EnumSyndicateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateStatus'>
    


  /**
   * Reference to a field of type 'SyndicateStatus[]'
   */
  export type ListEnumSyndicateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateStatus[]'>
    


  /**
   * Reference to a field of type 'SyndicateMemberStatus'
   */
  export type EnumSyndicateMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateMemberStatus'>
    


  /**
   * Reference to a field of type 'SyndicateMemberStatus[]'
   */
  export type ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyndicateMemberStatus[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'DueDiligenceStatus'
   */
  export type EnumDueDiligenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DueDiligenceStatus'>
    


  /**
   * Reference to a field of type 'DueDiligenceStatus[]'
   */
  export type ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DueDiligenceStatus[]'>
    


  /**
   * Reference to a field of type 'PostCategory'
   */
  export type EnumPostCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostCategory'>
    


  /**
   * Reference to a field of type 'PostCategory[]'
   */
  export type ListEnumPostCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostCategory[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'TradeStatus'
   */
  export type EnumTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeStatus'>
    


  /**
   * Reference to a field of type 'TradeStatus[]'
   */
  export type ListEnumTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    smes?: SMEListRelationFilter
    investors?: InvestorListRelationFilter
    advisors?: AdvisorListRelationFilter
    deals?: DealListRelationFilter
    workflows?: WorkflowListRelationFilter
    documents?: DocumentListRelationFilter
    notifications?: NotificationListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    conversations?: ConversationListRelationFilter
    matches?: MatchListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    smes?: SMEOrderByRelationAggregateInput
    investors?: InvestorOrderByRelationAggregateInput
    advisors?: AdvisorOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    smes?: SMEListRelationFilter
    investors?: InvestorListRelationFilter
    advisors?: AdvisorListRelationFilter
    deals?: DealListRelationFilter
    workflows?: WorkflowListRelationFilter
    documents?: DocumentListRelationFilter
    notifications?: NotificationListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    conversations?: ConversationListRelationFilter
    matches?: MatchListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    settings?: JsonWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    notifications?: NotificationListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    messageParticipants?: ConversationParticipantListRelationFilter
    sentMessages?: MessageListRelationFilter
    bookings?: BookingListRelationFilter
    matchInterests?: MatchInterestListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
    messageParticipants?: ConversationParticipantOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    matchInterests?: MatchInterestOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    notifications?: NotificationListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    messageParticipants?: ConversationParticipantListRelationFilter
    sentMessages?: MessageListRelationFilter
    bookings?: BookingListRelationFilter
    matchInterests?: MatchInterestListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageWithAggregatesFilter<"User"> | $Enums.Language
    did?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SMEWhereInput = {
    AND?: SMEWhereInput | SMEWhereInput[]
    OR?: SMEWhereInput[]
    NOT?: SMEWhereInput | SMEWhereInput[]
    id?: StringFilter<"SME"> | string
    tenantId?: StringFilter<"SME"> | string
    userId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: DocumentListRelationFilter
    deals?: DealListRelationFilter
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
    matches?: MatchListRelationFilter
  }

  export type SMEOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    certified?: SortOrder
    certificationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    dueDiligences?: DueDiligenceOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
  }

  export type SMEWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SMEWhereInput | SMEWhereInput[]
    OR?: SMEWhereInput[]
    NOT?: SMEWhereInput | SMEWhereInput[]
    tenantId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: DocumentListRelationFilter
    deals?: DealListRelationFilter
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
    matches?: MatchListRelationFilter
  }, "id" | "userId">

  export type SMEOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    certified?: SortOrder
    certificationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SMECountOrderByAggregateInput
    _avg?: SMEAvgOrderByAggregateInput
    _max?: SMEMaxOrderByAggregateInput
    _min?: SMEMinOrderByAggregateInput
    _sum?: SMESumOrderByAggregateInput
  }

  export type SMEScalarWhereWithAggregatesInput = {
    AND?: SMEScalarWhereWithAggregatesInput | SMEScalarWhereWithAggregatesInput[]
    OR?: SMEScalarWhereWithAggregatesInput[]
    NOT?: SMEScalarWhereWithAggregatesInput | SMEScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SME"> | string
    tenantId?: StringWithAggregatesFilter<"SME"> | string
    userId?: StringWithAggregatesFilter<"SME"> | string
    name?: StringWithAggregatesFilter<"SME"> | string
    sector?: StringWithAggregatesFilter<"SME"> | string
    stage?: EnumSMEStageWithAggregatesFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatWithAggregatesFilter<"SME"> | number
    description?: StringNullableWithAggregatesFilter<"SME"> | string | null
    website?: StringNullableWithAggregatesFilter<"SME"> | string | null
    location?: StringNullableWithAggregatesFilter<"SME"> | string | null
    score?: FloatNullableWithAggregatesFilter<"SME"> | number | null
    certified?: BoolWithAggregatesFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableWithAggregatesFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusWithAggregatesFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeWithAggregatesFilter<"SME"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SME"> | Date | string
  }

  export type InvestorWhereInput = {
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    id?: StringFilter<"Investor"> | string
    tenantId?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestments?: DealInvestorListRelationFilter
    workflows?: WorkflowListRelationFilter
    leadSyndicates?: SyndicateListRelationFilter
    syndicateMemberships?: SyndicateMemberListRelationFilter
    secondaryListings?: SecondaryListingListRelationFilter
    tradesAsBuyer?: SecondaryTradeListRelationFilter
    tradesAsSeller?: SecondaryTradeListRelationFilter
    matches?: MatchListRelationFilter
  }

  export type InvestorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    dealInvestments?: DealInvestorOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    leadSyndicates?: SyndicateOrderByRelationAggregateInput
    syndicateMemberships?: SyndicateMemberOrderByRelationAggregateInput
    secondaryListings?: SecondaryListingOrderByRelationAggregateInput
    tradesAsBuyer?: SecondaryTradeOrderByRelationAggregateInput
    tradesAsSeller?: SecondaryTradeOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
  }

  export type InvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    tenantId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestments?: DealInvestorListRelationFilter
    workflows?: WorkflowListRelationFilter
    leadSyndicates?: SyndicateListRelationFilter
    syndicateMemberships?: SyndicateMemberListRelationFilter
    secondaryListings?: SecondaryListingListRelationFilter
    tradesAsBuyer?: SecondaryTradeListRelationFilter
    tradesAsSeller?: SecondaryTradeListRelationFilter
    matches?: MatchListRelationFilter
  }, "id" | "userId">

  export type InvestorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorCountOrderByAggregateInput
    _max?: InvestorMaxOrderByAggregateInput
    _min?: InvestorMinOrderByAggregateInput
  }

  export type InvestorScalarWhereWithAggregatesInput = {
    AND?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    OR?: InvestorScalarWhereWithAggregatesInput[]
    NOT?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investor"> | string
    tenantId?: StringWithAggregatesFilter<"Investor"> | string
    userId?: StringWithAggregatesFilter<"Investor"> | string
    name?: StringWithAggregatesFilter<"Investor"> | string
    type?: EnumInvestorTypeWithAggregatesFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusWithAggregatesFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonWithAggregatesFilter<"Investor">
    portfolio?: JsonWithAggregatesFilter<"Investor">
    createdAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
  }

  export type AdvisorWhereInput = {
    AND?: AdvisorWhereInput | AdvisorWhereInput[]
    OR?: AdvisorWhereInput[]
    NOT?: AdvisorWhereInput | AdvisorWhereInput[]
    id?: StringFilter<"Advisor"> | string
    tenantId?: StringFilter<"Advisor"> | string
    userId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
    services?: AdvisoryServiceListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type AdvisorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    certifications?: CertificationOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    dueDiligences?: DueDiligenceOrderByRelationAggregateInput
    services?: AdvisoryServiceOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type AdvisorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdvisorWhereInput | AdvisorWhereInput[]
    OR?: AdvisorWhereInput[]
    NOT?: AdvisorWhereInput | AdvisorWhereInput[]
    tenantId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
    dueDiligences?: DueDiligenceListRelationFilter
    services?: AdvisoryServiceListRelationFilter
    bookings?: BookingListRelationFilter
  }, "id" | "userId">

  export type AdvisorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdvisorCountOrderByAggregateInput
    _max?: AdvisorMaxOrderByAggregateInput
    _min?: AdvisorMinOrderByAggregateInput
  }

  export type AdvisorScalarWhereWithAggregatesInput = {
    AND?: AdvisorScalarWhereWithAggregatesInput | AdvisorScalarWhereWithAggregatesInput[]
    OR?: AdvisorScalarWhereWithAggregatesInput[]
    NOT?: AdvisorScalarWhereWithAggregatesInput | AdvisorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Advisor"> | string
    tenantId?: StringWithAggregatesFilter<"Advisor"> | string
    userId?: StringWithAggregatesFilter<"Advisor"> | string
    name?: StringWithAggregatesFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusWithAggregatesFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeWithAggregatesFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Advisor"> | Date | string
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    terms?: StringNullableFilter<"Deal"> | string | null
    isDocumentLocked?: BoolFilter<"Deal"> | boolean
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investors?: DealInvestorListRelationFilter
    documents?: DocumentListRelationFilter
    workflows?: WorkflowListRelationFilter
    syndicates?: SyndicateListRelationFilter
    conversations?: ConversationListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    equity?: SortOrderInput | SortOrder
    status?: SortOrder
    successFee?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investors?: DealInvestorOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    syndicates?: SyndicateOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    terms?: StringNullableFilter<"Deal"> | string | null
    isDocumentLocked?: BoolFilter<"Deal"> | boolean
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investors?: DealInvestorListRelationFilter
    documents?: DocumentListRelationFilter
    workflows?: WorkflowListRelationFilter
    syndicates?: SyndicateListRelationFilter
    conversations?: ConversationListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    equity?: SortOrderInput | SortOrder
    status?: SortOrder
    successFee?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    tenantId?: StringWithAggregatesFilter<"Deal"> | string
    smeId?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    description?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    amount?: FloatWithAggregatesFilter<"Deal"> | number
    equity?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    status?: EnumDealStatusWithAggregatesFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    terms?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    isDocumentLocked?: BoolWithAggregatesFilter<"Deal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
  }

  export type DealInvestorWhereInput = {
    AND?: DealInvestorWhereInput | DealInvestorWhereInput[]
    OR?: DealInvestorWhereInput[]
    NOT?: DealInvestorWhereInput | DealInvestorWhereInput[]
    id?: StringFilter<"DealInvestor"> | string
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
    deal?: XOR<DealRelationFilter, DealWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    secondaryListings?: SecondaryListingListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type DealInvestorOrderByWithRelationInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deal?: DealOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    secondaryListings?: SecondaryListingOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type DealInvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dealId_investorId?: DealInvestorDealIdInvestorIdCompoundUniqueInput
    AND?: DealInvestorWhereInput | DealInvestorWhereInput[]
    OR?: DealInvestorWhereInput[]
    NOT?: DealInvestorWhereInput | DealInvestorWhereInput[]
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
    deal?: XOR<DealRelationFilter, DealWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    secondaryListings?: SecondaryListingListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "dealId_investorId">

  export type DealInvestorOrderByWithAggregationInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealInvestorCountOrderByAggregateInput
    _avg?: DealInvestorAvgOrderByAggregateInput
    _max?: DealInvestorMaxOrderByAggregateInput
    _min?: DealInvestorMinOrderByAggregateInput
    _sum?: DealInvestorSumOrderByAggregateInput
  }

  export type DealInvestorScalarWhereWithAggregatesInput = {
    AND?: DealInvestorScalarWhereWithAggregatesInput | DealInvestorScalarWhereWithAggregatesInput[]
    OR?: DealInvestorScalarWhereWithAggregatesInput[]
    NOT?: DealInvestorScalarWhereWithAggregatesInput | DealInvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DealInvestor"> | string
    dealId?: StringWithAggregatesFilter<"DealInvestor"> | string
    investorId?: StringWithAggregatesFilter<"DealInvestor"> | string
    amount?: FloatWithAggregatesFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusWithAggregatesFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DealInvestor"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    tenantId?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    smeId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedBy?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sme?: SMEOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _avg?: CertificationAvgOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
    _sum?: CertificationSumOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    smeId?: StringWithAggregatesFilter<"Certification"> | string
    advisorId?: StringWithAggregatesFilter<"Certification"> | string
    status?: EnumCertificationStatusWithAggregatesFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableWithAggregatesFilter<"Certification"> | number | null
    comments?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrderInput | SortOrder
    investorId?: SortOrderInput | SortOrder
    advisorId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    didWorkflowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrderInput | SortOrder
    investorId?: SortOrderInput | SortOrder
    advisorId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    didWorkflowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    tenantId?: StringWithAggregatesFilter<"Workflow"> | string
    type?: EnumWorkflowTypeWithAggregatesFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusWithAggregatesFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonWithAggregatesFilter<"Workflow">
    smeId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    investorId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    advisorId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
  }

  export type SyndicateWhereInput = {
    AND?: SyndicateWhereInput | SyndicateWhereInput[]
    OR?: SyndicateWhereInput[]
    NOT?: SyndicateWhereInput | SyndicateWhereInput[]
    id?: StringFilter<"Syndicate"> | string
    tenantId?: StringFilter<"Syndicate"> | string
    name?: StringFilter<"Syndicate"> | string
    description?: StringNullableFilter<"Syndicate"> | string | null
    leadInvestorId?: StringFilter<"Syndicate"> | string
    targetAmount?: FloatFilter<"Syndicate"> | number
    minInvestment?: FloatFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableFilter<"Syndicate"> | number | null
    managementFee?: FloatFilter<"Syndicate"> | number
    carryFee?: FloatFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeFilter<"Syndicate"> | Date | string
    leadInvestor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    members?: SyndicateMemberListRelationFilter
  }

  export type SyndicateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrderInput | SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leadInvestor?: InvestorOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    members?: SyndicateMemberOrderByRelationAggregateInput
  }

  export type SyndicateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyndicateWhereInput | SyndicateWhereInput[]
    OR?: SyndicateWhereInput[]
    NOT?: SyndicateWhereInput | SyndicateWhereInput[]
    tenantId?: StringFilter<"Syndicate"> | string
    name?: StringFilter<"Syndicate"> | string
    description?: StringNullableFilter<"Syndicate"> | string | null
    leadInvestorId?: StringFilter<"Syndicate"> | string
    targetAmount?: FloatFilter<"Syndicate"> | number
    minInvestment?: FloatFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableFilter<"Syndicate"> | number | null
    managementFee?: FloatFilter<"Syndicate"> | number
    carryFee?: FloatFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeFilter<"Syndicate"> | Date | string
    leadInvestor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    members?: SyndicateMemberListRelationFilter
  }, "id">

  export type SyndicateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrderInput | SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SyndicateCountOrderByAggregateInput
    _avg?: SyndicateAvgOrderByAggregateInput
    _max?: SyndicateMaxOrderByAggregateInput
    _min?: SyndicateMinOrderByAggregateInput
    _sum?: SyndicateSumOrderByAggregateInput
  }

  export type SyndicateScalarWhereWithAggregatesInput = {
    AND?: SyndicateScalarWhereWithAggregatesInput | SyndicateScalarWhereWithAggregatesInput[]
    OR?: SyndicateScalarWhereWithAggregatesInput[]
    NOT?: SyndicateScalarWhereWithAggregatesInput | SyndicateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Syndicate"> | string
    tenantId?: StringWithAggregatesFilter<"Syndicate"> | string
    name?: StringWithAggregatesFilter<"Syndicate"> | string
    description?: StringNullableWithAggregatesFilter<"Syndicate"> | string | null
    leadInvestorId?: StringWithAggregatesFilter<"Syndicate"> | string
    targetAmount?: FloatWithAggregatesFilter<"Syndicate"> | number
    minInvestment?: FloatWithAggregatesFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableWithAggregatesFilter<"Syndicate"> | number | null
    managementFee?: FloatWithAggregatesFilter<"Syndicate"> | number
    carryFee?: FloatWithAggregatesFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusWithAggregatesFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableWithAggregatesFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableWithAggregatesFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Syndicate"> | Date | string
  }

  export type SyndicateMemberWhereInput = {
    AND?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    OR?: SyndicateMemberWhereInput[]
    NOT?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    id?: StringFilter<"SyndicateMember"> | string
    syndicateId?: StringFilter<"SyndicateMember"> | string
    investorId?: StringFilter<"SyndicateMember"> | string
    amount?: FloatFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFilter<"SyndicateMember"> | Date | string
    syndicate?: XOR<SyndicateRelationFilter, SyndicateWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }

  export type SyndicateMemberOrderByWithRelationInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    syndicate?: SyndicateOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
  }

  export type SyndicateMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syndicateId_investorId?: SyndicateMemberSyndicateIdInvestorIdCompoundUniqueInput
    AND?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    OR?: SyndicateMemberWhereInput[]
    NOT?: SyndicateMemberWhereInput | SyndicateMemberWhereInput[]
    syndicateId?: StringFilter<"SyndicateMember"> | string
    investorId?: StringFilter<"SyndicateMember"> | string
    amount?: FloatFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFilter<"SyndicateMember"> | Date | string
    syndicate?: XOR<SyndicateRelationFilter, SyndicateWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }, "id" | "syndicateId_investorId">

  export type SyndicateMemberOrderByWithAggregationInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    _count?: SyndicateMemberCountOrderByAggregateInput
    _avg?: SyndicateMemberAvgOrderByAggregateInput
    _max?: SyndicateMemberMaxOrderByAggregateInput
    _min?: SyndicateMemberMinOrderByAggregateInput
    _sum?: SyndicateMemberSumOrderByAggregateInput
  }

  export type SyndicateMemberScalarWhereWithAggregatesInput = {
    AND?: SyndicateMemberScalarWhereWithAggregatesInput | SyndicateMemberScalarWhereWithAggregatesInput[]
    OR?: SyndicateMemberScalarWhereWithAggregatesInput[]
    NOT?: SyndicateMemberScalarWhereWithAggregatesInput | SyndicateMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyndicateMember"> | string
    syndicateId?: StringWithAggregatesFilter<"SyndicateMember"> | string
    investorId?: StringWithAggregatesFilter<"SyndicateMember"> | string
    amount?: FloatWithAggregatesFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusWithAggregatesFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeWithAggregatesFilter<"SyndicateMember"> | Date | string
  }

  export type DueDiligenceWhereInput = {
    AND?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    OR?: DueDiligenceWhereInput[]
    NOT?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    id?: StringFilter<"DueDiligence"> | string
    smeId?: StringFilter<"DueDiligence"> | string
    advisorId?: StringNullableFilter<"DueDiligence"> | string | null
    financialScore?: FloatFilter<"DueDiligence"> | number
    teamScore?: FloatFilter<"DueDiligence"> | number
    marketScore?: FloatFilter<"DueDiligence"> | number
    productScore?: FloatFilter<"DueDiligence"> | number
    legalScore?: FloatFilter<"DueDiligence"> | number
    operationalScore?: FloatFilter<"DueDiligence"> | number
    overallScore?: FloatFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligence"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
  }

  export type DueDiligenceOrderByWithRelationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    redFlags?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sme?: SMEOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
  }

  export type DueDiligenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    OR?: DueDiligenceWhereInput[]
    NOT?: DueDiligenceWhereInput | DueDiligenceWhereInput[]
    smeId?: StringFilter<"DueDiligence"> | string
    advisorId?: StringNullableFilter<"DueDiligence"> | string | null
    financialScore?: FloatFilter<"DueDiligence"> | number
    teamScore?: FloatFilter<"DueDiligence"> | number
    marketScore?: FloatFilter<"DueDiligence"> | number
    productScore?: FloatFilter<"DueDiligence"> | number
    legalScore?: FloatFilter<"DueDiligence"> | number
    operationalScore?: FloatFilter<"DueDiligence"> | number
    overallScore?: FloatFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligence"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
  }, "id">

  export type DueDiligenceOrderByWithAggregationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    redFlags?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DueDiligenceCountOrderByAggregateInput
    _avg?: DueDiligenceAvgOrderByAggregateInput
    _max?: DueDiligenceMaxOrderByAggregateInput
    _min?: DueDiligenceMinOrderByAggregateInput
    _sum?: DueDiligenceSumOrderByAggregateInput
  }

  export type DueDiligenceScalarWhereWithAggregatesInput = {
    AND?: DueDiligenceScalarWhereWithAggregatesInput | DueDiligenceScalarWhereWithAggregatesInput[]
    OR?: DueDiligenceScalarWhereWithAggregatesInput[]
    NOT?: DueDiligenceScalarWhereWithAggregatesInput | DueDiligenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DueDiligence"> | string
    smeId?: StringWithAggregatesFilter<"DueDiligence"> | string
    advisorId?: StringNullableWithAggregatesFilter<"DueDiligence"> | string | null
    financialScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    teamScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    marketScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    productScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    legalScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    operationalScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    overallScore?: FloatWithAggregatesFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelWithAggregatesFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusWithAggregatesFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DueDiligence"> | Date | string
  }

  export type CommunityPostWhereInput = {
    AND?: CommunityPostWhereInput | CommunityPostWhereInput[]
    OR?: CommunityPostWhereInput[]
    NOT?: CommunityPostWhereInput | CommunityPostWhereInput[]
    id?: StringFilter<"CommunityPost"> | string
    tenantId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    category?: EnumPostCategoryFilter<"CommunityPost"> | $Enums.PostCategory
    smeId?: StringNullableFilter<"CommunityPost"> | string | null
    dealId?: StringNullableFilter<"CommunityPost"> | string | null
    syndicateId?: StringNullableFilter<"CommunityPost"> | string | null
    likes?: IntFilter<"CommunityPost"> | number
    views?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    isAnnouncement?: BoolFilter<"CommunityPost"> | boolean
    status?: EnumPostStatusFilter<"CommunityPost"> | $Enums.PostStatus
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
    comments?: CommentListRelationFilter
  }

  export type CommunityPostOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    syndicateId?: SortOrderInput | SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
  }

  export type CommunityPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityPostWhereInput | CommunityPostWhereInput[]
    OR?: CommunityPostWhereInput[]
    NOT?: CommunityPostWhereInput | CommunityPostWhereInput[]
    tenantId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    category?: EnumPostCategoryFilter<"CommunityPost"> | $Enums.PostCategory
    smeId?: StringNullableFilter<"CommunityPost"> | string | null
    dealId?: StringNullableFilter<"CommunityPost"> | string | null
    syndicateId?: StringNullableFilter<"CommunityPost"> | string | null
    likes?: IntFilter<"CommunityPost"> | number
    views?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    isAnnouncement?: BoolFilter<"CommunityPost"> | boolean
    status?: EnumPostStatusFilter<"CommunityPost"> | $Enums.PostStatus
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
    comments?: CommentListRelationFilter
  }, "id">

  export type CommunityPostOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    syndicateId?: SortOrderInput | SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityPostCountOrderByAggregateInput
    _avg?: CommunityPostAvgOrderByAggregateInput
    _max?: CommunityPostMaxOrderByAggregateInput
    _min?: CommunityPostMinOrderByAggregateInput
    _sum?: CommunityPostSumOrderByAggregateInput
  }

  export type CommunityPostScalarWhereWithAggregatesInput = {
    AND?: CommunityPostScalarWhereWithAggregatesInput | CommunityPostScalarWhereWithAggregatesInput[]
    OR?: CommunityPostScalarWhereWithAggregatesInput[]
    NOT?: CommunityPostScalarWhereWithAggregatesInput | CommunityPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityPost"> | string
    tenantId?: StringWithAggregatesFilter<"CommunityPost"> | string
    authorId?: StringWithAggregatesFilter<"CommunityPost"> | string
    title?: StringWithAggregatesFilter<"CommunityPost"> | string
    content?: StringWithAggregatesFilter<"CommunityPost"> | string
    category?: EnumPostCategoryWithAggregatesFilter<"CommunityPost"> | $Enums.PostCategory
    smeId?: StringNullableWithAggregatesFilter<"CommunityPost"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"CommunityPost"> | string | null
    syndicateId?: StringNullableWithAggregatesFilter<"CommunityPost"> | string | null
    likes?: IntWithAggregatesFilter<"CommunityPost"> | number
    views?: IntWithAggregatesFilter<"CommunityPost"> | number
    isPinned?: BoolWithAggregatesFilter<"CommunityPost"> | boolean
    isAnnouncement?: BoolWithAggregatesFilter<"CommunityPost"> | boolean
    status?: EnumPostStatusWithAggregatesFilter<"CommunityPost"> | $Enums.PostStatus
    createdAt?: DateTimeWithAggregatesFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityPost"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    likes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: CommunityPostOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    likes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<CommunityPostRelationFilter, CommunityPostWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    likes?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type SecondaryListingWhereInput = {
    AND?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    OR?: SecondaryListingWhereInput[]
    NOT?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    id?: StringFilter<"SecondaryListing"> | string
    tenantId?: StringFilter<"SecondaryListing"> | string
    sellerId?: StringFilter<"SecondaryListing"> | string
    dealInvestorId?: StringFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatFilter<"SecondaryListing"> | number
    pricePerShare?: FloatFilter<"SecondaryListing"> | number
    minPurchase?: FloatFilter<"SecondaryListing"> | number
    status?: EnumListingStatusFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    seller?: XOR<InvestorRelationFilter, InvestorWhereInput>
    dealInvestor?: XOR<DealInvestorRelationFilter, DealInvestorWhereInput>
    trades?: SecondaryTradeListRelationFilter
  }

  export type SecondaryListingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: InvestorOrderByWithRelationInput
    dealInvestor?: DealInvestorOrderByWithRelationInput
    trades?: SecondaryTradeOrderByRelationAggregateInput
  }

  export type SecondaryListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    OR?: SecondaryListingWhereInput[]
    NOT?: SecondaryListingWhereInput | SecondaryListingWhereInput[]
    tenantId?: StringFilter<"SecondaryListing"> | string
    sellerId?: StringFilter<"SecondaryListing"> | string
    dealInvestorId?: StringFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatFilter<"SecondaryListing"> | number
    pricePerShare?: FloatFilter<"SecondaryListing"> | number
    minPurchase?: FloatFilter<"SecondaryListing"> | number
    status?: EnumListingStatusFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    seller?: XOR<InvestorRelationFilter, InvestorWhereInput>
    dealInvestor?: XOR<DealInvestorRelationFilter, DealInvestorWhereInput>
    trades?: SecondaryTradeListRelationFilter
  }, "id">

  export type SecondaryListingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecondaryListingCountOrderByAggregateInput
    _avg?: SecondaryListingAvgOrderByAggregateInput
    _max?: SecondaryListingMaxOrderByAggregateInput
    _min?: SecondaryListingMinOrderByAggregateInput
    _sum?: SecondaryListingSumOrderByAggregateInput
  }

  export type SecondaryListingScalarWhereWithAggregatesInput = {
    AND?: SecondaryListingScalarWhereWithAggregatesInput | SecondaryListingScalarWhereWithAggregatesInput[]
    OR?: SecondaryListingScalarWhereWithAggregatesInput[]
    NOT?: SecondaryListingScalarWhereWithAggregatesInput | SecondaryListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecondaryListing"> | string
    tenantId?: StringWithAggregatesFilter<"SecondaryListing"> | string
    sellerId?: StringWithAggregatesFilter<"SecondaryListing"> | string
    dealInvestorId?: StringWithAggregatesFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatWithAggregatesFilter<"SecondaryListing"> | number
    pricePerShare?: FloatWithAggregatesFilter<"SecondaryListing"> | number
    minPurchase?: FloatWithAggregatesFilter<"SecondaryListing"> | number
    status?: EnumListingStatusWithAggregatesFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeWithAggregatesFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecondaryListing"> | Date | string
  }

  export type SecondaryTradeWhereInput = {
    AND?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    OR?: SecondaryTradeWhereInput[]
    NOT?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    id?: StringFilter<"SecondaryTrade"> | string
    listingId?: StringFilter<"SecondaryTrade"> | string
    buyerId?: StringFilter<"SecondaryTrade"> | string
    sellerId?: StringFilter<"SecondaryTrade"> | string
    shares?: FloatFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatFilter<"SecondaryTrade"> | number
    totalAmount?: FloatFilter<"SecondaryTrade"> | number
    fee?: FloatFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    listing?: XOR<SecondaryListingRelationFilter, SecondaryListingWhereInput>
    buyer?: XOR<InvestorRelationFilter, InvestorWhereInput>
    seller?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }

  export type SecondaryTradeOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listing?: SecondaryListingOrderByWithRelationInput
    buyer?: InvestorOrderByWithRelationInput
    seller?: InvestorOrderByWithRelationInput
  }

  export type SecondaryTradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    OR?: SecondaryTradeWhereInput[]
    NOT?: SecondaryTradeWhereInput | SecondaryTradeWhereInput[]
    listingId?: StringFilter<"SecondaryTrade"> | string
    buyerId?: StringFilter<"SecondaryTrade"> | string
    sellerId?: StringFilter<"SecondaryTrade"> | string
    shares?: FloatFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatFilter<"SecondaryTrade"> | number
    totalAmount?: FloatFilter<"SecondaryTrade"> | number
    fee?: FloatFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    listing?: XOR<SecondaryListingRelationFilter, SecondaryListingWhereInput>
    buyer?: XOR<InvestorRelationFilter, InvestorWhereInput>
    seller?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }, "id">

  export type SecondaryTradeOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecondaryTradeCountOrderByAggregateInput
    _avg?: SecondaryTradeAvgOrderByAggregateInput
    _max?: SecondaryTradeMaxOrderByAggregateInput
    _min?: SecondaryTradeMinOrderByAggregateInput
    _sum?: SecondaryTradeSumOrderByAggregateInput
  }

  export type SecondaryTradeScalarWhereWithAggregatesInput = {
    AND?: SecondaryTradeScalarWhereWithAggregatesInput | SecondaryTradeScalarWhereWithAggregatesInput[]
    OR?: SecondaryTradeScalarWhereWithAggregatesInput[]
    NOT?: SecondaryTradeScalarWhereWithAggregatesInput | SecondaryTradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    listingId?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    buyerId?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    sellerId?: StringWithAggregatesFilter<"SecondaryTrade"> | string
    shares?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    totalAmount?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    fee?: FloatWithAggregatesFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusWithAggregatesFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableWithAggregatesFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SecondaryTrade"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    tenantId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    dealId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    messages?: MessageListRelationFilter
    participants?: ConversationParticipantListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    tenantId?: StringFilter<"Conversation"> | string
    dealId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
    messages?: MessageListRelationFilter
    participants?: ConversationParticipantListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    tenantId?: StringWithAggregatesFilter<"Conversation"> | string
    dealId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    id?: StringFilter<"ConversationParticipant"> | string
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_userId?: ConversationParticipantConversationIdUserIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "conversationId_userId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    userId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
    joinedAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    read?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type AdvisoryServiceWhereInput = {
    AND?: AdvisoryServiceWhereInput | AdvisoryServiceWhereInput[]
    OR?: AdvisoryServiceWhereInput[]
    NOT?: AdvisoryServiceWhereInput | AdvisoryServiceWhereInput[]
    id?: StringFilter<"AdvisoryService"> | string
    tenantId?: StringFilter<"AdvisoryService"> | string
    advisorId?: StringFilter<"AdvisoryService"> | string
    name?: StringFilter<"AdvisoryService"> | string
    category?: StringFilter<"AdvisoryService"> | string
    description?: StringNullableFilter<"AdvisoryService"> | string | null
    price?: FloatFilter<"AdvisoryService"> | number
    duration?: StringFilter<"AdvisoryService"> | string
    features?: StringNullableListFilter<"AdvisoryService">
    status?: StringFilter<"AdvisoryService"> | string
    createdAt?: DateTimeFilter<"AdvisoryService"> | Date | string
    updatedAt?: DateTimeFilter<"AdvisoryService"> | Date | string
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
    bookings?: BookingListRelationFilter
  }

  export type AdvisoryServiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    advisorId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    advisor?: AdvisorOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type AdvisoryServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdvisoryServiceWhereInput | AdvisoryServiceWhereInput[]
    OR?: AdvisoryServiceWhereInput[]
    NOT?: AdvisoryServiceWhereInput | AdvisoryServiceWhereInput[]
    tenantId?: StringFilter<"AdvisoryService"> | string
    advisorId?: StringFilter<"AdvisoryService"> | string
    name?: StringFilter<"AdvisoryService"> | string
    category?: StringFilter<"AdvisoryService"> | string
    description?: StringNullableFilter<"AdvisoryService"> | string | null
    price?: FloatFilter<"AdvisoryService"> | number
    duration?: StringFilter<"AdvisoryService"> | string
    features?: StringNullableListFilter<"AdvisoryService">
    status?: StringFilter<"AdvisoryService"> | string
    createdAt?: DateTimeFilter<"AdvisoryService"> | Date | string
    updatedAt?: DateTimeFilter<"AdvisoryService"> | Date | string
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
    bookings?: BookingListRelationFilter
  }, "id">

  export type AdvisoryServiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    advisorId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdvisoryServiceCountOrderByAggregateInput
    _avg?: AdvisoryServiceAvgOrderByAggregateInput
    _max?: AdvisoryServiceMaxOrderByAggregateInput
    _min?: AdvisoryServiceMinOrderByAggregateInput
    _sum?: AdvisoryServiceSumOrderByAggregateInput
  }

  export type AdvisoryServiceScalarWhereWithAggregatesInput = {
    AND?: AdvisoryServiceScalarWhereWithAggregatesInput | AdvisoryServiceScalarWhereWithAggregatesInput[]
    OR?: AdvisoryServiceScalarWhereWithAggregatesInput[]
    NOT?: AdvisoryServiceScalarWhereWithAggregatesInput | AdvisoryServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdvisoryService"> | string
    tenantId?: StringWithAggregatesFilter<"AdvisoryService"> | string
    advisorId?: StringWithAggregatesFilter<"AdvisoryService"> | string
    name?: StringWithAggregatesFilter<"AdvisoryService"> | string
    category?: StringWithAggregatesFilter<"AdvisoryService"> | string
    description?: StringNullableWithAggregatesFilter<"AdvisoryService"> | string | null
    price?: FloatWithAggregatesFilter<"AdvisoryService"> | number
    duration?: StringWithAggregatesFilter<"AdvisoryService"> | string
    features?: StringNullableListFilter<"AdvisoryService">
    status?: StringWithAggregatesFilter<"AdvisoryService"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdvisoryService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdvisoryService"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    tenantId?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    advisorId?: StringNullableFilter<"Booking"> | string | null
    serviceId?: StringNullableFilter<"Booking"> | string | null
    preferredDate?: DateTimeFilter<"Booking"> | Date | string
    notes?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    amount?: FloatNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    service?: XOR<AdvisoryServiceNullableRelationFilter, AdvisoryServiceWhereInput> | null
    payments?: PaymentListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    preferredDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
    service?: AdvisoryServiceOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tenantId?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    advisorId?: StringNullableFilter<"Booking"> | string | null
    serviceId?: StringNullableFilter<"Booking"> | string | null
    preferredDate?: DateTimeFilter<"Booking"> | Date | string
    notes?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    amount?: FloatNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    service?: XOR<AdvisoryServiceNullableRelationFilter, AdvisoryServiceWhereInput> | null
    payments?: PaymentListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    advisorId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    preferredDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    tenantId?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    advisorId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    preferredDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    amount?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: StringFilter<"Match"> | string
    tenantId?: StringFilter<"Match"> | string
    smeId?: StringFilter<"Match"> | string
    investorId?: StringFilter<"Match"> | string
    score?: IntFilter<"Match"> | number
    factors?: JsonNullableFilter<"Match">
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    interests?: MatchInterestListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    score?: SortOrder
    factors?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    interests?: MatchInterestOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    smeId_investorId?: MatchSmeIdInvestorIdCompoundUniqueInput
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    tenantId?: StringFilter<"Match"> | string
    smeId?: StringFilter<"Match"> | string
    investorId?: StringFilter<"Match"> | string
    score?: IntFilter<"Match"> | number
    factors?: JsonNullableFilter<"Match">
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
    interests?: MatchInterestListRelationFilter
  }, "id" | "smeId_investorId">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    score?: SortOrder
    factors?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Match"> | string
    tenantId?: StringWithAggregatesFilter<"Match"> | string
    smeId?: StringWithAggregatesFilter<"Match"> | string
    investorId?: StringWithAggregatesFilter<"Match"> | string
    score?: IntWithAggregatesFilter<"Match"> | number
    factors?: JsonNullableWithAggregatesFilter<"Match">
    status?: EnumMatchStatusWithAggregatesFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type MatchInterestWhereInput = {
    AND?: MatchInterestWhereInput | MatchInterestWhereInput[]
    OR?: MatchInterestWhereInput[]
    NOT?: MatchInterestWhereInput | MatchInterestWhereInput[]
    id?: StringFilter<"MatchInterest"> | string
    matchId?: StringFilter<"MatchInterest"> | string
    userId?: StringFilter<"MatchInterest"> | string
    interest?: BoolFilter<"MatchInterest"> | boolean
    createdAt?: DateTimeFilter<"MatchInterest"> | Date | string
    match?: XOR<MatchRelationFilter, MatchWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MatchInterestOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    userId?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    match?: MatchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MatchInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    matchId_userId?: MatchInterestMatchIdUserIdCompoundUniqueInput
    AND?: MatchInterestWhereInput | MatchInterestWhereInput[]
    OR?: MatchInterestWhereInput[]
    NOT?: MatchInterestWhereInput | MatchInterestWhereInput[]
    matchId?: StringFilter<"MatchInterest"> | string
    userId?: StringFilter<"MatchInterest"> | string
    interest?: BoolFilter<"MatchInterest"> | boolean
    createdAt?: DateTimeFilter<"MatchInterest"> | Date | string
    match?: XOR<MatchRelationFilter, MatchWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "matchId_userId">

  export type MatchInterestOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    userId?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
    _count?: MatchInterestCountOrderByAggregateInput
    _max?: MatchInterestMaxOrderByAggregateInput
    _min?: MatchInterestMinOrderByAggregateInput
  }

  export type MatchInterestScalarWhereWithAggregatesInput = {
    AND?: MatchInterestScalarWhereWithAggregatesInput | MatchInterestScalarWhereWithAggregatesInput[]
    OR?: MatchInterestScalarWhereWithAggregatesInput[]
    NOT?: MatchInterestScalarWhereWithAggregatesInput | MatchInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchInterest"> | string
    matchId?: StringWithAggregatesFilter<"MatchInterest"> | string
    userId?: StringWithAggregatesFilter<"MatchInterest"> | string
    interest?: BoolWithAggregatesFilter<"MatchInterest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MatchInterest"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    tenantId?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    keys?: JsonFilter<"PushSubscription">
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    keys?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_endpoint?: PushSubscriptionUserIdEndpointCompoundUniqueInput
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    tenantId?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    keys?: JsonFilter<"PushSubscription">
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    keys?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    tenantId?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringWithAggregatesFilter<"PushSubscription"> | string
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    keys?: JsonWithAggregatesFilter<"PushSubscription">
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    provider?: StringFilter<"Payment"> | string
    providerTxId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    dealInvestorId?: StringNullableFilter<"Payment"> | string | null
    bookingId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestment?: XOR<DealInvestorNullableRelationFilter, DealInvestorWhereInput> | null
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    providerTxId?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    dealInvestorId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    dealInvestment?: DealInvestorOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    tenantId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    provider?: StringFilter<"Payment"> | string
    providerTxId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    dealInvestorId?: StringNullableFilter<"Payment"> | string | null
    bookingId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestment?: XOR<DealInvestorNullableRelationFilter, DealInvestorWhereInput> | null
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    providerTxId?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    dealInvestorId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    tenantId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    provider?: StringWithAggregatesFilter<"Payment"> | string
    providerTxId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    dealInvestorId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    bookingId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMECreateInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMEUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type SMECreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMEUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMEUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorCreateInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutDealInvestorInput
    payments?: PaymentCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorUncheckedCreateInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutDealInvestorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutDealInvestorNestedInput
    payments?: PaymentUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutDealInvestorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorCreateManyInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    sme?: SMECreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutCertificationsInput
    advisor: AdvisorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    smeId: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutCertificationsNestedInput
    advisor?: AdvisorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyInput = {
    id?: string
    smeId: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateManyInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadInvestor: InvestorCreateNestedOneWithoutLeadSyndicatesInput
    deal?: DealCreateNestedOneWithoutSyndicatesInput
    members?: SyndicateMemberCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadInvestor?: InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput
    deal?: DealUpdateOneWithoutSyndicatesNestedInput
    members?: SyndicateMemberUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberCreateInput = {
    id?: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
    syndicate: SyndicateCreateNestedOneWithoutMembersInput
    investor: InvestorCreateNestedOneWithoutSyndicateMembershipsInput
  }

  export type SyndicateMemberUncheckedCreateInput = {
    id?: string
    syndicateId: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syndicate?: SyndicateUpdateOneRequiredWithoutMembersNestedInput
    investor?: InvestorUpdateOneRequiredWithoutSyndicateMembershipsNestedInput
  }

  export type SyndicateMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberCreateManyInput = {
    id?: string
    syndicateId: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceCreateInput = {
    id?: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDueDiligencesInput
    advisor?: AdvisorCreateNestedOneWithoutDueDiligencesInput
  }

  export type DueDiligenceUncheckedCreateInput = {
    id?: string
    smeId: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDueDiligencesNestedInput
    advisor?: AdvisorUpdateOneWithoutDueDiligencesNestedInput
  }

  export type DueDiligenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceCreateManyInput = {
    id?: string
    smeId: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostCreateInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostCreateManyInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingCreateInput = {
    id?: string
    tenantId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: InvestorCreateNestedOneWithoutSecondaryListingsInput
    dealInvestor: DealInvestorCreateNestedOneWithoutSecondaryListingsInput
    trades?: SecondaryTradeCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingUncheckedCreateInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: SecondaryTradeUncheckedCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: InvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput
    dealInvestor?: DealInvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput
    trades?: SecondaryTradeUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: SecondaryTradeUncheckedUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingCreateManyInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeCreateInput = {
    id?: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: SecondaryListingCreateNestedOneWithoutTradesInput
    buyer: InvestorCreateNestedOneWithoutTradesAsBuyerInput
    seller: InvestorCreateNestedOneWithoutTradesAsSellerInput
  }

  export type SecondaryTradeUncheckedCreateInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: SecondaryListingUpdateOneRequiredWithoutTradesNestedInput
    buyer?: InvestorUpdateOneRequiredWithoutTradesAsBuyerNestedInput
    seller?: InvestorUpdateOneRequiredWithoutTradesAsSellerNestedInput
  }

  export type SecondaryTradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeCreateManyInput = {
    id?: string
    listingId: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutConversationsInput
    deal?: DealCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    tenantId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
    deal?: DealUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    tenantId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    id?: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutMessageParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisoryServiceCreateInput = {
    id?: string
    tenantId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor: AdvisorCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type AdvisoryServiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    advisorId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type AdvisoryServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type AdvisoryServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type AdvisoryServiceCreateManyInput = {
    id?: string
    tenantId: string
    advisorId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisoryServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisoryServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    tenantId: string
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    advisor?: AdvisorCreateNestedOneWithoutBookingsInput
    service?: AdvisoryServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    advisorId?: string | null
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    advisor?: AdvisorUpdateOneWithoutBookingsNestedInput
    service?: AdvisoryServiceUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    advisorId?: string | null
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    id?: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMatchesInput
    sme: SMECreateNestedOneWithoutMatchesInput
    investor: InvestorCreateNestedOneWithoutMatchesInput
    interests?: MatchInterestCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id?: string
    tenantId: string
    smeId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: MatchInterestUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMatchesNestedInput
    sme?: SMEUpdateOneRequiredWithoutMatchesNestedInput
    investor?: InvestorUpdateOneRequiredWithoutMatchesNestedInput
    interests?: MatchInterestUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: MatchInterestUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    id?: string
    tenantId: string
    smeId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestCreateInput = {
    id?: string
    interest: boolean
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutInterestsInput
    user: UserCreateNestedOneWithoutMatchInterestsInput
  }

  export type MatchInterestUncheckedCreateInput = {
    id?: string
    matchId: string
    userId: string
    interest: boolean
    createdAt?: Date | string
  }

  export type MatchInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutInterestsNestedInput
    user?: UserUpdateOneRequiredWithoutMatchInterestsNestedInput
  }

  export type MatchInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestCreateManyInput = {
    id?: string
    matchId: string
    userId: string
    interest: boolean
    createdAt?: Date | string
  }

  export type MatchInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPushSubscriptionsInput
    user: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPushSubscriptionsNestedInput
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    user: UserCreateNestedOneWithoutPaymentsInput
    dealInvestment?: DealInvestorCreateNestedOneWithoutPaymentsInput
    booking?: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    dealInvestment?: DealInvestorUpdateOneWithoutPaymentsNestedInput
    booking?: BookingUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SMEListRelationFilter = {
    every?: SMEWhereInput
    some?: SMEWhereInput
    none?: SMEWhereInput
  }

  export type InvestorListRelationFilter = {
    every?: InvestorWhereInput
    some?: InvestorWhereInput
    none?: InvestorWhereInput
  }

  export type AdvisorListRelationFilter = {
    every?: AdvisorWhereInput
    some?: AdvisorWhereInput
    none?: AdvisorWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMEOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvisorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type EnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SMENullableRelationFilter = {
    is?: SMEWhereInput | null
    isNot?: SMEWhereInput | null
  }

  export type InvestorNullableRelationFilter = {
    is?: InvestorWhereInput | null
    isNot?: InvestorWhereInput | null
  }

  export type AdvisorNullableRelationFilter = {
    is?: AdvisorWhereInput | null
    isNot?: AdvisorWhereInput | null
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type MatchInterestListRelationFilter = {
    every?: MatchInterestWhereInput
    some?: MatchInterestWhereInput
    none?: MatchInterestWhereInput
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorBackupCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSMEStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageFilter<$PrismaModel> | $Enums.SMEStage
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSMEStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusFilter<$PrismaModel> | $Enums.SMEStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type DueDiligenceListRelationFilter = {
    every?: DueDiligenceWhereInput
    some?: DueDiligenceWhereInput
    none?: DueDiligenceWhereInput
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DueDiligenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMECountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMEAvgOrderByAggregateInput = {
    fundingRequired?: SortOrder
    score?: SortOrder
  }

  export type SMEMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMEMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMESumOrderByAggregateInput = {
    fundingRequired?: SortOrder
    score?: SortOrder
  }

  export type EnumSMEStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageWithAggregatesFilter<$PrismaModel> | $Enums.SMEStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStageFilter<$PrismaModel>
    _max?: NestedEnumSMEStageFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSMEStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel> | $Enums.SMEStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStatusFilter<$PrismaModel>
    _max?: NestedEnumSMEStatusFilter<$PrismaModel>
  }

  export type EnumInvestorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeFilter<$PrismaModel> | $Enums.InvestorType
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type DealInvestorListRelationFilter = {
    every?: DealInvestorWhereInput
    some?: DealInvestorWhereInput
    none?: DealInvestorWhereInput
  }

  export type SyndicateListRelationFilter = {
    every?: SyndicateWhereInput
    some?: SyndicateWhereInput
    none?: SyndicateWhereInput
  }

  export type SyndicateMemberListRelationFilter = {
    every?: SyndicateMemberWhereInput
    some?: SyndicateMemberWhereInput
    none?: SyndicateMemberWhereInput
  }

  export type SecondaryListingListRelationFilter = {
    every?: SecondaryListingWhereInput
    some?: SecondaryListingWhereInput
    none?: SecondaryListingWhereInput
  }

  export type SecondaryTradeListRelationFilter = {
    every?: SecondaryTradeWhereInput
    some?: SecondaryTradeWhereInput
    none?: SecondaryTradeWhereInput
  }

  export type DealInvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyndicateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyndicateMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecondaryListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecondaryTradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvestorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvestorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestorTypeFilter<$PrismaModel>
    _max?: NestedEnumInvestorTypeFilter<$PrismaModel>
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type EnumAdvisorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusFilter<$PrismaModel> | $Enums.AdvisorStatus
  }

  export type AdvisoryServiceListRelationFilter = {
    every?: AdvisoryServiceWhereInput
    some?: AdvisoryServiceWhereInput
    none?: AdvisoryServiceWhereInput
  }

  export type AdvisoryServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvisorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdvisorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvisorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvisorStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvisorStatusFilter<$PrismaModel>
  }

  export type EnumDealStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusFilter<$PrismaModel> | $Enums.DealStatus
  }

  export type SMERelationFilter = {
    is?: SMEWhereInput
    isNot?: SMEWhereInput
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    terms?: SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    amount?: SortOrder
    equity?: SortOrder
    successFee?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    terms?: SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    terms?: SortOrder
    isDocumentLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    amount?: SortOrder
    equity?: SortOrder
    successFee?: SortOrder
  }

  export type EnumDealStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealStatusFilter<$PrismaModel>
    _max?: NestedEnumDealStatusFilter<$PrismaModel>
  }

  export type EnumInvestmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusFilter<$PrismaModel> | $Enums.InvestmentStatus
  }

  export type DealRelationFilter = {
    is?: DealWhereInput
    isNot?: DealWhereInput
  }

  export type InvestorRelationFilter = {
    is?: InvestorWhereInput
    isNot?: InvestorWhereInput
  }

  export type DealInvestorDealIdInvestorIdCompoundUniqueInput = {
    dealId: string
    investorId: string
  }

  export type DealInvestorCountOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DealInvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorMinOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvestmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestmentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DealNullableRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type AdvisorRelationFilter = {
    is?: AdvisorWhereInput
    isNot?: AdvisorWhereInput
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type EnumWorkflowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeFilter<$PrismaModel> | $Enums.WorkflowType
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkflowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTypeFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type EnumSyndicateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusFilter<$PrismaModel> | $Enums.SyndicateStatus
  }

  export type SyndicateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrder
    closingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyndicateAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
  }

  export type SyndicateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrder
    closingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyndicateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leadInvestorId?: SortOrder
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
    status?: SortOrder
    dealId?: SortOrder
    closingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyndicateSumOrderByAggregateInput = {
    targetAmount?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    managementFee?: SortOrder
    carryFee?: SortOrder
  }

  export type EnumSyndicateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateStatusFilter<$PrismaModel>
  }

  export type EnumSyndicateMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
  }

  export type SyndicateRelationFilter = {
    is?: SyndicateWhereInput
    isNot?: SyndicateWhereInput
  }

  export type SyndicateMemberSyndicateIdInvestorIdCompoundUniqueInput = {
    syndicateId: string
    investorId: string
  }

  export type SyndicateMemberCountOrderByAggregateInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
  }

  export type SyndicateMemberAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SyndicateMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
  }

  export type SyndicateMemberMinOrderByAggregateInput = {
    id?: SortOrder
    syndicateId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
  }

  export type SyndicateMemberSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type EnumDueDiligenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusFilter<$PrismaModel> | $Enums.DueDiligenceStatus
  }

  export type DueDiligenceCountOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    redFlags?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDiligenceAvgOrderByAggregateInput = {
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
  }

  export type DueDiligenceMaxOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDiligenceMinOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDiligenceSumOrderByAggregateInput = {
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    productScore?: SortOrder
    legalScore?: SortOrder
    operationalScore?: SortOrder
    overallScore?: SortOrder
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type EnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DueDiligenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
    _max?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
  }

  export type EnumPostCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryFilter<$PrismaModel> | $Enums.PostCategory
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityPostCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    syndicateId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type CommunityPostMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    syndicateId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    syndicateId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isAnnouncement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type EnumPostCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PostCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostCategoryFilter<$PrismaModel>
    _max?: NestedEnumPostCategoryFilter<$PrismaModel>
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type CommunityPostRelationFilter = {
    is?: CommunityPostWhereInput
    isNot?: CommunityPostWhereInput
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type DealInvestorRelationFilter = {
    is?: DealInvestorWhereInput
    isNot?: DealInvestorWhereInput
  }

  export type SecondaryListingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryListingAvgOrderByAggregateInput = {
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
  }

  export type SecondaryListingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryListingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sellerId?: SortOrder
    dealInvestorId?: SortOrder
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
    status?: SortOrder
    listedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryListingSumOrderByAggregateInput = {
    sharesAvailable?: SortOrder
    pricePerShare?: SortOrder
    minPurchase?: SortOrder
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type EnumTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusFilter<$PrismaModel> | $Enums.TradeStatus
  }

  export type SecondaryListingRelationFilter = {
    is?: SecondaryListingWhereInput
    isNot?: SecondaryListingWhereInput
  }

  export type SecondaryTradeCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryTradeAvgOrderByAggregateInput = {
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
  }

  export type SecondaryTradeMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryTradeMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecondaryTradeSumOrderByAggregateInput = {
    shares?: SortOrder
    pricePerShare?: SortOrder
    totalAmount?: SortOrder
    fee?: SortOrder
  }

  export type EnumTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    dealId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdUserIdCompoundUniqueInput = {
    conversationId: string
    userId: string
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisoryServiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    advisorId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisoryServiceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AdvisoryServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    advisorId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisoryServiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    advisorId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisoryServiceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type AdvisoryServiceNullableRelationFilter = {
    is?: AdvisoryServiceWhereInput | null
    isNot?: AdvisoryServiceWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    advisorId?: SortOrder
    serviceId?: SortOrder
    preferredDate?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    advisorId?: SortOrder
    serviceId?: SortOrder
    preferredDate?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    advisorId?: SortOrder
    serviceId?: SortOrder
    preferredDate?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type MatchSmeIdInvestorIdCompoundUniqueInput = {
    smeId: string
    investorId: string
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    score?: SortOrder
    factors?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    score?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    score?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    score?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type MatchRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type MatchInterestMatchIdUserIdCompoundUniqueInput = {
    matchId: string
    userId: string
  }

  export type MatchInterestCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    userId?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    userId?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchInterestMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    userId?: SortOrder
    interest?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionUserIdEndpointCompoundUniqueInput = {
    userId: string
    endpoint: string
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    keys?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type DealInvestorNullableRelationFilter = {
    is?: DealInvestorWhereInput | null
    isNot?: DealInvestorWhereInput | null
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    providerTxId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    dealInvestorId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    providerTxId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    dealInvestorId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    provider?: SortOrder
    providerTxId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    dealInvestorId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SMECreateNestedManyWithoutTenantInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
  }

  export type InvestorCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type AdvisorCreateNestedManyWithoutTenantInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutTenantInput = {
    create?: XOR<PushSubscriptionCreateWithoutTenantInput, PushSubscriptionUncheckedCreateWithoutTenantInput> | PushSubscriptionCreateWithoutTenantInput[] | PushSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutTenantInput | PushSubscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: PushSubscriptionCreateManyTenantInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutTenantInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutTenantInput = {
    create?: XOR<MatchCreateWithoutTenantInput, MatchUncheckedCreateWithoutTenantInput> | MatchCreateWithoutTenantInput[] | MatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTenantInput | MatchCreateOrConnectWithoutTenantInput[]
    createMany?: MatchCreateManyTenantInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SMEUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
  }

  export type InvestorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type AdvisorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PushSubscriptionCreateWithoutTenantInput, PushSubscriptionUncheckedCreateWithoutTenantInput> | PushSubscriptionCreateWithoutTenantInput[] | PushSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutTenantInput | PushSubscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: PushSubscriptionCreateManyTenantInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MatchCreateWithoutTenantInput, MatchUncheckedCreateWithoutTenantInput> | MatchCreateWithoutTenantInput[] | MatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTenantInput | MatchCreateOrConnectWithoutTenantInput[]
    createMany?: MatchCreateManyTenantInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SMEUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    upsert?: SMEUpsertWithWhereUniqueWithoutTenantInput | SMEUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    set?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    disconnect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    delete?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    update?: SMEUpdateWithWhereUniqueWithoutTenantInput | SMEUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SMEUpdateManyWithWhereWithoutTenantInput | SMEUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SMEScalarWhereInput | SMEScalarWhereInput[]
  }

  export type InvestorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutTenantInput | InvestorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutTenantInput | InvestorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutTenantInput | InvestorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type AdvisorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    upsert?: AdvisorUpsertWithWhereUniqueWithoutTenantInput | AdvisorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    set?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    disconnect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    delete?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    update?: AdvisorUpdateWithWhereUniqueWithoutTenantInput | AdvisorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AdvisorUpdateManyWithWhereWithoutTenantInput | AdvisorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
  }

  export type DealUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutTenantInput | WorkflowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutTenantInput | WorkflowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutTenantInput | WorkflowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutTenantInput, PushSubscriptionUncheckedCreateWithoutTenantInput> | PushSubscriptionCreateWithoutTenantInput[] | PushSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutTenantInput | PushSubscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutTenantInput | PushSubscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PushSubscriptionCreateManyTenantInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutTenantInput | PushSubscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutTenantInput | PushSubscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutTenantInput | ConversationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutTenantInput | ConversationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutTenantInput | ConversationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MatchCreateWithoutTenantInput, MatchUncheckedCreateWithoutTenantInput> | MatchCreateWithoutTenantInput[] | MatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTenantInput | MatchCreateOrConnectWithoutTenantInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTenantInput | MatchUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MatchCreateManyTenantInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTenantInput | MatchUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTenantInput | MatchUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SMEUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    upsert?: SMEUpsertWithWhereUniqueWithoutTenantInput | SMEUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    set?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    disconnect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    delete?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    update?: SMEUpdateWithWhereUniqueWithoutTenantInput | SMEUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SMEUpdateManyWithWhereWithoutTenantInput | SMEUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SMEScalarWhereInput | SMEScalarWhereInput[]
  }

  export type InvestorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutTenantInput | InvestorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutTenantInput | InvestorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutTenantInput | InvestorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type AdvisorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    upsert?: AdvisorUpsertWithWhereUniqueWithoutTenantInput | AdvisorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    set?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    disconnect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    delete?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    update?: AdvisorUpdateWithWhereUniqueWithoutTenantInput | AdvisorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AdvisorUpdateManyWithWhereWithoutTenantInput | AdvisorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutTenantInput | WorkflowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutTenantInput | WorkflowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutTenantInput | WorkflowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutTenantInput, PushSubscriptionUncheckedCreateWithoutTenantInput> | PushSubscriptionCreateWithoutTenantInput[] | PushSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutTenantInput | PushSubscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutTenantInput | PushSubscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PushSubscriptionCreateManyTenantInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutTenantInput | PushSubscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutTenantInput | PushSubscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutTenantInput | ConversationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutTenantInput | ConversationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutTenantInput | ConversationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MatchCreateWithoutTenantInput, MatchUncheckedCreateWithoutTenantInput> | MatchCreateWithoutTenantInput[] | MatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTenantInput | MatchCreateOrConnectWithoutTenantInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTenantInput | MatchUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MatchCreateManyTenantInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTenantInput | MatchUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTenantInput | MatchUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreatetwoFactorBackupCodesInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutUserInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutUserInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    connect?: AdvisorWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MatchInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchInterestCreateWithoutUserInput, MatchInterestUncheckedCreateWithoutUserInput> | MatchInterestCreateWithoutUserInput[] | MatchInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutUserInput | MatchInterestCreateOrConnectWithoutUserInput[]
    createMany?: MatchInterestCreateManyUserInputEnvelope
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SMEUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    connect?: AdvisorWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MatchInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchInterestCreateWithoutUserInput, MatchInterestUncheckedCreateWithoutUserInput> | MatchInterestCreateWithoutUserInput[] | MatchInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutUserInput | MatchInterestCreateOrConnectWithoutUserInput[]
    createMany?: MatchInterestCreateManyUserInputEnvelope
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumLanguageFieldUpdateOperationsInput = {
    set?: $Enums.Language
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdatetwoFactorBackupCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type SMEUpdateOneWithoutUserNestedInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    upsert?: SMEUpsertWithoutUserInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutUserInput, SMEUpdateWithoutUserInput>, SMEUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    upsert?: AdvisorUpsertWithoutUserInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutUserInput, AdvisorUpdateWithoutUserInput>, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MatchInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchInterestCreateWithoutUserInput, MatchInterestUncheckedCreateWithoutUserInput> | MatchInterestCreateWithoutUserInput[] | MatchInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutUserInput | MatchInterestCreateOrConnectWithoutUserInput[]
    upsert?: MatchInterestUpsertWithWhereUniqueWithoutUserInput | MatchInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchInterestCreateManyUserInputEnvelope
    set?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    disconnect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    delete?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    update?: MatchInterestUpdateWithWhereUniqueWithoutUserInput | MatchInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchInterestUpdateManyWithWhereWithoutUserInput | MatchInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchInterestScalarWhereInput | MatchInterestScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SMEUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    upsert?: SMEUpsertWithoutUserInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutUserInput, SMEUpdateWithoutUserInput>, SMEUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    upsert?: AdvisorUpsertWithoutUserInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutUserInput, AdvisorUpdateWithoutUserInput>, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MatchInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchInterestCreateWithoutUserInput, MatchInterestUncheckedCreateWithoutUserInput> | MatchInterestCreateWithoutUserInput[] | MatchInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutUserInput | MatchInterestCreateOrConnectWithoutUserInput[]
    upsert?: MatchInterestUpsertWithWhereUniqueWithoutUserInput | MatchInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchInterestCreateManyUserInputEnvelope
    set?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    disconnect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    delete?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    update?: MatchInterestUpdateWithWhereUniqueWithoutUserInput | MatchInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchInterestUpdateManyWithWhereWithoutUserInput | MatchInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchInterestScalarWhereInput | MatchInterestScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutSmesInput = {
    create?: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSmeInput = {
    create?: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmeInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutSmeInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutSmeInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutSmeInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutSmeInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceCreateNestedManyWithoutSmeInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutSmeInput = {
    create?: XOR<MatchCreateWithoutSmeInput, MatchUncheckedCreateWithoutSmeInput> | MatchCreateWithoutSmeInput[] | MatchUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSmeInput | MatchCreateOrConnectWithoutSmeInput[]
    createMany?: MatchCreateManySmeInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<MatchCreateWithoutSmeInput, MatchUncheckedCreateWithoutSmeInput> | MatchCreateWithoutSmeInput[] | MatchUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSmeInput | MatchCreateOrConnectWithoutSmeInput[]
    createMany?: MatchCreateManySmeInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type EnumSMEStageFieldUpdateOperationsInput = {
    set?: $Enums.SMEStage
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSMEStatusFieldUpdateOperationsInput = {
    set?: $Enums.SMEStatus
  }

  export type TenantUpdateOneRequiredWithoutSmesNestedInput = {
    create?: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmesInput
    upsert?: TenantUpsertWithoutSmesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSmesInput, TenantUpdateWithoutSmesInput>, TenantUncheckedUpdateWithoutSmesInput>
  }

  export type UserUpdateOneRequiredWithoutSmeNestedInput = {
    create?: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmeInput
    upsert?: UserUpsertWithoutSmeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmeInput, UserUpdateWithoutSmeInput>, UserUncheckedUpdateWithoutSmeInput>
  }

  export type DocumentUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSmeInput | DocumentUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSmeInput | DocumentUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSmeInput | DocumentUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutSmeInput | DealUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutSmeInput | DealUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DealUpdateManyWithWhereWithoutSmeInput | DealUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutSmeNestedInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutSmeInput | CertificationUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutSmeInput | CertificationUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutSmeInput | CertificationUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutSmeNestedInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutSmeInput | WorkflowUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutSmeInput | WorkflowUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutSmeInput | WorkflowUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutSmeInput | DueDiligenceUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutSmeInput | DueDiligenceUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutSmeInput | DueDiligenceUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutSmeNestedInput = {
    create?: XOR<MatchCreateWithoutSmeInput, MatchUncheckedCreateWithoutSmeInput> | MatchCreateWithoutSmeInput[] | MatchUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSmeInput | MatchCreateOrConnectWithoutSmeInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutSmeInput | MatchUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: MatchCreateManySmeInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutSmeInput | MatchUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutSmeInput | MatchUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSmeInput | DocumentUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSmeInput | DocumentUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSmeInput | DocumentUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutSmeInput | DealUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutSmeInput | DealUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DealUpdateManyWithWhereWithoutSmeInput | DealUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutSmeInput | CertificationUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutSmeInput | CertificationUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutSmeInput | CertificationUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutSmeInput | WorkflowUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutSmeInput | WorkflowUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutSmeInput | WorkflowUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput> | DueDiligenceCreateWithoutSmeInput[] | DueDiligenceUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutSmeInput | DueDiligenceCreateOrConnectWithoutSmeInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutSmeInput | DueDiligenceUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DueDiligenceCreateManySmeInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutSmeInput | DueDiligenceUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutSmeInput | DueDiligenceUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<MatchCreateWithoutSmeInput, MatchUncheckedCreateWithoutSmeInput> | MatchCreateWithoutSmeInput[] | MatchUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSmeInput | MatchCreateOrConnectWithoutSmeInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutSmeInput | MatchUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: MatchCreateManySmeInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutSmeInput | MatchUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutSmeInput | MatchUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvestorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvestorInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    connect?: UserWhereUniqueInput
  }

  export type DealInvestorCreateNestedManyWithoutInvestorInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutInvestorInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateCreateNestedManyWithoutLeadInvestorInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type SyndicateMemberCreateNestedManyWithoutInvestorInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type SecondaryListingCreateNestedManyWithoutSellerInput = {
    create?: XOR<SecondaryListingCreateWithoutSellerInput, SecondaryListingUncheckedCreateWithoutSellerInput> | SecondaryListingCreateWithoutSellerInput[] | SecondaryListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutSellerInput | SecondaryListingCreateOrConnectWithoutSellerInput[]
    createMany?: SecondaryListingCreateManySellerInputEnvelope
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
  }

  export type SecondaryTradeCreateNestedManyWithoutBuyerInput = {
    create?: XOR<SecondaryTradeCreateWithoutBuyerInput, SecondaryTradeUncheckedCreateWithoutBuyerInput> | SecondaryTradeCreateWithoutBuyerInput[] | SecondaryTradeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutBuyerInput | SecondaryTradeCreateOrConnectWithoutBuyerInput[]
    createMany?: SecondaryTradeCreateManyBuyerInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type SecondaryTradeCreateNestedManyWithoutSellerInput = {
    create?: XOR<SecondaryTradeCreateWithoutSellerInput, SecondaryTradeUncheckedCreateWithoutSellerInput> | SecondaryTradeCreateWithoutSellerInput[] | SecondaryTradeUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutSellerInput | SecondaryTradeCreateOrConnectWithoutSellerInput[]
    createMany?: SecondaryTradeCreateManySellerInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutInvestorInput = {
    create?: XOR<MatchCreateWithoutInvestorInput, MatchUncheckedCreateWithoutInvestorInput> | MatchCreateWithoutInvestorInput[] | MatchUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInvestorInput | MatchCreateOrConnectWithoutInvestorInput[]
    createMany?: MatchCreateManyInvestorInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type DealInvestorUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type SecondaryListingUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<SecondaryListingCreateWithoutSellerInput, SecondaryListingUncheckedCreateWithoutSellerInput> | SecondaryListingCreateWithoutSellerInput[] | SecondaryListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutSellerInput | SecondaryListingCreateOrConnectWithoutSellerInput[]
    createMany?: SecondaryListingCreateManySellerInputEnvelope
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
  }

  export type SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<SecondaryTradeCreateWithoutBuyerInput, SecondaryTradeUncheckedCreateWithoutBuyerInput> | SecondaryTradeCreateWithoutBuyerInput[] | SecondaryTradeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutBuyerInput | SecondaryTradeCreateOrConnectWithoutBuyerInput[]
    createMany?: SecondaryTradeCreateManyBuyerInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<SecondaryTradeCreateWithoutSellerInput, SecondaryTradeUncheckedCreateWithoutSellerInput> | SecondaryTradeCreateWithoutSellerInput[] | SecondaryTradeUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutSellerInput | SecondaryTradeCreateOrConnectWithoutSellerInput[]
    createMany?: SecondaryTradeCreateManySellerInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<MatchCreateWithoutInvestorInput, MatchUncheckedCreateWithoutInvestorInput> | MatchCreateWithoutInvestorInput[] | MatchUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInvestorInput | MatchCreateOrConnectWithoutInvestorInput[]
    createMany?: MatchCreateManyInvestorInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type EnumInvestorTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvestorType
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type TenantUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvestorsInput
    upsert?: TenantUpsertWithoutInvestorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvestorsInput, TenantUpdateWithoutInvestorsInput>, TenantUncheckedUpdateWithoutInvestorsInput>
  }

  export type UserUpdateOneRequiredWithoutInvestorNestedInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    upsert?: UserUpsertWithoutInvestorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorInput, UserUpdateWithoutInvestorInput>, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type DealInvestorUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutInvestorInput | DealInvestorUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutInvestorInput | DealInvestorUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutInvestorInput | DealInvestorUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutInvestorInput | WorkflowUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutInvestorInput | WorkflowUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutInvestorInput | WorkflowUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUpdateManyWithoutLeadInvestorNestedInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutLeadInvestorInput | SyndicateUpdateManyWithWhereWithoutLeadInvestorInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type SyndicateMemberUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutInvestorInput | SyndicateMemberUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type SecondaryListingUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SecondaryListingCreateWithoutSellerInput, SecondaryListingUncheckedCreateWithoutSellerInput> | SecondaryListingCreateWithoutSellerInput[] | SecondaryListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutSellerInput | SecondaryListingCreateOrConnectWithoutSellerInput[]
    upsert?: SecondaryListingUpsertWithWhereUniqueWithoutSellerInput | SecondaryListingUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SecondaryListingCreateManySellerInputEnvelope
    set?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    disconnect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    delete?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    update?: SecondaryListingUpdateWithWhereUniqueWithoutSellerInput | SecondaryListingUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SecondaryListingUpdateManyWithWhereWithoutSellerInput | SecondaryListingUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SecondaryListingScalarWhereInput | SecondaryListingScalarWhereInput[]
  }

  export type SecondaryTradeUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutBuyerInput, SecondaryTradeUncheckedCreateWithoutBuyerInput> | SecondaryTradeCreateWithoutBuyerInput[] | SecondaryTradeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutBuyerInput | SecondaryTradeCreateOrConnectWithoutBuyerInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutBuyerInput | SecondaryTradeUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: SecondaryTradeCreateManyBuyerInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutBuyerInput | SecondaryTradeUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutBuyerInput | SecondaryTradeUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type SecondaryTradeUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutSellerInput, SecondaryTradeUncheckedCreateWithoutSellerInput> | SecondaryTradeCreateWithoutSellerInput[] | SecondaryTradeUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutSellerInput | SecondaryTradeCreateOrConnectWithoutSellerInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutSellerInput | SecondaryTradeUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SecondaryTradeCreateManySellerInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutSellerInput | SecondaryTradeUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutSellerInput | SecondaryTradeUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<MatchCreateWithoutInvestorInput, MatchUncheckedCreateWithoutInvestorInput> | MatchCreateWithoutInvestorInput[] | MatchUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInvestorInput | MatchCreateOrConnectWithoutInvestorInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutInvestorInput | MatchUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: MatchCreateManyInvestorInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutInvestorInput | MatchUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutInvestorInput | MatchUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutInvestorInput | DealInvestorUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutInvestorInput | DealInvestorUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutInvestorInput | DealInvestorUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutInvestorInput | WorkflowUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutInvestorInput | WorkflowUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutInvestorInput | WorkflowUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput = {
    create?: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput> | SyndicateCreateWithoutLeadInvestorInput[] | SyndicateUncheckedCreateWithoutLeadInvestorInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutLeadInvestorInput | SyndicateCreateOrConnectWithoutLeadInvestorInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput[]
    createMany?: SyndicateCreateManyLeadInvestorInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput | SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutLeadInvestorInput | SyndicateUpdateManyWithWhereWithoutLeadInvestorInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput> | SyndicateMemberCreateWithoutInvestorInput[] | SyndicateMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutInvestorInput | SyndicateMemberCreateOrConnectWithoutInvestorInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: SyndicateMemberCreateManyInvestorInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput | SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutInvestorInput | SyndicateMemberUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SecondaryListingCreateWithoutSellerInput, SecondaryListingUncheckedCreateWithoutSellerInput> | SecondaryListingCreateWithoutSellerInput[] | SecondaryListingUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutSellerInput | SecondaryListingCreateOrConnectWithoutSellerInput[]
    upsert?: SecondaryListingUpsertWithWhereUniqueWithoutSellerInput | SecondaryListingUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SecondaryListingCreateManySellerInputEnvelope
    set?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    disconnect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    delete?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    update?: SecondaryListingUpdateWithWhereUniqueWithoutSellerInput | SecondaryListingUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SecondaryListingUpdateManyWithWhereWithoutSellerInput | SecondaryListingUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SecondaryListingScalarWhereInput | SecondaryListingScalarWhereInput[]
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutBuyerInput, SecondaryTradeUncheckedCreateWithoutBuyerInput> | SecondaryTradeCreateWithoutBuyerInput[] | SecondaryTradeUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutBuyerInput | SecondaryTradeCreateOrConnectWithoutBuyerInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutBuyerInput | SecondaryTradeUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: SecondaryTradeCreateManyBuyerInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutBuyerInput | SecondaryTradeUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutBuyerInput | SecondaryTradeUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutSellerInput, SecondaryTradeUncheckedCreateWithoutSellerInput> | SecondaryTradeCreateWithoutSellerInput[] | SecondaryTradeUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutSellerInput | SecondaryTradeCreateOrConnectWithoutSellerInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutSellerInput | SecondaryTradeUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SecondaryTradeCreateManySellerInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutSellerInput | SecondaryTradeUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutSellerInput | SecondaryTradeUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<MatchCreateWithoutInvestorInput, MatchUncheckedCreateWithoutInvestorInput> | MatchCreateWithoutInvestorInput[] | MatchUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutInvestorInput | MatchCreateOrConnectWithoutInvestorInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutInvestorInput | MatchUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: MatchCreateManyInvestorInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutInvestorInput | MatchUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutInvestorInput | MatchUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type AdvisorCreatespecializationInput = {
    set: string[]
  }

  export type AdvisorCreatecertificationListInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutAdvisorsInput = {
    create?: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAdvisorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdvisorInput = {
    create?: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvisorInput
    connect?: UserWhereUniqueInput
  }

  export type CertificationCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type AdvisoryServiceCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<AdvisoryServiceCreateWithoutAdvisorInput, AdvisoryServiceUncheckedCreateWithoutAdvisorInput> | AdvisoryServiceCreateWithoutAdvisorInput[] | AdvisoryServiceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: AdvisoryServiceCreateOrConnectWithoutAdvisorInput | AdvisoryServiceCreateOrConnectWithoutAdvisorInput[]
    createMany?: AdvisoryServiceCreateManyAdvisorInputEnvelope
    connect?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<BookingCreateWithoutAdvisorInput, BookingUncheckedCreateWithoutAdvisorInput> | BookingCreateWithoutAdvisorInput[] | BookingUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutAdvisorInput | BookingCreateOrConnectWithoutAdvisorInput[]
    createMany?: BookingCreateManyAdvisorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
  }

  export type AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<AdvisoryServiceCreateWithoutAdvisorInput, AdvisoryServiceUncheckedCreateWithoutAdvisorInput> | AdvisoryServiceCreateWithoutAdvisorInput[] | AdvisoryServiceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: AdvisoryServiceCreateOrConnectWithoutAdvisorInput | AdvisoryServiceCreateOrConnectWithoutAdvisorInput[]
    createMany?: AdvisoryServiceCreateManyAdvisorInputEnvelope
    connect?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<BookingCreateWithoutAdvisorInput, BookingUncheckedCreateWithoutAdvisorInput> | BookingCreateWithoutAdvisorInput[] | BookingUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutAdvisorInput | BookingCreateOrConnectWithoutAdvisorInput[]
    createMany?: BookingCreateManyAdvisorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AdvisorUpdatespecializationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdvisorUpdatecertificationListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAdvisorStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdvisorStatus
  }

  export type TenantUpdateOneRequiredWithoutAdvisorsNestedInput = {
    create?: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAdvisorsInput
    upsert?: TenantUpsertWithoutAdvisorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAdvisorsInput, TenantUpdateWithoutAdvisorsInput>, TenantUncheckedUpdateWithoutAdvisorsInput>
  }

  export type UserUpdateOneRequiredWithoutAdvisorNestedInput = {
    create?: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvisorInput
    upsert?: UserUpsertWithoutAdvisorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdvisorInput, UserUpdateWithoutAdvisorInput>, UserUncheckedUpdateWithoutAdvisorInput>
  }

  export type CertificationUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutAdvisorInput | CertificationUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutAdvisorInput | CertificationUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutAdvisorInput | CertificationUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAdvisorInput | WorkflowUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAdvisorInput | WorkflowUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAdvisorInput | WorkflowUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutAdvisorInput | DueDiligenceUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type AdvisoryServiceUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<AdvisoryServiceCreateWithoutAdvisorInput, AdvisoryServiceUncheckedCreateWithoutAdvisorInput> | AdvisoryServiceCreateWithoutAdvisorInput[] | AdvisoryServiceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: AdvisoryServiceCreateOrConnectWithoutAdvisorInput | AdvisoryServiceCreateOrConnectWithoutAdvisorInput[]
    upsert?: AdvisoryServiceUpsertWithWhereUniqueWithoutAdvisorInput | AdvisoryServiceUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: AdvisoryServiceCreateManyAdvisorInputEnvelope
    set?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    disconnect?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    delete?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    connect?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    update?: AdvisoryServiceUpdateWithWhereUniqueWithoutAdvisorInput | AdvisoryServiceUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: AdvisoryServiceUpdateManyWithWhereWithoutAdvisorInput | AdvisoryServiceUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: AdvisoryServiceScalarWhereInput | AdvisoryServiceScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<BookingCreateWithoutAdvisorInput, BookingUncheckedCreateWithoutAdvisorInput> | BookingCreateWithoutAdvisorInput[] | BookingUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutAdvisorInput | BookingCreateOrConnectWithoutAdvisorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutAdvisorInput | BookingUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: BookingCreateManyAdvisorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutAdvisorInput | BookingUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutAdvisorInput | BookingUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutAdvisorInput | CertificationUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutAdvisorInput | CertificationUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutAdvisorInput | CertificationUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAdvisorInput | WorkflowUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAdvisorInput | WorkflowUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAdvisorInput | WorkflowUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput> | DueDiligenceCreateWithoutAdvisorInput[] | DueDiligenceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: DueDiligenceCreateOrConnectWithoutAdvisorInput | DueDiligenceCreateOrConnectWithoutAdvisorInput[]
    upsert?: DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: DueDiligenceCreateManyAdvisorInputEnvelope
    set?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    disconnect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    delete?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    connect?: DueDiligenceWhereUniqueInput | DueDiligenceWhereUniqueInput[]
    update?: DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput | DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: DueDiligenceUpdateManyWithWhereWithoutAdvisorInput | DueDiligenceUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
  }

  export type AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<AdvisoryServiceCreateWithoutAdvisorInput, AdvisoryServiceUncheckedCreateWithoutAdvisorInput> | AdvisoryServiceCreateWithoutAdvisorInput[] | AdvisoryServiceUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: AdvisoryServiceCreateOrConnectWithoutAdvisorInput | AdvisoryServiceCreateOrConnectWithoutAdvisorInput[]
    upsert?: AdvisoryServiceUpsertWithWhereUniqueWithoutAdvisorInput | AdvisoryServiceUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: AdvisoryServiceCreateManyAdvisorInputEnvelope
    set?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    disconnect?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    delete?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    connect?: AdvisoryServiceWhereUniqueInput | AdvisoryServiceWhereUniqueInput[]
    update?: AdvisoryServiceUpdateWithWhereUniqueWithoutAdvisorInput | AdvisoryServiceUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: AdvisoryServiceUpdateManyWithWhereWithoutAdvisorInput | AdvisoryServiceUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: AdvisoryServiceScalarWhereInput | AdvisoryServiceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<BookingCreateWithoutAdvisorInput, BookingUncheckedCreateWithoutAdvisorInput> | BookingCreateWithoutAdvisorInput[] | BookingUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutAdvisorInput | BookingCreateOrConnectWithoutAdvisorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutAdvisorInput | BookingUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: BookingCreateManyAdvisorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutAdvisorInput | BookingUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutAdvisorInput | BookingUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDealsInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutDealsInput = {
    create?: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDealsInput
    connect?: SMEWhereUniqueInput
  }

  export type DealInvestorCreateNestedManyWithoutDealInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutDealInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateCreateNestedManyWithoutDealInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutDealInput = {
    create?: XOR<ConversationCreateWithoutDealInput, ConversationUncheckedCreateWithoutDealInput> | ConversationCreateWithoutDealInput[] | ConversationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutDealInput | ConversationCreateOrConnectWithoutDealInput[]
    createMany?: ConversationCreateManyDealInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type DealInvestorUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type SyndicateUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<ConversationCreateWithoutDealInput, ConversationUncheckedCreateWithoutDealInput> | ConversationCreateWithoutDealInput[] | ConversationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutDealInput | ConversationCreateOrConnectWithoutDealInput[]
    createMany?: ConversationCreateManyDealInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type EnumDealStatusFieldUpdateOperationsInput = {
    set?: $Enums.DealStatus
  }

  export type TenantUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    upsert?: TenantUpsertWithoutDealsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDealsInput, TenantUpdateWithoutDealsInput>, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type SMEUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDealsInput
    upsert?: SMEUpsertWithoutDealsInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDealsInput, SMEUpdateWithoutDealsInput>, SMEUncheckedUpdateWithoutDealsInput>
  }

  export type DealInvestorUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutDealInput | DealInvestorUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutDealInput | DealInvestorUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutDealInput | DealInvestorUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutDealNestedInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutDealInput | WorkflowUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutDealInput | WorkflowUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutDealInput | WorkflowUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUpdateManyWithoutDealNestedInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutDealInput | SyndicateUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutDealInput | SyndicateUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutDealInput | SyndicateUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutDealNestedInput = {
    create?: XOR<ConversationCreateWithoutDealInput, ConversationUncheckedCreateWithoutDealInput> | ConversationCreateWithoutDealInput[] | ConversationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutDealInput | ConversationCreateOrConnectWithoutDealInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutDealInput | ConversationUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ConversationCreateManyDealInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutDealInput | ConversationUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutDealInput | ConversationUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type DealInvestorUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutDealInput | DealInvestorUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutDealInput | DealInvestorUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutDealInput | DealInvestorUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutDealInput | WorkflowUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutDealInput | WorkflowUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutDealInput | WorkflowUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type SyndicateUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput> | SyndicateCreateWithoutDealInput[] | SyndicateUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SyndicateCreateOrConnectWithoutDealInput | SyndicateCreateOrConnectWithoutDealInput[]
    upsert?: SyndicateUpsertWithWhereUniqueWithoutDealInput | SyndicateUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SyndicateCreateManyDealInputEnvelope
    set?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    disconnect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    delete?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    connect?: SyndicateWhereUniqueInput | SyndicateWhereUniqueInput[]
    update?: SyndicateUpdateWithWhereUniqueWithoutDealInput | SyndicateUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SyndicateUpdateManyWithWhereWithoutDealInput | SyndicateUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<ConversationCreateWithoutDealInput, ConversationUncheckedCreateWithoutDealInput> | ConversationCreateWithoutDealInput[] | ConversationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutDealInput | ConversationCreateOrConnectWithoutDealInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutDealInput | ConversationUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ConversationCreateManyDealInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutDealInput | ConversationUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutDealInput | ConversationUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type DealCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInvestorsInput
    connect?: DealWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutDealInvestmentsInput = {
    create?: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutDealInvestmentsInput
    connect?: InvestorWhereUniqueInput
  }

  export type SecondaryListingCreateNestedManyWithoutDealInvestorInput = {
    create?: XOR<SecondaryListingCreateWithoutDealInvestorInput, SecondaryListingUncheckedCreateWithoutDealInvestorInput> | SecondaryListingCreateWithoutDealInvestorInput[] | SecondaryListingUncheckedCreateWithoutDealInvestorInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutDealInvestorInput | SecondaryListingCreateOrConnectWithoutDealInvestorInput[]
    createMany?: SecondaryListingCreateManyDealInvestorInputEnvelope
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutDealInvestmentInput = {
    create?: XOR<PaymentCreateWithoutDealInvestmentInput, PaymentUncheckedCreateWithoutDealInvestmentInput> | PaymentCreateWithoutDealInvestmentInput[] | PaymentUncheckedCreateWithoutDealInvestmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDealInvestmentInput | PaymentCreateOrConnectWithoutDealInvestmentInput[]
    createMany?: PaymentCreateManyDealInvestmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SecondaryListingUncheckedCreateNestedManyWithoutDealInvestorInput = {
    create?: XOR<SecondaryListingCreateWithoutDealInvestorInput, SecondaryListingUncheckedCreateWithoutDealInvestorInput> | SecondaryListingCreateWithoutDealInvestorInput[] | SecondaryListingUncheckedCreateWithoutDealInvestorInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutDealInvestorInput | SecondaryListingCreateOrConnectWithoutDealInvestorInput[]
    createMany?: SecondaryListingCreateManyDealInvestorInputEnvelope
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutDealInvestmentInput = {
    create?: XOR<PaymentCreateWithoutDealInvestmentInput, PaymentUncheckedCreateWithoutDealInvestmentInput> | PaymentCreateWithoutDealInvestmentInput[] | PaymentUncheckedCreateWithoutDealInvestmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDealInvestmentInput | PaymentCreateOrConnectWithoutDealInvestmentInput[]
    createMany?: PaymentCreateManyDealInvestmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvestmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvestmentStatus
  }

  export type DealUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInvestorsInput
    upsert?: DealUpsertWithoutInvestorsInput
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutInvestorsInput, DealUpdateWithoutInvestorsInput>, DealUncheckedUpdateWithoutInvestorsInput>
  }

  export type InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput = {
    create?: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutDealInvestmentsInput
    upsert?: InvestorUpsertWithoutDealInvestmentsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutDealInvestmentsInput, InvestorUpdateWithoutDealInvestmentsInput>, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
  }

  export type SecondaryListingUpdateManyWithoutDealInvestorNestedInput = {
    create?: XOR<SecondaryListingCreateWithoutDealInvestorInput, SecondaryListingUncheckedCreateWithoutDealInvestorInput> | SecondaryListingCreateWithoutDealInvestorInput[] | SecondaryListingUncheckedCreateWithoutDealInvestorInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutDealInvestorInput | SecondaryListingCreateOrConnectWithoutDealInvestorInput[]
    upsert?: SecondaryListingUpsertWithWhereUniqueWithoutDealInvestorInput | SecondaryListingUpsertWithWhereUniqueWithoutDealInvestorInput[]
    createMany?: SecondaryListingCreateManyDealInvestorInputEnvelope
    set?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    disconnect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    delete?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    update?: SecondaryListingUpdateWithWhereUniqueWithoutDealInvestorInput | SecondaryListingUpdateWithWhereUniqueWithoutDealInvestorInput[]
    updateMany?: SecondaryListingUpdateManyWithWhereWithoutDealInvestorInput | SecondaryListingUpdateManyWithWhereWithoutDealInvestorInput[]
    deleteMany?: SecondaryListingScalarWhereInput | SecondaryListingScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutDealInvestmentNestedInput = {
    create?: XOR<PaymentCreateWithoutDealInvestmentInput, PaymentUncheckedCreateWithoutDealInvestmentInput> | PaymentCreateWithoutDealInvestmentInput[] | PaymentUncheckedCreateWithoutDealInvestmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDealInvestmentInput | PaymentCreateOrConnectWithoutDealInvestmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutDealInvestmentInput | PaymentUpsertWithWhereUniqueWithoutDealInvestmentInput[]
    createMany?: PaymentCreateManyDealInvestmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutDealInvestmentInput | PaymentUpdateWithWhereUniqueWithoutDealInvestmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutDealInvestmentInput | PaymentUpdateManyWithWhereWithoutDealInvestmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SecondaryListingUncheckedUpdateManyWithoutDealInvestorNestedInput = {
    create?: XOR<SecondaryListingCreateWithoutDealInvestorInput, SecondaryListingUncheckedCreateWithoutDealInvestorInput> | SecondaryListingCreateWithoutDealInvestorInput[] | SecondaryListingUncheckedCreateWithoutDealInvestorInput[]
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutDealInvestorInput | SecondaryListingCreateOrConnectWithoutDealInvestorInput[]
    upsert?: SecondaryListingUpsertWithWhereUniqueWithoutDealInvestorInput | SecondaryListingUpsertWithWhereUniqueWithoutDealInvestorInput[]
    createMany?: SecondaryListingCreateManyDealInvestorInputEnvelope
    set?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    disconnect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    delete?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    connect?: SecondaryListingWhereUniqueInput | SecondaryListingWhereUniqueInput[]
    update?: SecondaryListingUpdateWithWhereUniqueWithoutDealInvestorInput | SecondaryListingUpdateWithWhereUniqueWithoutDealInvestorInput[]
    updateMany?: SecondaryListingUpdateManyWithWhereWithoutDealInvestorInput | SecondaryListingUpdateManyWithWhereWithoutDealInvestorInput[]
    deleteMany?: SecondaryListingScalarWhereInput | SecondaryListingScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutDealInvestmentNestedInput = {
    create?: XOR<PaymentCreateWithoutDealInvestmentInput, PaymentUncheckedCreateWithoutDealInvestmentInput> | PaymentCreateWithoutDealInvestmentInput[] | PaymentUncheckedCreateWithoutDealInvestmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDealInvestmentInput | PaymentCreateOrConnectWithoutDealInvestmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutDealInvestmentInput | PaymentUpsertWithWhereUniqueWithoutDealInvestmentInput[]
    createMany?: PaymentCreateManyDealInvestmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutDealInvestmentInput | PaymentUpdateWithWhereUniqueWithoutDealInvestmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutDealInvestmentInput | PaymentUpdateManyWithWhereWithoutDealInvestmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutDocumentsInput = {
    create?: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDocumentsInput
    connect?: SMEWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    connect?: DealWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    upsert?: TenantUpsertWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentsInput, TenantUpdateWithoutDocumentsInput>, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMEUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDocumentsInput
    upsert?: SMEUpsertWithoutDocumentsInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDocumentsInput, SMEUpdateWithoutDocumentsInput>, SMEUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    upsert?: DealUpsertWithoutDocumentsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutDocumentsInput, DealUpdateWithoutDocumentsInput>, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMECreateNestedOneWithoutCertificationsInput = {
    create?: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: SMECreateOrConnectWithoutCertificationsInput
    connect?: SMEWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutCertificationsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type EnumCertificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.CertificationStatus
  }

  export type SMEUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: SMECreateOrConnectWithoutCertificationsInput
    upsert?: SMEUpsertWithoutCertificationsInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutCertificationsInput, SMEUpdateWithoutCertificationsInput>, SMEUncheckedUpdateWithoutCertificationsInput>
  }

  export type AdvisorUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutCertificationsInput
    upsert?: AdvisorUpsertWithoutCertificationsInput
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutCertificationsInput, AdvisorUpdateWithoutCertificationsInput>, AdvisorUncheckedUpdateWithoutCertificationsInput>
  }

  export type TenantCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: SMECreateOrConnectWithoutWorkflowsInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutWorkflowsInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutWorkflowsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: DealCreateOrConnectWithoutWorkflowsInput
    connect?: DealWhereUniqueInput
  }

  export type EnumWorkflowTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowType
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type TenantUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowsInput
    upsert?: TenantUpsertWithoutWorkflowsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWorkflowsInput, TenantUpdateWithoutWorkflowsInput>, TenantUncheckedUpdateWithoutWorkflowsInput>
  }

  export type SMEUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: SMECreateOrConnectWithoutWorkflowsInput
    upsert?: SMEUpsertWithoutWorkflowsInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutWorkflowsInput, SMEUpdateWithoutWorkflowsInput>, SMEUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutWorkflowsInput
    upsert?: InvestorUpsertWithoutWorkflowsInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutWorkflowsInput, InvestorUpdateWithoutWorkflowsInput>, InvestorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AdvisorUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutWorkflowsInput
    upsert?: AdvisorUpsertWithoutWorkflowsInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutWorkflowsInput, AdvisorUpdateWithoutWorkflowsInput>, AdvisorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type DealUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: DealCreateOrConnectWithoutWorkflowsInput
    upsert?: DealUpsertWithoutWorkflowsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutWorkflowsInput, DealUpdateWithoutWorkflowsInput>, DealUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorCreateNestedOneWithoutLeadSyndicatesInput = {
    create?: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutLeadSyndicatesInput
    connect?: InvestorWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutSyndicatesInput = {
    create?: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSyndicatesInput
    connect?: DealWhereUniqueInput
  }

  export type SyndicateMemberCreateNestedManyWithoutSyndicateInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
  }

  export type EnumSyndicateStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyndicateStatus
  }

  export type InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput = {
    create?: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutLeadSyndicatesInput
    upsert?: InvestorUpsertWithoutLeadSyndicatesInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutLeadSyndicatesInput, InvestorUpdateWithoutLeadSyndicatesInput>, InvestorUncheckedUpdateWithoutLeadSyndicatesInput>
  }

  export type DealUpdateOneWithoutSyndicatesNestedInput = {
    create?: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSyndicatesInput
    upsert?: DealUpsertWithoutSyndicatesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutSyndicatesInput, DealUpdateWithoutSyndicatesInput>, DealUncheckedUpdateWithoutSyndicatesInput>
  }

  export type SyndicateMemberUpdateManyWithoutSyndicateNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput | SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput = {
    create?: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput> | SyndicateMemberCreateWithoutSyndicateInput[] | SyndicateMemberUncheckedCreateWithoutSyndicateInput[]
    connectOrCreate?: SyndicateMemberCreateOrConnectWithoutSyndicateInput | SyndicateMemberCreateOrConnectWithoutSyndicateInput[]
    upsert?: SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput[]
    createMany?: SyndicateMemberCreateManySyndicateInputEnvelope
    set?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    disconnect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    delete?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    connect?: SyndicateMemberWhereUniqueInput | SyndicateMemberWhereUniqueInput[]
    update?: SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput | SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput[]
    updateMany?: SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput | SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput[]
    deleteMany?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
  }

  export type SyndicateCreateNestedOneWithoutMembersInput = {
    create?: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SyndicateCreateOrConnectWithoutMembersInput
    connect?: SyndicateWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutSyndicateMembershipsInput = {
    create?: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutSyndicateMembershipsInput
    connect?: InvestorWhereUniqueInput
  }

  export type EnumSyndicateMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyndicateMemberStatus
  }

  export type SyndicateUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SyndicateCreateOrConnectWithoutMembersInput
    upsert?: SyndicateUpsertWithoutMembersInput
    connect?: SyndicateWhereUniqueInput
    update?: XOR<XOR<SyndicateUpdateToOneWithWhereWithoutMembersInput, SyndicateUpdateWithoutMembersInput>, SyndicateUncheckedUpdateWithoutMembersInput>
  }

  export type InvestorUpdateOneRequiredWithoutSyndicateMembershipsNestedInput = {
    create?: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutSyndicateMembershipsInput
    upsert?: InvestorUpsertWithoutSyndicateMembershipsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutSyndicateMembershipsInput, InvestorUpdateWithoutSyndicateMembershipsInput>, InvestorUncheckedUpdateWithoutSyndicateMembershipsInput>
  }

  export type DueDiligenceCreatestrengthsInput = {
    set: string[]
  }

  export type DueDiligenceCreateweaknessesInput = {
    set: string[]
  }

  export type DueDiligenceCreaterecommendationsInput = {
    set: string[]
  }

  export type DueDiligenceCreateredFlagsInput = {
    set: string[]
  }

  export type SMECreateNestedOneWithoutDueDiligencesInput = {
    create?: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: SMECreateOrConnectWithoutDueDiligencesInput
    connect?: SMEWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutDueDiligencesInput = {
    create?: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutDueDiligencesInput
    connect?: AdvisorWhereUniqueInput
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type DueDiligenceUpdatestrengthsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DueDiligenceUpdateweaknessesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DueDiligenceUpdaterecommendationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DueDiligenceUpdateredFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumDueDiligenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DueDiligenceStatus
  }

  export type SMEUpdateOneRequiredWithoutDueDiligencesNestedInput = {
    create?: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: SMECreateOrConnectWithoutDueDiligencesInput
    upsert?: SMEUpsertWithoutDueDiligencesInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDueDiligencesInput, SMEUpdateWithoutDueDiligencesInput>, SMEUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type AdvisorUpdateOneWithoutDueDiligencesNestedInput = {
    create?: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutDueDiligencesInput
    upsert?: AdvisorUpsertWithoutDueDiligencesInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutDueDiligencesInput, AdvisorUpdateWithoutDueDiligencesInput>, AdvisorUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumPostCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PostCategory
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommunityPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommunityPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommentsInput
    upsert?: CommunityPostUpsertWithoutCommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<XOR<CommunityPostUpdateToOneWithWhereWithoutCommentsInput, CommunityPostUpdateWithoutCommentsInput>, CommunityPostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type InvestorCreateNestedOneWithoutSecondaryListingsInput = {
    create?: XOR<InvestorCreateWithoutSecondaryListingsInput, InvestorUncheckedCreateWithoutSecondaryListingsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutSecondaryListingsInput
    connect?: InvestorWhereUniqueInput
  }

  export type DealInvestorCreateNestedOneWithoutSecondaryListingsInput = {
    create?: XOR<DealInvestorCreateWithoutSecondaryListingsInput, DealInvestorUncheckedCreateWithoutSecondaryListingsInput>
    connectOrCreate?: DealInvestorCreateOrConnectWithoutSecondaryListingsInput
    connect?: DealInvestorWhereUniqueInput
  }

  export type SecondaryTradeCreateNestedManyWithoutListingInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type SecondaryTradeUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type InvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput = {
    create?: XOR<InvestorCreateWithoutSecondaryListingsInput, InvestorUncheckedCreateWithoutSecondaryListingsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutSecondaryListingsInput
    upsert?: InvestorUpsertWithoutSecondaryListingsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutSecondaryListingsInput, InvestorUpdateWithoutSecondaryListingsInput>, InvestorUncheckedUpdateWithoutSecondaryListingsInput>
  }

  export type DealInvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput = {
    create?: XOR<DealInvestorCreateWithoutSecondaryListingsInput, DealInvestorUncheckedCreateWithoutSecondaryListingsInput>
    connectOrCreate?: DealInvestorCreateOrConnectWithoutSecondaryListingsInput
    upsert?: DealInvestorUpsertWithoutSecondaryListingsInput
    connect?: DealInvestorWhereUniqueInput
    update?: XOR<XOR<DealInvestorUpdateToOneWithWhereWithoutSecondaryListingsInput, DealInvestorUpdateWithoutSecondaryListingsInput>, DealInvestorUncheckedUpdateWithoutSecondaryListingsInput>
  }

  export type SecondaryTradeUpdateManyWithoutListingNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutListingInput | SecondaryTradeUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutListingInput | SecondaryTradeUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutListingInput | SecondaryTradeUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput> | SecondaryTradeCreateWithoutListingInput[] | SecondaryTradeUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SecondaryTradeCreateOrConnectWithoutListingInput | SecondaryTradeCreateOrConnectWithoutListingInput[]
    upsert?: SecondaryTradeUpsertWithWhereUniqueWithoutListingInput | SecondaryTradeUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SecondaryTradeCreateManyListingInputEnvelope
    set?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    disconnect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    delete?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    connect?: SecondaryTradeWhereUniqueInput | SecondaryTradeWhereUniqueInput[]
    update?: SecondaryTradeUpdateWithWhereUniqueWithoutListingInput | SecondaryTradeUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SecondaryTradeUpdateManyWithWhereWithoutListingInput | SecondaryTradeUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
  }

  export type SecondaryListingCreateNestedOneWithoutTradesInput = {
    create?: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutTradesInput
    connect?: SecondaryListingWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutTradesAsBuyerInput = {
    create?: XOR<InvestorCreateWithoutTradesAsBuyerInput, InvestorUncheckedCreateWithoutTradesAsBuyerInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutTradesAsBuyerInput
    connect?: InvestorWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutTradesAsSellerInput = {
    create?: XOR<InvestorCreateWithoutTradesAsSellerInput, InvestorUncheckedCreateWithoutTradesAsSellerInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutTradesAsSellerInput
    connect?: InvestorWhereUniqueInput
  }

  export type EnumTradeStatusFieldUpdateOperationsInput = {
    set?: $Enums.TradeStatus
  }

  export type SecondaryListingUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
    connectOrCreate?: SecondaryListingCreateOrConnectWithoutTradesInput
    upsert?: SecondaryListingUpsertWithoutTradesInput
    connect?: SecondaryListingWhereUniqueInput
    update?: XOR<XOR<SecondaryListingUpdateToOneWithWhereWithoutTradesInput, SecondaryListingUpdateWithoutTradesInput>, SecondaryListingUncheckedUpdateWithoutTradesInput>
  }

  export type InvestorUpdateOneRequiredWithoutTradesAsBuyerNestedInput = {
    create?: XOR<InvestorCreateWithoutTradesAsBuyerInput, InvestorUncheckedCreateWithoutTradesAsBuyerInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutTradesAsBuyerInput
    upsert?: InvestorUpsertWithoutTradesAsBuyerInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutTradesAsBuyerInput, InvestorUpdateWithoutTradesAsBuyerInput>, InvestorUncheckedUpdateWithoutTradesAsBuyerInput>
  }

  export type InvestorUpdateOneRequiredWithoutTradesAsSellerNestedInput = {
    create?: XOR<InvestorCreateWithoutTradesAsSellerInput, InvestorUncheckedCreateWithoutTradesAsSellerInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutTradesAsSellerInput
    upsert?: InvestorUpsertWithoutTradesAsSellerInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutTradesAsSellerInput, InvestorUpdateWithoutTradesAsSellerInput>, InvestorUncheckedUpdateWithoutTradesAsSellerInput>
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantCreateNestedOneWithoutConversationsInput = {
    create?: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutConversationsInput
    connect?: TenantWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutConversationsInput = {
    create?: XOR<DealCreateWithoutConversationsInput, DealUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: DealCreateOrConnectWithoutConversationsInput
    connect?: DealWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutConversationsInput
    upsert?: TenantUpsertWithoutConversationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutConversationsInput, TenantUpdateWithoutConversationsInput>, TenantUncheckedUpdateWithoutConversationsInput>
  }

  export type DealUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<DealCreateWithoutConversationsInput, DealUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: DealCreateOrConnectWithoutConversationsInput
    upsert?: DealUpsertWithoutConversationsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutConversationsInput, DealUpdateWithoutConversationsInput>, DealUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageParticipantsInput = {
    create?: XOR<UserCreateWithoutMessageParticipantsInput, UserUncheckedCreateWithoutMessageParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutMessageParticipantsInput, UserUncheckedCreateWithoutMessageParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageParticipantsInput
    upsert?: UserUpsertWithoutMessageParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageParticipantsInput, UserUpdateWithoutMessageParticipantsInput>, UserUncheckedUpdateWithoutMessageParticipantsInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type AdvisoryServiceCreatefeaturesInput = {
    set: string[]
  }

  export type AdvisorCreateNestedOneWithoutServicesInput = {
    create?: XOR<AdvisorCreateWithoutServicesInput, AdvisorUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutServicesInput
    connect?: AdvisorWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AdvisoryServiceUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdvisorUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<AdvisorCreateWithoutServicesInput, AdvisorUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutServicesInput
    upsert?: AdvisorUpsertWithoutServicesInput
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutServicesInput, AdvisorUpdateWithoutServicesInput>, AdvisorUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutBookingsInput = {
    create?: XOR<AdvisorCreateWithoutBookingsInput, AdvisorUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutBookingsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type AdvisoryServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<AdvisoryServiceCreateWithoutBookingsInput, AdvisoryServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AdvisoryServiceCreateOrConnectWithoutBookingsInput
    connect?: AdvisoryServiceWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type AdvisorUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<AdvisorCreateWithoutBookingsInput, AdvisorUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutBookingsInput
    upsert?: AdvisorUpsertWithoutBookingsInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutBookingsInput, AdvisorUpdateWithoutBookingsInput>, AdvisorUncheckedUpdateWithoutBookingsInput>
  }

  export type AdvisoryServiceUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<AdvisoryServiceCreateWithoutBookingsInput, AdvisoryServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: AdvisoryServiceCreateOrConnectWithoutBookingsInput
    upsert?: AdvisoryServiceUpsertWithoutBookingsInput
    disconnect?: AdvisoryServiceWhereInput | boolean
    delete?: AdvisoryServiceWhereInput | boolean
    connect?: AdvisoryServiceWhereUniqueInput
    update?: XOR<XOR<AdvisoryServiceUpdateToOneWithWhereWithoutBookingsInput, AdvisoryServiceUpdateWithoutBookingsInput>, AdvisoryServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutMatchesInput = {
    create?: XOR<TenantCreateWithoutMatchesInput, TenantUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMatchesInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutMatchesInput = {
    create?: XOR<SMECreateWithoutMatchesInput, SMEUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: SMECreateOrConnectWithoutMatchesInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutMatchesInput = {
    create?: XOR<InvestorCreateWithoutMatchesInput, InvestorUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutMatchesInput
    connect?: InvestorWhereUniqueInput
  }

  export type MatchInterestCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchInterestCreateWithoutMatchInput, MatchInterestUncheckedCreateWithoutMatchInput> | MatchInterestCreateWithoutMatchInput[] | MatchInterestUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutMatchInput | MatchInterestCreateOrConnectWithoutMatchInput[]
    createMany?: MatchInterestCreateManyMatchInputEnvelope
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
  }

  export type MatchInterestUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchInterestCreateWithoutMatchInput, MatchInterestUncheckedCreateWithoutMatchInput> | MatchInterestCreateWithoutMatchInput[] | MatchInterestUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutMatchInput | MatchInterestCreateOrConnectWithoutMatchInput[]
    createMany?: MatchInterestCreateManyMatchInputEnvelope
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type TenantUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<TenantCreateWithoutMatchesInput, TenantUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMatchesInput
    upsert?: TenantUpsertWithoutMatchesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMatchesInput, TenantUpdateWithoutMatchesInput>, TenantUncheckedUpdateWithoutMatchesInput>
  }

  export type SMEUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<SMECreateWithoutMatchesInput, SMEUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: SMECreateOrConnectWithoutMatchesInput
    upsert?: SMEUpsertWithoutMatchesInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutMatchesInput, SMEUpdateWithoutMatchesInput>, SMEUncheckedUpdateWithoutMatchesInput>
  }

  export type InvestorUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<InvestorCreateWithoutMatchesInput, InvestorUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutMatchesInput
    upsert?: InvestorUpsertWithoutMatchesInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutMatchesInput, InvestorUpdateWithoutMatchesInput>, InvestorUncheckedUpdateWithoutMatchesInput>
  }

  export type MatchInterestUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchInterestCreateWithoutMatchInput, MatchInterestUncheckedCreateWithoutMatchInput> | MatchInterestCreateWithoutMatchInput[] | MatchInterestUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutMatchInput | MatchInterestCreateOrConnectWithoutMatchInput[]
    upsert?: MatchInterestUpsertWithWhereUniqueWithoutMatchInput | MatchInterestUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchInterestCreateManyMatchInputEnvelope
    set?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    disconnect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    delete?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    update?: MatchInterestUpdateWithWhereUniqueWithoutMatchInput | MatchInterestUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchInterestUpdateManyWithWhereWithoutMatchInput | MatchInterestUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchInterestScalarWhereInput | MatchInterestScalarWhereInput[]
  }

  export type MatchInterestUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchInterestCreateWithoutMatchInput, MatchInterestUncheckedCreateWithoutMatchInput> | MatchInterestCreateWithoutMatchInput[] | MatchInterestUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchInterestCreateOrConnectWithoutMatchInput | MatchInterestCreateOrConnectWithoutMatchInput[]
    upsert?: MatchInterestUpsertWithWhereUniqueWithoutMatchInput | MatchInterestUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchInterestCreateManyMatchInputEnvelope
    set?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    disconnect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    delete?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    connect?: MatchInterestWhereUniqueInput | MatchInterestWhereUniqueInput[]
    update?: MatchInterestUpdateWithWhereUniqueWithoutMatchInput | MatchInterestUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchInterestUpdateManyWithWhereWithoutMatchInput | MatchInterestUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchInterestScalarWhereInput | MatchInterestScalarWhereInput[]
  }

  export type MatchCreateNestedOneWithoutInterestsInput = {
    create?: XOR<MatchCreateWithoutInterestsInput, MatchUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutInterestsInput
    connect?: MatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchInterestsInput = {
    create?: XOR<UserCreateWithoutMatchInterestsInput, UserUncheckedCreateWithoutMatchInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type MatchUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<MatchCreateWithoutInterestsInput, MatchUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutInterestsInput
    upsert?: MatchUpsertWithoutInterestsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutInterestsInput, MatchUpdateWithoutInterestsInput>, MatchUncheckedUpdateWithoutInterestsInput>
  }

  export type UserUpdateOneRequiredWithoutMatchInterestsNestedInput = {
    create?: XOR<UserCreateWithoutMatchInterestsInput, UserUncheckedCreateWithoutMatchInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchInterestsInput
    upsert?: UserUpsertWithoutMatchInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchInterestsInput, UserUpdateWithoutMatchInterestsInput>, UserUncheckedUpdateWithoutMatchInterestsInput>
  }

  export type TenantCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<TenantCreateWithoutPushSubscriptionsInput, TenantUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPushSubscriptionsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<TenantCreateWithoutPushSubscriptionsInput, TenantUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: TenantUpsertWithoutPushSubscriptionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPushSubscriptionsInput, TenantUpdateWithoutPushSubscriptionsInput>, TenantUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: UserUpsertWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionsInput, UserUpdateWithoutPushSubscriptionsInput>, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type DealInvestorCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<DealInvestorCreateWithoutPaymentsInput, DealInvestorUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: DealInvestorCreateOrConnectWithoutPaymentsInput
    connect?: DealInvestorWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type DealInvestorUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<DealInvestorCreateWithoutPaymentsInput, DealInvestorUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: DealInvestorCreateOrConnectWithoutPaymentsInput
    upsert?: DealInvestorUpsertWithoutPaymentsInput
    disconnect?: DealInvestorWhereInput | boolean
    delete?: DealInvestorWhereInput | boolean
    connect?: DealInvestorWhereUniqueInput
    update?: XOR<XOR<DealInvestorUpdateToOneWithWhereWithoutPaymentsInput, DealInvestorUpdateWithoutPaymentsInput>, DealInvestorUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSMEStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageFilter<$PrismaModel> | $Enums.SMEStage
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSMEStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusFilter<$PrismaModel> | $Enums.SMEStatus
  }

  export type NestedEnumSMEStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageWithAggregatesFilter<$PrismaModel> | $Enums.SMEStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStageFilter<$PrismaModel>
    _max?: NestedEnumSMEStageFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel> | $Enums.SMEStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStatusFilter<$PrismaModel>
    _max?: NestedEnumSMEStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvestorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeFilter<$PrismaModel> | $Enums.InvestorType
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvestorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestorTypeFilter<$PrismaModel>
    _max?: NestedEnumInvestorTypeFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdvisorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusFilter<$PrismaModel> | $Enums.AdvisorStatus
  }

  export type NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvisorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvisorStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvisorStatusFilter<$PrismaModel>
  }

  export type NestedEnumDealStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusFilter<$PrismaModel> | $Enums.DealStatus
  }

  export type NestedEnumDealStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealStatusFilter<$PrismaModel>
    _max?: NestedEnumDealStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvestmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusFilter<$PrismaModel> | $Enums.InvestmentStatus
  }

  export type NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeFilter<$PrismaModel> | $Enums.WorkflowType
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyndicateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusFilter<$PrismaModel> | $Enums.SyndicateStatus
  }

  export type NestedEnumSyndicateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateStatus | EnumSyndicateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateStatus[] | ListEnumSyndicateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyndicateMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
  }

  export type NestedEnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyndicateMemberStatus | EnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyndicateMemberStatus[] | ListEnumSyndicateMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyndicateMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyndicateMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumSyndicateMemberStatusFilter<$PrismaModel>
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedEnumDueDiligenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusFilter<$PrismaModel> | $Enums.DueDiligenceStatus
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type NestedEnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DueDiligenceStatus | EnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DueDiligenceStatus[] | ListEnumDueDiligenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDueDiligenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DueDiligenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
    _max?: NestedEnumDueDiligenceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryFilter<$PrismaModel> | $Enums.PostCategory
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PostCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostCategoryFilter<$PrismaModel>
    _max?: NestedEnumPostCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusFilter<$PrismaModel> | $Enums.TradeStatus
  }

  export type NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SMECreateWithoutTenantInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutTenantInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput>
  }

  export type SMECreateManyTenantInputEnvelope = {
    data: SMECreateManyTenantInput | SMECreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvestorCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput>
  }

  export type InvestorCreateManyTenantInputEnvelope = {
    data: InvestorCreateManyTenantInput | InvestorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AdvisorCreateWithoutTenantInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput>
  }

  export type AdvisorCreateManyTenantInputEnvelope = {
    data: AdvisorCreateManyTenantInput | AdvisorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutTenantInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTenantInput = {
    id?: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTenantInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealCreateManyTenantInputEnvelope = {
    data: DealCreateManyTenantInput | DealCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowCreateManyTenantInputEnvelope = {
    data: WorkflowCreateManyTenantInput | WorkflowCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentCreateManyTenantInputEnvelope = {
    data: DocumentCreateManyTenantInput | DocumentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutTenantInput = {
    id?: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutTenantInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutTenantInput, PushSubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type PushSubscriptionCreateManyTenantInputEnvelope = {
    data: PushSubscriptionCreateManyTenantInput | PushSubscriptionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutTenantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutTenantInput = {
    id?: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutTenantInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput>
  }

  export type ConversationCreateManyTenantInputEnvelope = {
    data: ConversationCreateManyTenantInput | ConversationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutTenantInput = {
    id?: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutMatchesInput
    investor: InvestorCreateNestedOneWithoutMatchesInput
    interests?: MatchInterestCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutTenantInput = {
    id?: string
    smeId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: MatchInterestUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutTenantInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutTenantInput, MatchUncheckedCreateWithoutTenantInput>
  }

  export type MatchCreateManyTenantInputEnvelope = {
    data: MatchCreateManyTenantInput | MatchCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    dealInvestment?: DealInvestorCreateNestedOneWithoutPaymentsInput
    booking?: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SMEUpsertWithWhereUniqueWithoutTenantInput = {
    where: SMEWhereUniqueInput
    update: XOR<SMEUpdateWithoutTenantInput, SMEUncheckedUpdateWithoutTenantInput>
    create: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput>
  }

  export type SMEUpdateWithWhereUniqueWithoutTenantInput = {
    where: SMEWhereUniqueInput
    data: XOR<SMEUpdateWithoutTenantInput, SMEUncheckedUpdateWithoutTenantInput>
  }

  export type SMEUpdateManyWithWhereWithoutTenantInput = {
    where: SMEScalarWhereInput
    data: XOR<SMEUpdateManyMutationInput, SMEUncheckedUpdateManyWithoutTenantInput>
  }

  export type SMEScalarWhereInput = {
    AND?: SMEScalarWhereInput | SMEScalarWhereInput[]
    OR?: SMEScalarWhereInput[]
    NOT?: SMEScalarWhereInput | SMEScalarWhereInput[]
    id?: StringFilter<"SME"> | string
    tenantId?: StringFilter<"SME"> | string
    userId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
  }

  export type InvestorUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    update: XOR<InvestorUpdateWithoutTenantInput, InvestorUncheckedUpdateWithoutTenantInput>
    create: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput>
  }

  export type InvestorUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    data: XOR<InvestorUpdateWithoutTenantInput, InvestorUncheckedUpdateWithoutTenantInput>
  }

  export type InvestorUpdateManyWithWhereWithoutTenantInput = {
    where: InvestorScalarWhereInput
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvestorScalarWhereInput = {
    AND?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    OR?: InvestorScalarWhereInput[]
    NOT?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    id?: StringFilter<"Investor"> | string
    tenantId?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
  }

  export type AdvisorUpsertWithWhereUniqueWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    update: XOR<AdvisorUpdateWithoutTenantInput, AdvisorUncheckedUpdateWithoutTenantInput>
    create: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput>
  }

  export type AdvisorUpdateWithWhereUniqueWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    data: XOR<AdvisorUpdateWithoutTenantInput, AdvisorUncheckedUpdateWithoutTenantInput>
  }

  export type AdvisorUpdateManyWithWhereWithoutTenantInput = {
    where: AdvisorScalarWhereInput
    data: XOR<AdvisorUpdateManyMutationInput, AdvisorUncheckedUpdateManyWithoutTenantInput>
  }

  export type AdvisorScalarWhereInput = {
    AND?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
    OR?: AdvisorScalarWhereInput[]
    NOT?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
    id?: StringFilter<"Advisor"> | string
    tenantId?: StringFilter<"Advisor"> | string
    userId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealUpdateWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
  }

  export type DealUpdateManyWithWhereWithoutTenantInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutTenantInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    terms?: StringNullableFilter<"Deal"> | string | null
    isDocumentLocked?: BoolFilter<"Deal"> | boolean
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutTenantInput, WorkflowUncheckedUpdateWithoutTenantInput>
    create: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutTenantInput, WorkflowUncheckedUpdateWithoutTenantInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutTenantInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutTenantInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: StringFilter<"Workflow"> | string
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutTenantInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutTenantInput, PushSubscriptionUncheckedUpdateWithoutTenantInput>
    create: XOR<PushSubscriptionCreateWithoutTenantInput, PushSubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutTenantInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutTenantInput, PushSubscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutTenantInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutTenantInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    tenantId?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    keys?: JsonFilter<"PushSubscription">
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutTenantInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutTenantInput, ConversationUncheckedUpdateWithoutTenantInput>
    create: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutTenantInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutTenantInput, ConversationUncheckedUpdateWithoutTenantInput>
  }

  export type ConversationUpdateManyWithWhereWithoutTenantInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutTenantInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    dealId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutTenantInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutTenantInput, MatchUncheckedUpdateWithoutTenantInput>
    create: XOR<MatchCreateWithoutTenantInput, MatchUncheckedCreateWithoutTenantInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutTenantInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutTenantInput, MatchUncheckedUpdateWithoutTenantInput>
  }

  export type MatchUpdateManyWithWhereWithoutTenantInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutTenantInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: StringFilter<"Match"> | string
    tenantId?: StringFilter<"Match"> | string
    smeId?: StringFilter<"Match"> | string
    investorId?: StringFilter<"Match"> | string
    score?: IntFilter<"Match"> | number
    factors?: JsonNullableFilter<"Match">
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    provider?: StringFilter<"Payment"> | string
    providerTxId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    dealInvestorId?: StringNullableFilter<"Payment"> | string | null
    bookingId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type SMECreateWithoutUserInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutUserInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
  }

  export type InvestorCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutUserInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
  }

  export type AdvisorCreateWithoutUserInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutUserInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutUserInput = {
    id?: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantCreateManyUserInputEnvelope = {
    data: ConversationParticipantCreateManyUserInput | ConversationParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    tenantId: string
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor?: AdvisorCreateNestedOneWithoutBookingsInput
    service?: AdvisoryServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    advisorId?: string | null
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchInterestCreateWithoutUserInput = {
    id?: string
    interest: boolean
    createdAt?: Date | string
    match: MatchCreateNestedOneWithoutInterestsInput
  }

  export type MatchInterestUncheckedCreateWithoutUserInput = {
    id?: string
    matchId: string
    interest: boolean
    createdAt?: Date | string
  }

  export type MatchInterestCreateOrConnectWithoutUserInput = {
    where: MatchInterestWhereUniqueInput
    create: XOR<MatchInterestCreateWithoutUserInput, MatchInterestUncheckedCreateWithoutUserInput>
  }

  export type MatchInterestCreateManyUserInputEnvelope = {
    data: MatchInterestCreateManyUserInput | MatchInterestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    dealInvestment?: DealInvestorCreateNestedOneWithoutPaymentsInput
    booking?: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutUserInput = {
    update: XOR<SMEUpdateWithoutUserInput, SMEUncheckedUpdateWithoutUserInput>
    create: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutUserInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutUserInput, SMEUncheckedUpdateWithoutUserInput>
  }

  export type SMEUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutUserInput = {
    update: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type AdvisorUpsertWithoutUserInput = {
    update: XOR<AdvisorUpdateWithoutUserInput, AdvisorUncheckedUpdateWithoutUserInput>
    create: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutUserInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutUserInput, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    id?: StringFilter<"ConversationParticipant"> | string
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    tenantId?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    advisorId?: StringNullableFilter<"Booking"> | string | null
    serviceId?: StringNullableFilter<"Booking"> | string | null
    preferredDate?: DateTimeFilter<"Booking"> | Date | string
    notes?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    amount?: FloatNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type MatchInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchInterestWhereUniqueInput
    update: XOR<MatchInterestUpdateWithoutUserInput, MatchInterestUncheckedUpdateWithoutUserInput>
    create: XOR<MatchInterestCreateWithoutUserInput, MatchInterestUncheckedCreateWithoutUserInput>
  }

  export type MatchInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchInterestWhereUniqueInput
    data: XOR<MatchInterestUpdateWithoutUserInput, MatchInterestUncheckedUpdateWithoutUserInput>
  }

  export type MatchInterestUpdateManyWithWhereWithoutUserInput = {
    where: MatchInterestScalarWhereInput
    data: XOR<MatchInterestUpdateManyMutationInput, MatchInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchInterestScalarWhereInput = {
    AND?: MatchInterestScalarWhereInput | MatchInterestScalarWhereInput[]
    OR?: MatchInterestScalarWhereInput[]
    NOT?: MatchInterestScalarWhereInput | MatchInterestScalarWhereInput[]
    id?: StringFilter<"MatchInterest"> | string
    matchId?: StringFilter<"MatchInterest"> | string
    userId?: StringFilter<"MatchInterest"> | string
    interest?: BoolFilter<"MatchInterest"> | boolean
    createdAt?: DateTimeFilter<"MatchInterest"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantCreateWithoutSmesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSmesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSmesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
  }

  export type UserCreateWithoutSmeInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSmeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
  }

  export type DocumentCreateWithoutSmeInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput>
  }

  export type DocumentCreateManySmeInputEnvelope = {
    data: DocumentCreateManySmeInput | DocumentCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutSmeInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSmeInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput>
  }

  export type DealCreateManySmeInputEnvelope = {
    data: DealCreateManySmeInput | DealCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type CertificationCreateWithoutSmeInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor: AdvisorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutSmeInput = {
    id?: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput>
  }

  export type CertificationCreateManySmeInputEnvelope = {
    data: CertificationCreateManySmeInput | CertificationCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutSmeInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput>
  }

  export type WorkflowCreateManySmeInputEnvelope = {
    data: WorkflowCreateManySmeInput | WorkflowCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type DueDiligenceCreateWithoutSmeInput = {
    id?: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor?: AdvisorCreateNestedOneWithoutDueDiligencesInput
  }

  export type DueDiligenceUncheckedCreateWithoutSmeInput = {
    id?: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateOrConnectWithoutSmeInput = {
    where: DueDiligenceWhereUniqueInput
    create: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput>
  }

  export type DueDiligenceCreateManySmeInputEnvelope = {
    data: DueDiligenceCreateManySmeInput | DueDiligenceCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutSmeInput = {
    id?: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMatchesInput
    investor: InvestorCreateNestedOneWithoutMatchesInput
    interests?: MatchInterestCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: MatchInterestUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutSmeInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutSmeInput, MatchUncheckedCreateWithoutSmeInput>
  }

  export type MatchCreateManySmeInputEnvelope = {
    data: MatchCreateManySmeInput | MatchCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSmesInput = {
    update: XOR<TenantUpdateWithoutSmesInput, TenantUncheckedUpdateWithoutSmesInput>
    create: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSmesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSmesInput, TenantUncheckedUpdateWithoutSmesInput>
  }

  export type TenantUpdateWithoutSmesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSmesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutSmeInput = {
    update: XOR<UserUpdateWithoutSmeInput, UserUncheckedUpdateWithoutSmeInput>
    create: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmeInput, UserUncheckedUpdateWithoutSmeInput>
  }

  export type UserUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutSmeInput, DocumentUncheckedUpdateWithoutSmeInput>
    create: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutSmeInput, DocumentUncheckedUpdateWithoutSmeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutSmeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSmeInput>
  }

  export type DealUpsertWithWhereUniqueWithoutSmeInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutSmeInput, DealUncheckedUpdateWithoutSmeInput>
    create: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput>
  }

  export type DealUpdateWithWhereUniqueWithoutSmeInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutSmeInput, DealUncheckedUpdateWithoutSmeInput>
  }

  export type DealUpdateManyWithWhereWithoutSmeInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutSmeInput>
  }

  export type CertificationUpsertWithWhereUniqueWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutSmeInput, CertificationUncheckedUpdateWithoutSmeInput>
    create: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutSmeInput, CertificationUncheckedUpdateWithoutSmeInput>
  }

  export type CertificationUpdateManyWithWhereWithoutSmeInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutSmeInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutSmeInput, WorkflowUncheckedUpdateWithoutSmeInput>
    create: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutSmeInput, WorkflowUncheckedUpdateWithoutSmeInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutSmeInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutSmeInput>
  }

  export type DueDiligenceUpsertWithWhereUniqueWithoutSmeInput = {
    where: DueDiligenceWhereUniqueInput
    update: XOR<DueDiligenceUpdateWithoutSmeInput, DueDiligenceUncheckedUpdateWithoutSmeInput>
    create: XOR<DueDiligenceCreateWithoutSmeInput, DueDiligenceUncheckedCreateWithoutSmeInput>
  }

  export type DueDiligenceUpdateWithWhereUniqueWithoutSmeInput = {
    where: DueDiligenceWhereUniqueInput
    data: XOR<DueDiligenceUpdateWithoutSmeInput, DueDiligenceUncheckedUpdateWithoutSmeInput>
  }

  export type DueDiligenceUpdateManyWithWhereWithoutSmeInput = {
    where: DueDiligenceScalarWhereInput
    data: XOR<DueDiligenceUpdateManyMutationInput, DueDiligenceUncheckedUpdateManyWithoutSmeInput>
  }

  export type DueDiligenceScalarWhereInput = {
    AND?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
    OR?: DueDiligenceScalarWhereInput[]
    NOT?: DueDiligenceScalarWhereInput | DueDiligenceScalarWhereInput[]
    id?: StringFilter<"DueDiligence"> | string
    smeId?: StringFilter<"DueDiligence"> | string
    advisorId?: StringNullableFilter<"DueDiligence"> | string | null
    financialScore?: FloatFilter<"DueDiligence"> | number
    teamScore?: FloatFilter<"DueDiligence"> | number
    marketScore?: FloatFilter<"DueDiligence"> | number
    productScore?: FloatFilter<"DueDiligence"> | number
    legalScore?: FloatFilter<"DueDiligence"> | number
    operationalScore?: FloatFilter<"DueDiligence"> | number
    overallScore?: FloatFilter<"DueDiligence"> | number
    riskLevel?: EnumRiskLevelFilter<"DueDiligence"> | $Enums.RiskLevel
    strengths?: StringNullableListFilter<"DueDiligence">
    weaknesses?: StringNullableListFilter<"DueDiligence">
    recommendations?: StringNullableListFilter<"DueDiligence">
    redFlags?: StringNullableListFilter<"DueDiligence">
    status?: EnumDueDiligenceStatusFilter<"DueDiligence"> | $Enums.DueDiligenceStatus
    completedAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DueDiligence"> | Date | string | null
    createdAt?: DateTimeFilter<"DueDiligence"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligence"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutSmeInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutSmeInput, MatchUncheckedUpdateWithoutSmeInput>
    create: XOR<MatchCreateWithoutSmeInput, MatchUncheckedCreateWithoutSmeInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutSmeInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutSmeInput, MatchUncheckedUpdateWithoutSmeInput>
  }

  export type MatchUpdateManyWithWhereWithoutSmeInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutSmeInput>
  }

  export type TenantCreateWithoutInvestorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvestorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvestorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
  }

  export type UserCreateWithoutInvestorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorCreateWithoutInvestorInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutDealInvestorInput
    payments?: PaymentCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorUncheckedCreateWithoutInvestorInput = {
    id?: string
    dealId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutDealInvestorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorCreateOrConnectWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorCreateManyInvestorInputEnvelope = {
    data: DealInvestorCreateManyInvestorInput | DealInvestorCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutInvestorInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput>
  }

  export type WorkflowCreateManyInvestorInputEnvelope = {
    data: WorkflowCreateManyInvestorInput | WorkflowCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type SyndicateCreateWithoutLeadInvestorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutSyndicatesInput
    members?: SyndicateMemberCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUncheckedCreateWithoutLeadInvestorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateCreateOrConnectWithoutLeadInvestorInput = {
    where: SyndicateWhereUniqueInput
    create: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput>
  }

  export type SyndicateCreateManyLeadInvestorInputEnvelope = {
    data: SyndicateCreateManyLeadInvestorInput | SyndicateCreateManyLeadInvestorInput[]
    skipDuplicates?: boolean
  }

  export type SyndicateMemberCreateWithoutInvestorInput = {
    id?: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
    syndicate: SyndicateCreateNestedOneWithoutMembersInput
  }

  export type SyndicateMemberUncheckedCreateWithoutInvestorInput = {
    id?: string
    syndicateId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberCreateOrConnectWithoutInvestorInput = {
    where: SyndicateMemberWhereUniqueInput
    create: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput>
  }

  export type SyndicateMemberCreateManyInvestorInputEnvelope = {
    data: SyndicateMemberCreateManyInvestorInput | SyndicateMemberCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type SecondaryListingCreateWithoutSellerInput = {
    id?: string
    tenantId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestor: DealInvestorCreateNestedOneWithoutSecondaryListingsInput
    trades?: SecondaryTradeCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingUncheckedCreateWithoutSellerInput = {
    id?: string
    tenantId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: SecondaryTradeUncheckedCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingCreateOrConnectWithoutSellerInput = {
    where: SecondaryListingWhereUniqueInput
    create: XOR<SecondaryListingCreateWithoutSellerInput, SecondaryListingUncheckedCreateWithoutSellerInput>
  }

  export type SecondaryListingCreateManySellerInputEnvelope = {
    data: SecondaryListingCreateManySellerInput | SecondaryListingCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type SecondaryTradeCreateWithoutBuyerInput = {
    id?: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: SecondaryListingCreateNestedOneWithoutTradesInput
    seller: InvestorCreateNestedOneWithoutTradesAsSellerInput
  }

  export type SecondaryTradeUncheckedCreateWithoutBuyerInput = {
    id?: string
    listingId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeCreateOrConnectWithoutBuyerInput = {
    where: SecondaryTradeWhereUniqueInput
    create: XOR<SecondaryTradeCreateWithoutBuyerInput, SecondaryTradeUncheckedCreateWithoutBuyerInput>
  }

  export type SecondaryTradeCreateManyBuyerInputEnvelope = {
    data: SecondaryTradeCreateManyBuyerInput | SecondaryTradeCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type SecondaryTradeCreateWithoutSellerInput = {
    id?: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: SecondaryListingCreateNestedOneWithoutTradesInput
    buyer: InvestorCreateNestedOneWithoutTradesAsBuyerInput
  }

  export type SecondaryTradeUncheckedCreateWithoutSellerInput = {
    id?: string
    listingId: string
    buyerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeCreateOrConnectWithoutSellerInput = {
    where: SecondaryTradeWhereUniqueInput
    create: XOR<SecondaryTradeCreateWithoutSellerInput, SecondaryTradeUncheckedCreateWithoutSellerInput>
  }

  export type SecondaryTradeCreateManySellerInputEnvelope = {
    data: SecondaryTradeCreateManySellerInput | SecondaryTradeCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutInvestorInput = {
    id?: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMatchesInput
    sme: SMECreateNestedOneWithoutMatchesInput
    interests?: MatchInterestCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    smeId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: MatchInterestUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutInvestorInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutInvestorInput, MatchUncheckedCreateWithoutInvestorInput>
  }

  export type MatchCreateManyInvestorInputEnvelope = {
    data: MatchCreateManyInvestorInput | MatchCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInvestorsInput = {
    update: XOR<TenantUpdateWithoutInvestorsInput, TenantUncheckedUpdateWithoutInvestorsInput>
    create: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvestorsInput, TenantUncheckedUpdateWithoutInvestorsInput>
  }

  export type TenantUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutInvestorInput = {
    update: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type UserUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealInvestorUpsertWithWhereUniqueWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    update: XOR<DealInvestorUpdateWithoutInvestorInput, DealInvestorUncheckedUpdateWithoutInvestorInput>
    create: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorUpdateWithWhereUniqueWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    data: XOR<DealInvestorUpdateWithoutInvestorInput, DealInvestorUncheckedUpdateWithoutInvestorInput>
  }

  export type DealInvestorUpdateManyWithWhereWithoutInvestorInput = {
    where: DealInvestorScalarWhereInput
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyWithoutInvestorInput>
  }

  export type DealInvestorScalarWhereInput = {
    AND?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
    OR?: DealInvestorScalarWhereInput[]
    NOT?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
    id?: StringFilter<"DealInvestor"> | string
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutInvestorInput, WorkflowUncheckedUpdateWithoutInvestorInput>
    create: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutInvestorInput, WorkflowUncheckedUpdateWithoutInvestorInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutInvestorInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutInvestorInput>
  }

  export type SyndicateUpsertWithWhereUniqueWithoutLeadInvestorInput = {
    where: SyndicateWhereUniqueInput
    update: XOR<SyndicateUpdateWithoutLeadInvestorInput, SyndicateUncheckedUpdateWithoutLeadInvestorInput>
    create: XOR<SyndicateCreateWithoutLeadInvestorInput, SyndicateUncheckedCreateWithoutLeadInvestorInput>
  }

  export type SyndicateUpdateWithWhereUniqueWithoutLeadInvestorInput = {
    where: SyndicateWhereUniqueInput
    data: XOR<SyndicateUpdateWithoutLeadInvestorInput, SyndicateUncheckedUpdateWithoutLeadInvestorInput>
  }

  export type SyndicateUpdateManyWithWhereWithoutLeadInvestorInput = {
    where: SyndicateScalarWhereInput
    data: XOR<SyndicateUpdateManyMutationInput, SyndicateUncheckedUpdateManyWithoutLeadInvestorInput>
  }

  export type SyndicateScalarWhereInput = {
    AND?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
    OR?: SyndicateScalarWhereInput[]
    NOT?: SyndicateScalarWhereInput | SyndicateScalarWhereInput[]
    id?: StringFilter<"Syndicate"> | string
    tenantId?: StringFilter<"Syndicate"> | string
    name?: StringFilter<"Syndicate"> | string
    description?: StringNullableFilter<"Syndicate"> | string | null
    leadInvestorId?: StringFilter<"Syndicate"> | string
    targetAmount?: FloatFilter<"Syndicate"> | number
    minInvestment?: FloatFilter<"Syndicate"> | number
    maxInvestment?: FloatNullableFilter<"Syndicate"> | number | null
    managementFee?: FloatFilter<"Syndicate"> | number
    carryFee?: FloatFilter<"Syndicate"> | number
    status?: EnumSyndicateStatusFilter<"Syndicate"> | $Enums.SyndicateStatus
    dealId?: StringNullableFilter<"Syndicate"> | string | null
    closingDate?: DateTimeNullableFilter<"Syndicate"> | Date | string | null
    createdAt?: DateTimeFilter<"Syndicate"> | Date | string
    updatedAt?: DateTimeFilter<"Syndicate"> | Date | string
  }

  export type SyndicateMemberUpsertWithWhereUniqueWithoutInvestorInput = {
    where: SyndicateMemberWhereUniqueInput
    update: XOR<SyndicateMemberUpdateWithoutInvestorInput, SyndicateMemberUncheckedUpdateWithoutInvestorInput>
    create: XOR<SyndicateMemberCreateWithoutInvestorInput, SyndicateMemberUncheckedCreateWithoutInvestorInput>
  }

  export type SyndicateMemberUpdateWithWhereUniqueWithoutInvestorInput = {
    where: SyndicateMemberWhereUniqueInput
    data: XOR<SyndicateMemberUpdateWithoutInvestorInput, SyndicateMemberUncheckedUpdateWithoutInvestorInput>
  }

  export type SyndicateMemberUpdateManyWithWhereWithoutInvestorInput = {
    where: SyndicateMemberScalarWhereInput
    data: XOR<SyndicateMemberUpdateManyMutationInput, SyndicateMemberUncheckedUpdateManyWithoutInvestorInput>
  }

  export type SyndicateMemberScalarWhereInput = {
    AND?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
    OR?: SyndicateMemberScalarWhereInput[]
    NOT?: SyndicateMemberScalarWhereInput | SyndicateMemberScalarWhereInput[]
    id?: StringFilter<"SyndicateMember"> | string
    syndicateId?: StringFilter<"SyndicateMember"> | string
    investorId?: StringFilter<"SyndicateMember"> | string
    amount?: FloatFilter<"SyndicateMember"> | number
    status?: EnumSyndicateMemberStatusFilter<"SyndicateMember"> | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFilter<"SyndicateMember"> | Date | string
  }

  export type SecondaryListingUpsertWithWhereUniqueWithoutSellerInput = {
    where: SecondaryListingWhereUniqueInput
    update: XOR<SecondaryListingUpdateWithoutSellerInput, SecondaryListingUncheckedUpdateWithoutSellerInput>
    create: XOR<SecondaryListingCreateWithoutSellerInput, SecondaryListingUncheckedCreateWithoutSellerInput>
  }

  export type SecondaryListingUpdateWithWhereUniqueWithoutSellerInput = {
    where: SecondaryListingWhereUniqueInput
    data: XOR<SecondaryListingUpdateWithoutSellerInput, SecondaryListingUncheckedUpdateWithoutSellerInput>
  }

  export type SecondaryListingUpdateManyWithWhereWithoutSellerInput = {
    where: SecondaryListingScalarWhereInput
    data: XOR<SecondaryListingUpdateManyMutationInput, SecondaryListingUncheckedUpdateManyWithoutSellerInput>
  }

  export type SecondaryListingScalarWhereInput = {
    AND?: SecondaryListingScalarWhereInput | SecondaryListingScalarWhereInput[]
    OR?: SecondaryListingScalarWhereInput[]
    NOT?: SecondaryListingScalarWhereInput | SecondaryListingScalarWhereInput[]
    id?: StringFilter<"SecondaryListing"> | string
    tenantId?: StringFilter<"SecondaryListing"> | string
    sellerId?: StringFilter<"SecondaryListing"> | string
    dealInvestorId?: StringFilter<"SecondaryListing"> | string
    sharesAvailable?: FloatFilter<"SecondaryListing"> | number
    pricePerShare?: FloatFilter<"SecondaryListing"> | number
    minPurchase?: FloatFilter<"SecondaryListing"> | number
    status?: EnumListingStatusFilter<"SecondaryListing"> | $Enums.ListingStatus
    listedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SecondaryListing"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryListing"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryListing"> | Date | string
  }

  export type SecondaryTradeUpsertWithWhereUniqueWithoutBuyerInput = {
    where: SecondaryTradeWhereUniqueInput
    update: XOR<SecondaryTradeUpdateWithoutBuyerInput, SecondaryTradeUncheckedUpdateWithoutBuyerInput>
    create: XOR<SecondaryTradeCreateWithoutBuyerInput, SecondaryTradeUncheckedCreateWithoutBuyerInput>
  }

  export type SecondaryTradeUpdateWithWhereUniqueWithoutBuyerInput = {
    where: SecondaryTradeWhereUniqueInput
    data: XOR<SecondaryTradeUpdateWithoutBuyerInput, SecondaryTradeUncheckedUpdateWithoutBuyerInput>
  }

  export type SecondaryTradeUpdateManyWithWhereWithoutBuyerInput = {
    where: SecondaryTradeScalarWhereInput
    data: XOR<SecondaryTradeUpdateManyMutationInput, SecondaryTradeUncheckedUpdateManyWithoutBuyerInput>
  }

  export type SecondaryTradeScalarWhereInput = {
    AND?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
    OR?: SecondaryTradeScalarWhereInput[]
    NOT?: SecondaryTradeScalarWhereInput | SecondaryTradeScalarWhereInput[]
    id?: StringFilter<"SecondaryTrade"> | string
    listingId?: StringFilter<"SecondaryTrade"> | string
    buyerId?: StringFilter<"SecondaryTrade"> | string
    sellerId?: StringFilter<"SecondaryTrade"> | string
    shares?: FloatFilter<"SecondaryTrade"> | number
    pricePerShare?: FloatFilter<"SecondaryTrade"> | number
    totalAmount?: FloatFilter<"SecondaryTrade"> | number
    fee?: FloatFilter<"SecondaryTrade"> | number
    status?: EnumTradeStatusFilter<"SecondaryTrade"> | $Enums.TradeStatus
    executedAt?: DateTimeNullableFilter<"SecondaryTrade"> | Date | string | null
    createdAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
    updatedAt?: DateTimeFilter<"SecondaryTrade"> | Date | string
  }

  export type SecondaryTradeUpsertWithWhereUniqueWithoutSellerInput = {
    where: SecondaryTradeWhereUniqueInput
    update: XOR<SecondaryTradeUpdateWithoutSellerInput, SecondaryTradeUncheckedUpdateWithoutSellerInput>
    create: XOR<SecondaryTradeCreateWithoutSellerInput, SecondaryTradeUncheckedCreateWithoutSellerInput>
  }

  export type SecondaryTradeUpdateWithWhereUniqueWithoutSellerInput = {
    where: SecondaryTradeWhereUniqueInput
    data: XOR<SecondaryTradeUpdateWithoutSellerInput, SecondaryTradeUncheckedUpdateWithoutSellerInput>
  }

  export type SecondaryTradeUpdateManyWithWhereWithoutSellerInput = {
    where: SecondaryTradeScalarWhereInput
    data: XOR<SecondaryTradeUpdateManyMutationInput, SecondaryTradeUncheckedUpdateManyWithoutSellerInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutInvestorInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutInvestorInput, MatchUncheckedUpdateWithoutInvestorInput>
    create: XOR<MatchCreateWithoutInvestorInput, MatchUncheckedCreateWithoutInvestorInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutInvestorInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutInvestorInput, MatchUncheckedUpdateWithoutInvestorInput>
  }

  export type MatchUpdateManyWithWhereWithoutInvestorInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutInvestorInput>
  }

  export type TenantCreateWithoutAdvisorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAdvisorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAdvisorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
  }

  export type UserCreateWithoutAdvisorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdvisorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationCreateWithoutAdvisorInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutAdvisorInput = {
    id?: string
    smeId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationCreateManyAdvisorInputEnvelope = {
    data: CertificationCreateManyAdvisorInput | CertificationCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutAdvisorInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput>
  }

  export type WorkflowCreateManyAdvisorInputEnvelope = {
    data: WorkflowCreateManyAdvisorInput | WorkflowCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type DueDiligenceCreateWithoutAdvisorInput = {
    id?: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDueDiligencesInput
  }

  export type DueDiligenceUncheckedCreateWithoutAdvisorInput = {
    id?: string
    smeId: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateOrConnectWithoutAdvisorInput = {
    where: DueDiligenceWhereUniqueInput
    create: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput>
  }

  export type DueDiligenceCreateManyAdvisorInputEnvelope = {
    data: DueDiligenceCreateManyAdvisorInput | DueDiligenceCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type AdvisoryServiceCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type AdvisoryServiceUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type AdvisoryServiceCreateOrConnectWithoutAdvisorInput = {
    where: AdvisoryServiceWhereUniqueInput
    create: XOR<AdvisoryServiceCreateWithoutAdvisorInput, AdvisoryServiceUncheckedCreateWithoutAdvisorInput>
  }

  export type AdvisoryServiceCreateManyAdvisorInputEnvelope = {
    data: AdvisoryServiceCreateManyAdvisorInput | AdvisoryServiceCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    service?: AdvisoryServiceCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    userId: string
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutAdvisorInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutAdvisorInput, BookingUncheckedCreateWithoutAdvisorInput>
  }

  export type BookingCreateManyAdvisorInputEnvelope = {
    data: BookingCreateManyAdvisorInput | BookingCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAdvisorsInput = {
    update: XOR<TenantUpdateWithoutAdvisorsInput, TenantUncheckedUpdateWithoutAdvisorsInput>
    create: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAdvisorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAdvisorsInput, TenantUncheckedUpdateWithoutAdvisorsInput>
  }

  export type TenantUpdateWithoutAdvisorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAdvisorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAdvisorInput = {
    update: XOR<UserUpdateWithoutAdvisorInput, UserUncheckedUpdateWithoutAdvisorInput>
    create: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdvisorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdvisorInput, UserUncheckedUpdateWithoutAdvisorInput>
  }

  export type UserUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CertificationUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutAdvisorInput, CertificationUncheckedUpdateWithoutAdvisorInput>
    create: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutAdvisorInput, CertificationUncheckedUpdateWithoutAdvisorInput>
  }

  export type CertificationUpdateManyWithWhereWithoutAdvisorInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type WorkflowUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutAdvisorInput, WorkflowUncheckedUpdateWithoutAdvisorInput>
    create: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutAdvisorInput, WorkflowUncheckedUpdateWithoutAdvisorInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutAdvisorInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type DueDiligenceUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: DueDiligenceWhereUniqueInput
    update: XOR<DueDiligenceUpdateWithoutAdvisorInput, DueDiligenceUncheckedUpdateWithoutAdvisorInput>
    create: XOR<DueDiligenceCreateWithoutAdvisorInput, DueDiligenceUncheckedCreateWithoutAdvisorInput>
  }

  export type DueDiligenceUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: DueDiligenceWhereUniqueInput
    data: XOR<DueDiligenceUpdateWithoutAdvisorInput, DueDiligenceUncheckedUpdateWithoutAdvisorInput>
  }

  export type DueDiligenceUpdateManyWithWhereWithoutAdvisorInput = {
    where: DueDiligenceScalarWhereInput
    data: XOR<DueDiligenceUpdateManyMutationInput, DueDiligenceUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type AdvisoryServiceUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: AdvisoryServiceWhereUniqueInput
    update: XOR<AdvisoryServiceUpdateWithoutAdvisorInput, AdvisoryServiceUncheckedUpdateWithoutAdvisorInput>
    create: XOR<AdvisoryServiceCreateWithoutAdvisorInput, AdvisoryServiceUncheckedCreateWithoutAdvisorInput>
  }

  export type AdvisoryServiceUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: AdvisoryServiceWhereUniqueInput
    data: XOR<AdvisoryServiceUpdateWithoutAdvisorInput, AdvisoryServiceUncheckedUpdateWithoutAdvisorInput>
  }

  export type AdvisoryServiceUpdateManyWithWhereWithoutAdvisorInput = {
    where: AdvisoryServiceScalarWhereInput
    data: XOR<AdvisoryServiceUpdateManyMutationInput, AdvisoryServiceUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type AdvisoryServiceScalarWhereInput = {
    AND?: AdvisoryServiceScalarWhereInput | AdvisoryServiceScalarWhereInput[]
    OR?: AdvisoryServiceScalarWhereInput[]
    NOT?: AdvisoryServiceScalarWhereInput | AdvisoryServiceScalarWhereInput[]
    id?: StringFilter<"AdvisoryService"> | string
    tenantId?: StringFilter<"AdvisoryService"> | string
    advisorId?: StringFilter<"AdvisoryService"> | string
    name?: StringFilter<"AdvisoryService"> | string
    category?: StringFilter<"AdvisoryService"> | string
    description?: StringNullableFilter<"AdvisoryService"> | string | null
    price?: FloatFilter<"AdvisoryService"> | number
    duration?: StringFilter<"AdvisoryService"> | string
    features?: StringNullableListFilter<"AdvisoryService">
    status?: StringFilter<"AdvisoryService"> | string
    createdAt?: DateTimeFilter<"AdvisoryService"> | Date | string
    updatedAt?: DateTimeFilter<"AdvisoryService"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutAdvisorInput, BookingUncheckedUpdateWithoutAdvisorInput>
    create: XOR<BookingCreateWithoutAdvisorInput, BookingUncheckedCreateWithoutAdvisorInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutAdvisorInput, BookingUncheckedUpdateWithoutAdvisorInput>
  }

  export type BookingUpdateManyWithWhereWithoutAdvisorInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type TenantCreateWithoutDealsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDealsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDealsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
  }

  export type SMECreateWithoutDealsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDealsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDealsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
  }

  export type DealInvestorCreateWithoutDealInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutDealInvestorInput
    payments?: PaymentCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorUncheckedCreateWithoutDealInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutDealInvestorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorCreateOrConnectWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput>
  }

  export type DealInvestorCreateManyDealInputEnvelope = {
    data: DealInvestorCreateManyDealInput | DealInvestorCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDealInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    sme?: SMECreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutDealInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentCreateManyDealInputEnvelope = {
    data: DocumentCreateManyDealInput | DocumentCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutDealInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput>
  }

  export type WorkflowCreateManyDealInputEnvelope = {
    data: WorkflowCreateManyDealInput | WorkflowCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type SyndicateCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadInvestor: InvestorCreateNestedOneWithoutLeadSyndicatesInput
    members?: SyndicateMemberCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: SyndicateMemberUncheckedCreateNestedManyWithoutSyndicateInput
  }

  export type SyndicateCreateOrConnectWithoutDealInput = {
    where: SyndicateWhereUniqueInput
    create: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput>
  }

  export type SyndicateCreateManyDealInputEnvelope = {
    data: SyndicateCreateManyDealInput | SyndicateCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutDealInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutDealInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutDealInput, ConversationUncheckedCreateWithoutDealInput>
  }

  export type ConversationCreateManyDealInputEnvelope = {
    data: ConversationCreateManyDealInput | ConversationCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutDealsInput = {
    update: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDealsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type TenantUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutDealsInput = {
    update: XOR<SMEUpdateWithoutDealsInput, SMEUncheckedUpdateWithoutDealsInput>
    create: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDealsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDealsInput, SMEUncheckedUpdateWithoutDealsInput>
  }

  export type SMEUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type DealInvestorUpsertWithWhereUniqueWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    update: XOR<DealInvestorUpdateWithoutDealInput, DealInvestorUncheckedUpdateWithoutDealInput>
    create: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput>
  }

  export type DealInvestorUpdateWithWhereUniqueWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    data: XOR<DealInvestorUpdateWithoutDealInput, DealInvestorUncheckedUpdateWithoutDealInput>
  }

  export type DealInvestorUpdateManyWithWhereWithoutDealInput = {
    where: DealInvestorScalarWhereInput
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyWithoutDealInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDealInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDealInput>
  }

  export type WorkflowUpsertWithWhereUniqueWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutDealInput, WorkflowUncheckedUpdateWithoutDealInput>
    create: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutDealInput, WorkflowUncheckedUpdateWithoutDealInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutDealInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutDealInput>
  }

  export type SyndicateUpsertWithWhereUniqueWithoutDealInput = {
    where: SyndicateWhereUniqueInput
    update: XOR<SyndicateUpdateWithoutDealInput, SyndicateUncheckedUpdateWithoutDealInput>
    create: XOR<SyndicateCreateWithoutDealInput, SyndicateUncheckedCreateWithoutDealInput>
  }

  export type SyndicateUpdateWithWhereUniqueWithoutDealInput = {
    where: SyndicateWhereUniqueInput
    data: XOR<SyndicateUpdateWithoutDealInput, SyndicateUncheckedUpdateWithoutDealInput>
  }

  export type SyndicateUpdateManyWithWhereWithoutDealInput = {
    where: SyndicateScalarWhereInput
    data: XOR<SyndicateUpdateManyMutationInput, SyndicateUncheckedUpdateManyWithoutDealInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutDealInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutDealInput, ConversationUncheckedUpdateWithoutDealInput>
    create: XOR<ConversationCreateWithoutDealInput, ConversationUncheckedCreateWithoutDealInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutDealInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutDealInput, ConversationUncheckedUpdateWithoutDealInput>
  }

  export type ConversationUpdateManyWithWhereWithoutDealInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutDealInput>
  }

  export type DealCreateWithoutInvestorsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutInvestorsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutInvestorsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
  }

  export type InvestorCreateWithoutDealInvestmentsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutDealInvestmentsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutDealInvestmentsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
  }

  export type SecondaryListingCreateWithoutDealInvestorInput = {
    id?: string
    tenantId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: InvestorCreateNestedOneWithoutSecondaryListingsInput
    trades?: SecondaryTradeCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingUncheckedCreateWithoutDealInvestorInput = {
    id?: string
    tenantId: string
    sellerId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trades?: SecondaryTradeUncheckedCreateNestedManyWithoutListingInput
  }

  export type SecondaryListingCreateOrConnectWithoutDealInvestorInput = {
    where: SecondaryListingWhereUniqueInput
    create: XOR<SecondaryListingCreateWithoutDealInvestorInput, SecondaryListingUncheckedCreateWithoutDealInvestorInput>
  }

  export type SecondaryListingCreateManyDealInvestorInputEnvelope = {
    data: SecondaryListingCreateManyDealInvestorInput | SecondaryListingCreateManyDealInvestorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutDealInvestmentInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    user: UserCreateNestedOneWithoutPaymentsInput
    booking?: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutDealInvestmentInput = {
    id?: string
    tenantId: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutDealInvestmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutDealInvestmentInput, PaymentUncheckedCreateWithoutDealInvestmentInput>
  }

  export type PaymentCreateManyDealInvestmentInputEnvelope = {
    data: PaymentCreateManyDealInvestmentInput | PaymentCreateManyDealInvestmentInput[]
    skipDuplicates?: boolean
  }

  export type DealUpsertWithoutInvestorsInput = {
    update: XOR<DealUpdateWithoutInvestorsInput, DealUncheckedUpdateWithoutInvestorsInput>
    create: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutInvestorsInput, DealUncheckedUpdateWithoutInvestorsInput>
  }

  export type DealUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type InvestorUpsertWithoutDealInvestmentsInput = {
    update: XOR<InvestorUpdateWithoutDealInvestmentsInput, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
    create: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutDealInvestmentsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutDealInvestmentsInput, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
  }

  export type InvestorUpdateWithoutDealInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutDealInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type SecondaryListingUpsertWithWhereUniqueWithoutDealInvestorInput = {
    where: SecondaryListingWhereUniqueInput
    update: XOR<SecondaryListingUpdateWithoutDealInvestorInput, SecondaryListingUncheckedUpdateWithoutDealInvestorInput>
    create: XOR<SecondaryListingCreateWithoutDealInvestorInput, SecondaryListingUncheckedCreateWithoutDealInvestorInput>
  }

  export type SecondaryListingUpdateWithWhereUniqueWithoutDealInvestorInput = {
    where: SecondaryListingWhereUniqueInput
    data: XOR<SecondaryListingUpdateWithoutDealInvestorInput, SecondaryListingUncheckedUpdateWithoutDealInvestorInput>
  }

  export type SecondaryListingUpdateManyWithWhereWithoutDealInvestorInput = {
    where: SecondaryListingScalarWhereInput
    data: XOR<SecondaryListingUpdateManyMutationInput, SecondaryListingUncheckedUpdateManyWithoutDealInvestorInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutDealInvestmentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutDealInvestmentInput, PaymentUncheckedUpdateWithoutDealInvestmentInput>
    create: XOR<PaymentCreateWithoutDealInvestmentInput, PaymentUncheckedCreateWithoutDealInvestmentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutDealInvestmentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutDealInvestmentInput, PaymentUncheckedUpdateWithoutDealInvestmentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutDealInvestmentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutDealInvestmentInput>
  }

  export type TenantCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
  }

  export type SMECreateWithoutDocumentsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDocumentsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
  }

  export type DealCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutDocumentsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
  }

  export type TenantUpsertWithoutDocumentsInput = {
    update: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type TenantUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutDocumentsInput = {
    update: XOR<SMEUpdateWithoutDocumentsInput, SMEUncheckedUpdateWithoutDocumentsInput>
    create: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDocumentsInput, SMEUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMEUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type DealUpsertWithoutDocumentsInput = {
    update: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SMECreateWithoutCertificationsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutCertificationsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutCertificationsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
  }

  export type AdvisorCreateWithoutCertificationsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutCertificationsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutCertificationsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
  }

  export type SMEUpsertWithoutCertificationsInput = {
    update: XOR<SMEUpdateWithoutCertificationsInput, SMEUncheckedUpdateWithoutCertificationsInput>
    create: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutCertificationsInput, SMEUncheckedUpdateWithoutCertificationsInput>
  }

  export type SMEUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type AdvisorUpsertWithoutCertificationsInput = {
    update: XOR<AdvisorUpdateWithoutCertificationsInput, AdvisorUncheckedUpdateWithoutCertificationsInput>
    create: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutCertificationsInput, AdvisorUncheckedUpdateWithoutCertificationsInput>
  }

  export type AdvisorUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type TenantCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWorkflowsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
  }

  export type SMECreateWithoutWorkflowsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutWorkflowsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
  }

  export type InvestorCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutWorkflowsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
  }

  export type AdvisorCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutWorkflowsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
  }

  export type DealCreateWithoutWorkflowsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutWorkflowsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
  }

  export type TenantUpsertWithoutWorkflowsInput = {
    update: XOR<TenantUpdateWithoutWorkflowsInput, TenantUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWorkflowsInput, TenantUncheckedUpdateWithoutWorkflowsInput>
  }

  export type TenantUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutWorkflowsInput = {
    update: XOR<SMEUpdateWithoutWorkflowsInput, SMEUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutWorkflowsInput, SMEUncheckedUpdateWithoutWorkflowsInput>
  }

  export type SMEUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutWorkflowsInput = {
    update: XOR<InvestorUpdateWithoutWorkflowsInput, InvestorUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutWorkflowsInput, InvestorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type AdvisorUpsertWithoutWorkflowsInput = {
    update: XOR<AdvisorUpdateWithoutWorkflowsInput, AdvisorUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutWorkflowsInput, AdvisorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AdvisorUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type DealUpsertWithoutWorkflowsInput = {
    update: XOR<DealUpdateWithoutWorkflowsInput, DealUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutWorkflowsInput, DealUncheckedUpdateWithoutWorkflowsInput>
  }

  export type DealUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type InvestorCreateWithoutLeadSyndicatesInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutLeadSyndicatesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutLeadSyndicatesInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
  }

  export type DealCreateWithoutSyndicatesInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    conversations?: ConversationCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSyndicatesInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSyndicatesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
  }

  export type SyndicateMemberCreateWithoutSyndicateInput = {
    id?: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutSyndicateMembershipsInput
  }

  export type SyndicateMemberUncheckedCreateWithoutSyndicateInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberCreateOrConnectWithoutSyndicateInput = {
    where: SyndicateMemberWhereUniqueInput
    create: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput>
  }

  export type SyndicateMemberCreateManySyndicateInputEnvelope = {
    data: SyndicateMemberCreateManySyndicateInput | SyndicateMemberCreateManySyndicateInput[]
    skipDuplicates?: boolean
  }

  export type InvestorUpsertWithoutLeadSyndicatesInput = {
    update: XOR<InvestorUpdateWithoutLeadSyndicatesInput, InvestorUncheckedUpdateWithoutLeadSyndicatesInput>
    create: XOR<InvestorCreateWithoutLeadSyndicatesInput, InvestorUncheckedCreateWithoutLeadSyndicatesInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutLeadSyndicatesInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutLeadSyndicatesInput, InvestorUncheckedUpdateWithoutLeadSyndicatesInput>
  }

  export type InvestorUpdateWithoutLeadSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutLeadSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type DealUpsertWithoutSyndicatesInput = {
    update: XOR<DealUpdateWithoutSyndicatesInput, DealUncheckedUpdateWithoutSyndicatesInput>
    create: XOR<DealCreateWithoutSyndicatesInput, DealUncheckedCreateWithoutSyndicatesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutSyndicatesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutSyndicatesInput, DealUncheckedUpdateWithoutSyndicatesInput>
  }

  export type DealUpdateWithoutSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSyndicatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SyndicateMemberUpsertWithWhereUniqueWithoutSyndicateInput = {
    where: SyndicateMemberWhereUniqueInput
    update: XOR<SyndicateMemberUpdateWithoutSyndicateInput, SyndicateMemberUncheckedUpdateWithoutSyndicateInput>
    create: XOR<SyndicateMemberCreateWithoutSyndicateInput, SyndicateMemberUncheckedCreateWithoutSyndicateInput>
  }

  export type SyndicateMemberUpdateWithWhereUniqueWithoutSyndicateInput = {
    where: SyndicateMemberWhereUniqueInput
    data: XOR<SyndicateMemberUpdateWithoutSyndicateInput, SyndicateMemberUncheckedUpdateWithoutSyndicateInput>
  }

  export type SyndicateMemberUpdateManyWithWhereWithoutSyndicateInput = {
    where: SyndicateMemberScalarWhereInput
    data: XOR<SyndicateMemberUpdateManyMutationInput, SyndicateMemberUncheckedUpdateManyWithoutSyndicateInput>
  }

  export type SyndicateCreateWithoutMembersInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leadInvestor: InvestorCreateNestedOneWithoutLeadSyndicatesInput
    deal?: DealCreateNestedOneWithoutSyndicatesInput
  }

  export type SyndicateUncheckedCreateWithoutMembersInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateCreateOrConnectWithoutMembersInput = {
    where: SyndicateWhereUniqueInput
    create: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
  }

  export type InvestorCreateWithoutSyndicateMembershipsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutSyndicateMembershipsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutSyndicateMembershipsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
  }

  export type SyndicateUpsertWithoutMembersInput = {
    update: XOR<SyndicateUpdateWithoutMembersInput, SyndicateUncheckedUpdateWithoutMembersInput>
    create: XOR<SyndicateCreateWithoutMembersInput, SyndicateUncheckedCreateWithoutMembersInput>
    where?: SyndicateWhereInput
  }

  export type SyndicateUpdateToOneWithWhereWithoutMembersInput = {
    where?: SyndicateWhereInput
    data: XOR<SyndicateUpdateWithoutMembersInput, SyndicateUncheckedUpdateWithoutMembersInput>
  }

  export type SyndicateUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadInvestor?: InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput
    deal?: DealUpdateOneWithoutSyndicatesNestedInput
  }

  export type SyndicateUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpsertWithoutSyndicateMembershipsInput = {
    update: XOR<InvestorUpdateWithoutSyndicateMembershipsInput, InvestorUncheckedUpdateWithoutSyndicateMembershipsInput>
    create: XOR<InvestorCreateWithoutSyndicateMembershipsInput, InvestorUncheckedCreateWithoutSyndicateMembershipsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutSyndicateMembershipsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutSyndicateMembershipsInput, InvestorUncheckedUpdateWithoutSyndicateMembershipsInput>
  }

  export type InvestorUpdateWithoutSyndicateMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutSyndicateMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type SMECreateWithoutDueDiligencesInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    matches?: MatchCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDueDiligencesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    matches?: MatchUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDueDiligencesInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
  }

  export type AdvisorCreateWithoutDueDiligencesInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutDueDiligencesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutDueDiligencesInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
  }

  export type SMEUpsertWithoutDueDiligencesInput = {
    update: XOR<SMEUpdateWithoutDueDiligencesInput, SMEUncheckedUpdateWithoutDueDiligencesInput>
    create: XOR<SMECreateWithoutDueDiligencesInput, SMEUncheckedCreateWithoutDueDiligencesInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDueDiligencesInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDueDiligencesInput, SMEUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type SMEUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type AdvisorUpsertWithoutDueDiligencesInput = {
    update: XOR<AdvisorUpdateWithoutDueDiligencesInput, AdvisorUncheckedUpdateWithoutDueDiligencesInput>
    create: XOR<AdvisorCreateWithoutDueDiligencesInput, AdvisorUncheckedCreateWithoutDueDiligencesInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutDueDiligencesInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutDueDiligencesInput, AdvisorUncheckedUpdateWithoutDueDiligencesInput>
  }

  export type AdvisorUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutDueDiligencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    likes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CommunityPostCreateWithoutCommentsInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    tenantId: string
    authorId: string
    title: string
    content: string
    category?: $Enums.PostCategory
    smeId?: string | null
    dealId?: string | null
    syndicateId?: string | null
    likes?: number
    views?: number
    isPinned?: boolean
    isAnnouncement?: boolean
    status?: $Enums.PostStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostCreateOrConnectWithoutCommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CommunityPostUpsertWithoutCommentsInput = {
    update: XOR<CommunityPostUpdateWithoutCommentsInput, CommunityPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    where?: CommunityPostWhereInput
  }

  export type CommunityPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CommunityPostWhereInput
    data: XOR<CommunityPostUpdateWithoutCommentsInput, CommunityPostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommunityPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    syndicateId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isAnnouncement?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type InvestorCreateWithoutSecondaryListingsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutSecondaryListingsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutSecondaryListingsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutSecondaryListingsInput, InvestorUncheckedCreateWithoutSecondaryListingsInput>
  }

  export type DealInvestorCreateWithoutSecondaryListingsInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
    payments?: PaymentCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorUncheckedCreateWithoutSecondaryListingsInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutDealInvestmentInput
  }

  export type DealInvestorCreateOrConnectWithoutSecondaryListingsInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutSecondaryListingsInput, DealInvestorUncheckedCreateWithoutSecondaryListingsInput>
  }

  export type SecondaryTradeCreateWithoutListingInput = {
    id?: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: InvestorCreateNestedOneWithoutTradesAsBuyerInput
    seller: InvestorCreateNestedOneWithoutTradesAsSellerInput
  }

  export type SecondaryTradeUncheckedCreateWithoutListingInput = {
    id?: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeCreateOrConnectWithoutListingInput = {
    where: SecondaryTradeWhereUniqueInput
    create: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput>
  }

  export type SecondaryTradeCreateManyListingInputEnvelope = {
    data: SecondaryTradeCreateManyListingInput | SecondaryTradeCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type InvestorUpsertWithoutSecondaryListingsInput = {
    update: XOR<InvestorUpdateWithoutSecondaryListingsInput, InvestorUncheckedUpdateWithoutSecondaryListingsInput>
    create: XOR<InvestorCreateWithoutSecondaryListingsInput, InvestorUncheckedCreateWithoutSecondaryListingsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutSecondaryListingsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutSecondaryListingsInput, InvestorUncheckedUpdateWithoutSecondaryListingsInput>
  }

  export type InvestorUpdateWithoutSecondaryListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutSecondaryListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type DealInvestorUpsertWithoutSecondaryListingsInput = {
    update: XOR<DealInvestorUpdateWithoutSecondaryListingsInput, DealInvestorUncheckedUpdateWithoutSecondaryListingsInput>
    create: XOR<DealInvestorCreateWithoutSecondaryListingsInput, DealInvestorUncheckedCreateWithoutSecondaryListingsInput>
    where?: DealInvestorWhereInput
  }

  export type DealInvestorUpdateToOneWithWhereWithoutSecondaryListingsInput = {
    where?: DealInvestorWhereInput
    data: XOR<DealInvestorUpdateWithoutSecondaryListingsInput, DealInvestorUncheckedUpdateWithoutSecondaryListingsInput>
  }

  export type DealInvestorUpdateWithoutSecondaryListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
    payments?: PaymentUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutSecondaryListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutDealInvestmentNestedInput
  }

  export type SecondaryTradeUpsertWithWhereUniqueWithoutListingInput = {
    where: SecondaryTradeWhereUniqueInput
    update: XOR<SecondaryTradeUpdateWithoutListingInput, SecondaryTradeUncheckedUpdateWithoutListingInput>
    create: XOR<SecondaryTradeCreateWithoutListingInput, SecondaryTradeUncheckedCreateWithoutListingInput>
  }

  export type SecondaryTradeUpdateWithWhereUniqueWithoutListingInput = {
    where: SecondaryTradeWhereUniqueInput
    data: XOR<SecondaryTradeUpdateWithoutListingInput, SecondaryTradeUncheckedUpdateWithoutListingInput>
  }

  export type SecondaryTradeUpdateManyWithWhereWithoutListingInput = {
    where: SecondaryTradeScalarWhereInput
    data: XOR<SecondaryTradeUpdateManyMutationInput, SecondaryTradeUncheckedUpdateManyWithoutListingInput>
  }

  export type SecondaryListingCreateWithoutTradesInput = {
    id?: string
    tenantId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: InvestorCreateNestedOneWithoutSecondaryListingsInput
    dealInvestor: DealInvestorCreateNestedOneWithoutSecondaryListingsInput
  }

  export type SecondaryListingUncheckedCreateWithoutTradesInput = {
    id?: string
    tenantId: string
    sellerId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryListingCreateOrConnectWithoutTradesInput = {
    where: SecondaryListingWhereUniqueInput
    create: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
  }

  export type InvestorCreateWithoutTradesAsBuyerInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutTradesAsBuyerInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutTradesAsBuyerInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutTradesAsBuyerInput, InvestorUncheckedCreateWithoutTradesAsBuyerInput>
  }

  export type InvestorCreateWithoutTradesAsSellerInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    matches?: MatchCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutTradesAsSellerInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    matches?: MatchUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutTradesAsSellerInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutTradesAsSellerInput, InvestorUncheckedCreateWithoutTradesAsSellerInput>
  }

  export type SecondaryListingUpsertWithoutTradesInput = {
    update: XOR<SecondaryListingUpdateWithoutTradesInput, SecondaryListingUncheckedUpdateWithoutTradesInput>
    create: XOR<SecondaryListingCreateWithoutTradesInput, SecondaryListingUncheckedCreateWithoutTradesInput>
    where?: SecondaryListingWhereInput
  }

  export type SecondaryListingUpdateToOneWithWhereWithoutTradesInput = {
    where?: SecondaryListingWhereInput
    data: XOR<SecondaryListingUpdateWithoutTradesInput, SecondaryListingUncheckedUpdateWithoutTradesInput>
  }

  export type SecondaryListingUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: InvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput
    dealInvestor?: DealInvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput
  }

  export type SecondaryListingUncheckedUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpsertWithoutTradesAsBuyerInput = {
    update: XOR<InvestorUpdateWithoutTradesAsBuyerInput, InvestorUncheckedUpdateWithoutTradesAsBuyerInput>
    create: XOR<InvestorCreateWithoutTradesAsBuyerInput, InvestorUncheckedCreateWithoutTradesAsBuyerInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutTradesAsBuyerInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutTradesAsBuyerInput, InvestorUncheckedUpdateWithoutTradesAsBuyerInput>
  }

  export type InvestorUpdateWithoutTradesAsBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutTradesAsBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUpsertWithoutTradesAsSellerInput = {
    update: XOR<InvestorUpdateWithoutTradesAsSellerInput, InvestorUncheckedUpdateWithoutTradesAsSellerInput>
    create: XOR<InvestorCreateWithoutTradesAsSellerInput, InvestorUncheckedCreateWithoutTradesAsSellerInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutTradesAsSellerInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutTradesAsSellerInput, InvestorUncheckedUpdateWithoutTradesAsSellerInput>
  }

  export type InvestorUpdateWithoutTradesAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutTradesAsSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutConversationsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutConversationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
  }

  export type DealCreateWithoutConversationsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
    syndicates?: SyndicateCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutConversationsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
    syndicates?: SyndicateUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutConversationsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutConversationsInput, DealUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    id?: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMessageParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutConversationsInput = {
    update: XOR<TenantUpdateWithoutConversationsInput, TenantUncheckedUpdateWithoutConversationsInput>
    create: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutConversationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutConversationsInput, TenantUncheckedUpdateWithoutConversationsInput>
  }

  export type TenantUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DealUpsertWithoutConversationsInput = {
    update: XOR<DealUpdateWithoutConversationsInput, DealUncheckedUpdateWithoutConversationsInput>
    create: XOR<DealCreateWithoutConversationsInput, DealUncheckedCreateWithoutConversationsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutConversationsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutConversationsInput, DealUncheckedUpdateWithoutConversationsInput>
  }

  export type DealUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutConversationsInput
    deal?: DealCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    tenantId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutMessageParticipantsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageParticipantsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageParticipantsInput, UserUncheckedCreateWithoutMessageParticipantsInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
    deal?: DealUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMessageParticipantsInput = {
    update: XOR<UserUpdateWithoutMessageParticipantsInput, UserUncheckedUpdateWithoutMessageParticipantsInput>
    create: XOR<UserCreateWithoutMessageParticipantsInput, UserUncheckedCreateWithoutMessageParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageParticipantsInput, UserUncheckedUpdateWithoutMessageParticipantsInput>
  }

  export type UserUpdateWithoutMessageParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutConversationsInput
    deal?: DealCreateNestedOneWithoutConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
    deal?: DealUpdateOneWithoutConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdvisorCreateWithoutServicesInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    bookings?: BookingCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutServicesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutServicesInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutServicesInput, AdvisorUncheckedCreateWithoutServicesInput>
  }

  export type BookingCreateWithoutServiceInput = {
    id?: string
    tenantId: string
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    advisor?: AdvisorCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id?: string
    tenantId: string
    userId: string
    advisorId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: BookingCreateManyServiceInput | BookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type AdvisorUpsertWithoutServicesInput = {
    update: XOR<AdvisorUpdateWithoutServicesInput, AdvisorUncheckedUpdateWithoutServicesInput>
    create: XOR<AdvisorCreateWithoutServicesInput, AdvisorUncheckedCreateWithoutServicesInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutServicesInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutServicesInput, AdvisorUncheckedUpdateWithoutServicesInput>
  }

  export type AdvisorUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type AdvisorCreateWithoutBookingsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutAdvisorInput
    services?: AdvisoryServiceUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutBookingsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutBookingsInput, AdvisorUncheckedCreateWithoutBookingsInput>
  }

  export type AdvisoryServiceCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor: AdvisorCreateNestedOneWithoutServicesInput
  }

  export type AdvisoryServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    advisorId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisoryServiceCreateOrConnectWithoutBookingsInput = {
    where: AdvisoryServiceWhereUniqueInput
    create: XOR<AdvisoryServiceCreateWithoutBookingsInput, AdvisoryServiceUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    user: UserCreateNestedOneWithoutPaymentsInput
    dealInvestment?: DealInvestorCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    tenantId: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdvisorUpsertWithoutBookingsInput = {
    update: XOR<AdvisorUpdateWithoutBookingsInput, AdvisorUncheckedUpdateWithoutBookingsInput>
    create: XOR<AdvisorCreateWithoutBookingsInput, AdvisorUncheckedCreateWithoutBookingsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutBookingsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutBookingsInput, AdvisorUncheckedUpdateWithoutBookingsInput>
  }

  export type AdvisorUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisoryServiceUpsertWithoutBookingsInput = {
    update: XOR<AdvisoryServiceUpdateWithoutBookingsInput, AdvisoryServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<AdvisoryServiceCreateWithoutBookingsInput, AdvisoryServiceUncheckedCreateWithoutBookingsInput>
    where?: AdvisoryServiceWhereInput
  }

  export type AdvisoryServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: AdvisoryServiceWhereInput
    data: XOR<AdvisoryServiceUpdateWithoutBookingsInput, AdvisoryServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type AdvisoryServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneRequiredWithoutServicesNestedInput
  }

  export type AdvisoryServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type TenantCreateWithoutMatchesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMatchesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMatchesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMatchesInput, TenantUncheckedCreateWithoutMatchesInput>
  }

  export type SMECreateWithoutMatchesInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutMatchesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
    dueDiligences?: DueDiligenceUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutMatchesInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutMatchesInput, SMEUncheckedCreateWithoutMatchesInput>
  }

  export type InvestorCreateWithoutMatchesInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeCreateNestedManyWithoutSellerInput
  }

  export type InvestorUncheckedCreateWithoutMatchesInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
    leadSyndicates?: SyndicateUncheckedCreateNestedManyWithoutLeadInvestorInput
    syndicateMemberships?: SyndicateMemberUncheckedCreateNestedManyWithoutInvestorInput
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutSellerInput
    tradesAsBuyer?: SecondaryTradeUncheckedCreateNestedManyWithoutBuyerInput
    tradesAsSeller?: SecondaryTradeUncheckedCreateNestedManyWithoutSellerInput
  }

  export type InvestorCreateOrConnectWithoutMatchesInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutMatchesInput, InvestorUncheckedCreateWithoutMatchesInput>
  }

  export type MatchInterestCreateWithoutMatchInput = {
    id?: string
    interest: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMatchInterestsInput
  }

  export type MatchInterestUncheckedCreateWithoutMatchInput = {
    id?: string
    userId: string
    interest: boolean
    createdAt?: Date | string
  }

  export type MatchInterestCreateOrConnectWithoutMatchInput = {
    where: MatchInterestWhereUniqueInput
    create: XOR<MatchInterestCreateWithoutMatchInput, MatchInterestUncheckedCreateWithoutMatchInput>
  }

  export type MatchInterestCreateManyMatchInputEnvelope = {
    data: MatchInterestCreateManyMatchInput | MatchInterestCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutMatchesInput = {
    update: XOR<TenantUpdateWithoutMatchesInput, TenantUncheckedUpdateWithoutMatchesInput>
    create: XOR<TenantCreateWithoutMatchesInput, TenantUncheckedCreateWithoutMatchesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMatchesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMatchesInput, TenantUncheckedUpdateWithoutMatchesInput>
  }

  export type TenantUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutMatchesInput = {
    update: XOR<SMEUpdateWithoutMatchesInput, SMEUncheckedUpdateWithoutMatchesInput>
    create: XOR<SMECreateWithoutMatchesInput, SMEUncheckedCreateWithoutMatchesInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutMatchesInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutMatchesInput, SMEUncheckedUpdateWithoutMatchesInput>
  }

  export type SMEUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutMatchesInput = {
    update: XOR<InvestorUpdateWithoutMatchesInput, InvestorUncheckedUpdateWithoutMatchesInput>
    create: XOR<InvestorCreateWithoutMatchesInput, InvestorUncheckedCreateWithoutMatchesInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutMatchesInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutMatchesInput, InvestorUncheckedUpdateWithoutMatchesInput>
  }

  export type InvestorUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
  }

  export type InvestorUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
  }

  export type MatchInterestUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchInterestWhereUniqueInput
    update: XOR<MatchInterestUpdateWithoutMatchInput, MatchInterestUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchInterestCreateWithoutMatchInput, MatchInterestUncheckedCreateWithoutMatchInput>
  }

  export type MatchInterestUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchInterestWhereUniqueInput
    data: XOR<MatchInterestUpdateWithoutMatchInput, MatchInterestUncheckedUpdateWithoutMatchInput>
  }

  export type MatchInterestUpdateManyWithWhereWithoutMatchInput = {
    where: MatchInterestScalarWhereInput
    data: XOR<MatchInterestUpdateManyMutationInput, MatchInterestUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchCreateWithoutInterestsInput = {
    id?: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMatchesInput
    sme: SMECreateNestedOneWithoutMatchesInput
    investor: InvestorCreateNestedOneWithoutMatchesInput
  }

  export type MatchUncheckedCreateWithoutInterestsInput = {
    id?: string
    tenantId: string
    smeId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateOrConnectWithoutInterestsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutInterestsInput, MatchUncheckedCreateWithoutInterestsInput>
  }

  export type UserCreateWithoutMatchInterestsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchInterestsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchInterestsInput, UserUncheckedCreateWithoutMatchInterestsInput>
  }

  export type MatchUpsertWithoutInterestsInput = {
    update: XOR<MatchUpdateWithoutInterestsInput, MatchUncheckedUpdateWithoutInterestsInput>
    create: XOR<MatchCreateWithoutInterestsInput, MatchUncheckedCreateWithoutInterestsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutInterestsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutInterestsInput, MatchUncheckedUpdateWithoutInterestsInput>
  }

  export type MatchUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMatchesNestedInput
    sme?: SMEUpdateOneRequiredWithoutMatchesNestedInput
    investor?: InvestorUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type MatchUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMatchInterestsInput = {
    update: XOR<UserUpdateWithoutMatchInterestsInput, UserUncheckedUpdateWithoutMatchInterestsInput>
    create: XOR<UserCreateWithoutMatchInterestsInput, UserUncheckedCreateWithoutMatchInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchInterestsInput, UserUncheckedUpdateWithoutMatchInterestsInput>
  }

  export type UserUpdateWithoutMatchInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutPushSubscriptionsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPushSubscriptionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPushSubscriptionsInput, TenantUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type TenantUpsertWithoutPushSubscriptionsInput = {
    update: XOR<TenantUpdateWithoutPushSubscriptionsInput, TenantUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<TenantCreateWithoutPushSubscriptionsInput, TenantUncheckedCreateWithoutPushSubscriptionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPushSubscriptionsInput, TenantUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type TenantUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    matches?: MatchCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    matches?: MatchUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    messageParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    matchInterests?: MatchInterestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type DealInvestorCreateWithoutPaymentsInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
    secondaryListings?: SecondaryListingCreateNestedManyWithoutDealInvestorInput
  }

  export type DealInvestorUncheckedCreateWithoutPaymentsInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    secondaryListings?: SecondaryListingUncheckedCreateNestedManyWithoutDealInvestorInput
  }

  export type DealInvestorCreateOrConnectWithoutPaymentsInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutPaymentsInput, DealInvestorUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    advisor?: AdvisorCreateNestedOneWithoutBookingsInput
    service?: AdvisoryServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    userId: string
    advisorId?: string | null
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    matches?: MatchUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealInvestorUpsertWithoutPaymentsInput = {
    update: XOR<DealInvestorUpdateWithoutPaymentsInput, DealInvestorUncheckedUpdateWithoutPaymentsInput>
    create: XOR<DealInvestorCreateWithoutPaymentsInput, DealInvestorUncheckedCreateWithoutPaymentsInput>
    where?: DealInvestorWhereInput
  }

  export type DealInvestorUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: DealInvestorWhereInput
    data: XOR<DealInvestorUpdateWithoutPaymentsInput, DealInvestorUncheckedUpdateWithoutPaymentsInput>
  }

  export type DealInvestorUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutDealInvestorNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutDealInvestorNestedInput
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    advisor?: AdvisorUpdateOneWithoutBookingsNestedInput
    service?: AdvisoryServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMECreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorCreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisorCreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyTenantInput = {
    id?: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateManyTenantInput = {
    id?: string
    userId: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyTenantInput = {
    id?: string
    dealId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyTenantInput = {
    id?: string
    smeId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    messageParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    matchInterests?: MatchInterestUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMEUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutSmeNestedInput
    matches?: MatchUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutSmeNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUpdateManyWithoutSellerNestedInput
    matches?: MatchUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
    leadSyndicates?: SyndicateUncheckedUpdateManyWithoutLeadInvestorNestedInput
    syndicateMemberships?: SyndicateMemberUncheckedUpdateManyWithoutInvestorNestedInput
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutSellerNestedInput
    tradesAsBuyer?: SecondaryTradeUncheckedUpdateManyWithoutBuyerNestedInput
    tradesAsSeller?: SecondaryTradeUncheckedUpdateManyWithoutSellerNestedInput
    matches?: MatchUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
    dueDiligences?: DueDiligenceUncheckedUpdateManyWithoutAdvisorNestedInput
    services?: AdvisoryServiceUncheckedUpdateManyWithoutAdvisorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutMatchesNestedInput
    investor?: InvestorUpdateOneRequiredWithoutMatchesNestedInput
    interests?: MatchInterestUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: MatchInterestUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    dealInvestment?: DealInvestorUpdateOneWithoutPaymentsNestedInput
    booking?: BookingUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    tenantId: string
    endpoint: string
    keys: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationParticipantCreateManyUserInput = {
    id?: string
    conversationId: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    tenantId: string
    advisorId?: string | null
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchInterestCreateManyUserInput = {
    id?: string
    matchId: string
    interest: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    tenantId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    keys?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneWithoutBookingsNestedInput
    service?: AdvisoryServiceUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type MatchInterestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    dealInvestment?: DealInvestorUpdateOneWithoutPaymentsNestedInput
    booking?: BookingUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManySmeInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManySmeInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    terms?: string | null
    isDocumentLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateManySmeInput = {
    id?: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManySmeInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateManySmeInput = {
    id?: string
    advisorId?: string | null
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManySmeInput = {
    id?: string
    tenantId: string
    investorId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUpdateManyWithoutDealNestedInput
    conversations?: ConversationUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
    syndicates?: SyndicateUncheckedUpdateManyWithoutDealNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    isDocumentLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneWithoutDueDiligencesNestedInput
  }

  export type DueDiligenceUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMatchesNestedInput
    investor?: InvestorUpdateOneRequiredWithoutMatchesNestedInput
    interests?: MatchInterestUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: MatchInterestUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyInvestorInput = {
    id?: string
    dealId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyInvestorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateCreateManyLeadInvestorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    dealId?: string | null
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateMemberCreateManyInvestorInput = {
    id?: string
    syndicateId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SecondaryListingCreateManySellerInput = {
    id?: string
    tenantId: string
    dealInvestorId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeCreateManyBuyerInput = {
    id?: string
    listingId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeCreateManySellerInput = {
    id?: string
    listingId: string
    buyerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyInvestorInput = {
    id?: string
    tenantId: string
    smeId: string
    score: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutDealInvestorNestedInput
    payments?: PaymentUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutDealInvestorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateUpdateWithoutLeadInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutSyndicatesNestedInput
    members?: SyndicateMemberUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateWithoutLeadInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateManyWithoutLeadInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syndicate?: SyndicateUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SyndicateMemberUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    syndicateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestor?: DealInvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput
    trades?: SecondaryTradeUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: SecondaryTradeUncheckedUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealInvestorId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: SecondaryListingUpdateOneRequiredWithoutTradesNestedInput
    seller?: InvestorUpdateOneRequiredWithoutTradesAsSellerNestedInput
  }

  export type SecondaryTradeUncheckedUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: SecondaryListingUpdateOneRequiredWithoutTradesNestedInput
    buyer?: InvestorUpdateOneRequiredWithoutTradesAsBuyerNestedInput
  }

  export type SecondaryTradeUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMatchesNestedInput
    sme?: SMEUpdateOneRequiredWithoutMatchesNestedInput
    interests?: MatchInterestUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: MatchInterestUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyAdvisorInput = {
    id?: string
    smeId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyAdvisorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceCreateManyAdvisorInput = {
    id?: string
    smeId: string
    financialScore?: number
    teamScore?: number
    marketScore?: number
    productScore?: number
    legalScore?: number
    operationalScore?: number
    overallScore?: number
    riskLevel?: $Enums.RiskLevel
    strengths?: DueDiligenceCreatestrengthsInput | string[]
    weaknesses?: DueDiligenceCreateweaknessesInput | string[]
    recommendations?: DueDiligenceCreaterecommendationsInput | string[]
    redFlags?: DueDiligenceCreateredFlagsInput | string[]
    status?: $Enums.DueDiligenceStatus
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisoryServiceCreateManyAdvisorInput = {
    id?: string
    tenantId: string
    name: string
    category: string
    description?: string | null
    price: number
    duration: string
    features?: AdvisoryServiceCreatefeaturesInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyAdvisorInput = {
    id?: string
    tenantId: string
    userId: string
    serviceId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDueDiligencesNestedInput
  }

  export type DueDiligenceUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    financialScore?: FloatFieldUpdateOperationsInput | number
    teamScore?: FloatFieldUpdateOperationsInput | number
    marketScore?: FloatFieldUpdateOperationsInput | number
    productScore?: FloatFieldUpdateOperationsInput | number
    legalScore?: FloatFieldUpdateOperationsInput | number
    operationalScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    strengths?: DueDiligenceUpdatestrengthsInput | string[]
    weaknesses?: DueDiligenceUpdateweaknessesInput | string[]
    recommendations?: DueDiligenceUpdaterecommendationsInput | string[]
    redFlags?: DueDiligenceUpdateredFlagsInput | string[]
    status?: EnumDueDiligenceStatusFieldUpdateOperationsInput | $Enums.DueDiligenceStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisoryServiceUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type AdvisoryServiceUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type AdvisoryServiceUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: StringFieldUpdateOperationsInput | string
    features?: AdvisoryServiceUpdatefeaturesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: AdvisoryServiceUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyDealInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyDealInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyDealInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyndicateCreateManyDealInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    leadInvestorId: string
    targetAmount: number
    minInvestment?: number
    maxInvestment?: number | null
    managementFee?: number
    carryFee?: number
    status?: $Enums.SyndicateStatus
    closingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyDealInput = {
    id?: string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
    secondaryListings?: SecondaryListingUpdateManyWithoutDealInvestorNestedInput
    payments?: PaymentUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secondaryListings?: SecondaryListingUncheckedUpdateManyWithoutDealInvestorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutDealInvestmentNestedInput
  }

  export type DealInvestorUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadInvestor?: InvestorUpdateOneRequiredWithoutLeadSyndicatesNestedInput
    members?: SyndicateMemberUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: SyndicateMemberUncheckedUpdateManyWithoutSyndicateNestedInput
  }

  export type SyndicateUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leadInvestorId?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    minInvestment?: FloatFieldUpdateOperationsInput | number
    maxInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: FloatFieldUpdateOperationsInput | number
    carryFee?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateStatusFieldUpdateOperationsInput | $Enums.SyndicateStatus
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryListingCreateManyDealInvestorInput = {
    id?: string
    tenantId: string
    sellerId: string
    sharesAvailable: number
    pricePerShare: number
    minPurchase?: number
    status?: $Enums.ListingStatus
    listedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyDealInvestmentInput = {
    id?: string
    tenantId: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryListingUpdateWithoutDealInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: InvestorUpdateOneRequiredWithoutSecondaryListingsNestedInput
    trades?: SecondaryTradeUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingUncheckedUpdateWithoutDealInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trades?: SecondaryTradeUncheckedUpdateManyWithoutListingNestedInput
  }

  export type SecondaryListingUncheckedUpdateManyWithoutDealInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    sharesAvailable?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    minPurchase?: FloatFieldUpdateOperationsInput | number
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    listedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutDealInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    booking?: BookingUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutDealInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutDealInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberCreateManySyndicateInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.SyndicateMemberStatus
    joinedAt?: Date | string
  }

  export type SyndicateMemberUpdateWithoutSyndicateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutSyndicateMembershipsNestedInput
  }

  export type SyndicateMemberUncheckedUpdateWithoutSyndicateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyndicateMemberUncheckedUpdateManyWithoutSyndicateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumSyndicateMemberStatusFieldUpdateOperationsInput | $Enums.SyndicateMemberStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    parentId?: string | null
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeCreateManyListingInput = {
    id?: string
    buyerId: string
    sellerId: string
    shares: number
    pricePerShare: number
    totalAmount: number
    fee?: number
    status?: $Enums.TradeStatus
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecondaryTradeUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: InvestorUpdateOneRequiredWithoutTradesAsBuyerNestedInput
    seller?: InvestorUpdateOneRequiredWithoutTradesAsSellerNestedInput
  }

  export type SecondaryTradeUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecondaryTradeUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    shares?: FloatFieldUpdateOperationsInput | number
    pricePerShare?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationParticipantCreateManyConversationInput = {
    id?: string
    userId: string
    lastReadAt?: Date | string
    joinedAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lastReadAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyServiceInput = {
    id?: string
    tenantId: string
    userId: string
    advisorId?: string | null
    preferredDate: Date | string
    notes?: string | null
    status?: $Enums.BookingStatus
    amount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    advisor?: AdvisorUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    tenantId: string
    userId: string
    amount: number
    currency?: string
    method: $Enums.PaymentMethod
    provider: string
    providerTxId?: string | null
    status?: $Enums.PaymentStatus
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    dealInvestment?: DealInvestorUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    provider?: StringFieldUpdateOperationsInput | string
    providerTxId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    dealInvestorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestCreateManyMatchInput = {
    id?: string
    userId: string
    interest: boolean
    createdAt?: Date | string
  }

  export type MatchInterestUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMatchInterestsNestedInput
  }

  export type MatchInterestUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchInterestUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SMECountOutputTypeDefaultArgs instead
     */
    export type SMECountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SMECountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorCountOutputTypeDefaultArgs instead
     */
    export type InvestorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisorCountOutputTypeDefaultArgs instead
     */
    export type AdvisorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealCountOutputTypeDefaultArgs instead
     */
    export type DealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealInvestorCountOutputTypeDefaultArgs instead
     */
    export type DealInvestorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealInvestorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyndicateCountOutputTypeDefaultArgs instead
     */
    export type SyndicateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyndicateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityPostCountOutputTypeDefaultArgs instead
     */
    export type CommunityPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecondaryListingCountOutputTypeDefaultArgs instead
     */
    export type SecondaryListingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecondaryListingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisoryServiceCountOutputTypeDefaultArgs instead
     */
    export type AdvisoryServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisoryServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchCountOutputTypeDefaultArgs instead
     */
    export type MatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SMEDefaultArgs instead
     */
    export type SMEArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SMEDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorDefaultArgs instead
     */
    export type InvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisorDefaultArgs instead
     */
    export type AdvisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealDefaultArgs instead
     */
    export type DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealInvestorDefaultArgs instead
     */
    export type DealInvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealInvestorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificationDefaultArgs instead
     */
    export type CertificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefaultArgs instead
     */
    export type WorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyndicateDefaultArgs instead
     */
    export type SyndicateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyndicateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyndicateMemberDefaultArgs instead
     */
    export type SyndicateMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyndicateMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DueDiligenceDefaultArgs instead
     */
    export type DueDiligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DueDiligenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityPostDefaultArgs instead
     */
    export type CommunityPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecondaryListingDefaultArgs instead
     */
    export type SecondaryListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecondaryListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecondaryTradeDefaultArgs instead
     */
    export type SecondaryTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecondaryTradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationParticipantDefaultArgs instead
     */
    export type ConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisoryServiceDefaultArgs instead
     */
    export type AdvisoryServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisoryServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchDefaultArgs instead
     */
    export type MatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchInterestDefaultArgs instead
     */
    export type MatchInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PushSubscriptionDefaultArgs instead
     */
    export type PushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PushSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}