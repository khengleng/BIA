
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SME
 * 
 */
export type SME = $Result.DefaultSelection<Prisma.$SMEPayload>
/**
 * Model Investor
 * 
 */
export type Investor = $Result.DefaultSelection<Prisma.$InvestorPayload>
/**
 * Model Advisor
 * 
 */
export type Advisor = $Result.DefaultSelection<Prisma.$AdvisorPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model DealInvestor
 * 
 */
export type DealInvestor = $Result.DefaultSelection<Prisma.$DealInvestorPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SME: 'SME',
  INVESTOR: 'INVESTOR',
  ADVISOR: 'ADVISOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Language: {
  EN: 'EN',
  KM: 'KM',
  ZH: 'ZH'
};

export type Language = (typeof Language)[keyof typeof Language]


export const SMEStage: {
  SEED: 'SEED',
  GROWTH: 'GROWTH',
  EXPANSION: 'EXPANSION',
  MATURE: 'MATURE'
};

export type SMEStage = (typeof SMEStage)[keyof typeof SMEStage]


export const SMEStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  CERTIFIED: 'CERTIFIED',
  REJECTED: 'REJECTED'
};

export type SMEStatus = (typeof SMEStatus)[keyof typeof SMEStatus]


export const InvestorType: {
  ANGEL: 'ANGEL',
  VENTURE_CAPITAL: 'VENTURE_CAPITAL',
  PRIVATE_EQUITY: 'PRIVATE_EQUITY',
  CORPORATE: 'CORPORATE',
  INSTITUTIONAL: 'INSTITUTIONAL'
};

export type InvestorType = (typeof InvestorType)[keyof typeof InvestorType]


export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const AdvisorStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type AdvisorStatus = (typeof AdvisorStatus)[keyof typeof AdvisorStatus]


export const DealStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  NEGOTIATION: 'NEGOTIATION',
  FUNDED: 'FUNDED',
  CLOSED: 'CLOSED',
  CANCELLED: 'CANCELLED'
};

export type DealStatus = (typeof DealStatus)[keyof typeof DealStatus]


export const InvestmentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type InvestmentStatus = (typeof InvestmentStatus)[keyof typeof InvestmentStatus]


export const DocumentType: {
  PITCH_DECK: 'PITCH_DECK',
  FINANCIAL_STATEMENT: 'FINANCIAL_STATEMENT',
  BUSINESS_PLAN: 'BUSINESS_PLAN',
  LEGAL_DOCUMENT: 'LEGAL_DOCUMENT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const CertificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type CertificationStatus = (typeof CertificationStatus)[keyof typeof CertificationStatus]


export const WorkflowType: {
  SME_ONBOARDING: 'SME_ONBOARDING',
  SME_CERTIFICATION: 'SME_CERTIFICATION',
  INVESTOR_ONBOARDING: 'INVESTOR_ONBOARDING',
  DEAL_APPROVAL: 'DEAL_APPROVAL',
  KYC_VERIFICATION: 'KYC_VERIFICATION'
};

export type WorkflowType = (typeof WorkflowType)[keyof typeof WorkflowType]


export const WorkflowStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type SMEStage = $Enums.SMEStage

export const SMEStage: typeof $Enums.SMEStage

export type SMEStatus = $Enums.SMEStatus

export const SMEStatus: typeof $Enums.SMEStatus

export type InvestorType = $Enums.InvestorType

export const InvestorType: typeof $Enums.InvestorType

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type AdvisorStatus = $Enums.AdvisorStatus

export const AdvisorStatus: typeof $Enums.AdvisorStatus

export type DealStatus = $Enums.DealStatus

export const DealStatus: typeof $Enums.DealStatus

export type InvestmentStatus = $Enums.InvestmentStatus

export const InvestmentStatus: typeof $Enums.InvestmentStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type CertificationStatus = $Enums.CertificationStatus

export const CertificationStatus: typeof $Enums.CertificationStatus

export type WorkflowType = $Enums.WorkflowType

export const WorkflowType: typeof $Enums.WorkflowType

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.sME`: Exposes CRUD operations for the **SME** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMES
    * const sMES = await prisma.sME.findMany()
    * ```
    */
  get sME(): Prisma.SMEDelegate<ExtArgs>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **Investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.InvestorDelegate<ExtArgs>;

  /**
   * `prisma.advisor`: Exposes CRUD operations for the **Advisor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advisors
    * const advisors = await prisma.advisor.findMany()
    * ```
    */
  get advisor(): Prisma.AdvisorDelegate<ExtArgs>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs>;

  /**
   * `prisma.dealInvestor`: Exposes CRUD operations for the **DealInvestor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DealInvestors
    * const dealInvestors = await prisma.dealInvestor.findMany()
    * ```
    */
  get dealInvestor(): Prisma.DealInvestorDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    SME: 'SME',
    Investor: 'Investor',
    Advisor: 'Advisor',
    Deal: 'Deal',
    DealInvestor: 'DealInvestor',
    Document: 'Document',
    Certification: 'Certification',
    Workflow: 'Workflow'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "sME" | "investor" | "advisor" | "deal" | "dealInvestor" | "document" | "certification" | "workflow"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SME: {
        payload: Prisma.$SMEPayload<ExtArgs>
        fields: Prisma.SMEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMEFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMEFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          findFirst: {
            args: Prisma.SMEFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMEFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          findMany: {
            args: Prisma.SMEFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>[]
          }
          create: {
            args: Prisma.SMECreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          createMany: {
            args: Prisma.SMECreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SMECreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>[]
          }
          delete: {
            args: Prisma.SMEDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          update: {
            args: Prisma.SMEUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          deleteMany: {
            args: Prisma.SMEDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SMEUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SMEUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMEPayload>
          }
          aggregate: {
            args: Prisma.SMEAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSME>
          }
          groupBy: {
            args: Prisma.SMEGroupByArgs<ExtArgs>
            result: $Utils.Optional<SMEGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMECountArgs<ExtArgs>
            result: $Utils.Optional<SMECountAggregateOutputType> | number
          }
        }
      }
      Investor: {
        payload: Prisma.$InvestorPayload<ExtArgs>
        fields: Prisma.InvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findFirst: {
            args: Prisma.InvestorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findMany: {
            args: Prisma.InvestorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          create: {
            args: Prisma.InvestorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          createMany: {
            args: Prisma.InvestorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          delete: {
            args: Prisma.InvestorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          update: {
            args: Prisma.InvestorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          deleteMany: {
            args: Prisma.InvestorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvestorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.InvestorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      Advisor: {
        payload: Prisma.$AdvisorPayload<ExtArgs>
        fields: Prisma.AdvisorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvisorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvisorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          findFirst: {
            args: Prisma.AdvisorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvisorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          findMany: {
            args: Prisma.AdvisorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>[]
          }
          create: {
            args: Prisma.AdvisorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          createMany: {
            args: Prisma.AdvisorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvisorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>[]
          }
          delete: {
            args: Prisma.AdvisorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          update: {
            args: Prisma.AdvisorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          deleteMany: {
            args: Prisma.AdvisorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvisorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvisorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvisorPayload>
          }
          aggregate: {
            args: Prisma.AdvisorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvisor>
          }
          groupBy: {
            args: Prisma.AdvisorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvisorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvisorCountArgs<ExtArgs>
            result: $Utils.Optional<AdvisorCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      DealInvestor: {
        payload: Prisma.$DealInvestorPayload<ExtArgs>
        fields: Prisma.DealInvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealInvestorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealInvestorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          findFirst: {
            args: Prisma.DealInvestorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealInvestorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          findMany: {
            args: Prisma.DealInvestorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>[]
          }
          create: {
            args: Prisma.DealInvestorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          createMany: {
            args: Prisma.DealInvestorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealInvestorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>[]
          }
          delete: {
            args: Prisma.DealInvestorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          update: {
            args: Prisma.DealInvestorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          deleteMany: {
            args: Prisma.DealInvestorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealInvestorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealInvestorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealInvestorPayload>
          }
          aggregate: {
            args: Prisma.DealInvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealInvestor>
          }
          groupBy: {
            args: Prisma.DealInvestorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealInvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealInvestorCountArgs<ExtArgs>
            result: $Utils.Optional<DealInvestorCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    smes: number
    investors: number
    advisors: number
    deals: number
    workflows: number
    documents: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    smes?: boolean | TenantCountOutputTypeCountSmesArgs
    investors?: boolean | TenantCountOutputTypeCountInvestorsArgs
    advisors?: boolean | TenantCountOutputTypeCountAdvisorsArgs
    deals?: boolean | TenantCountOutputTypeCountDealsArgs
    workflows?: boolean | TenantCountOutputTypeCountWorkflowsArgs
    documents?: boolean | TenantCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMEWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAdvisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type SMECountOutputType
   */

  export type SMECountOutputType = {
    documents: number
    deals: number
    certifications: number
    workflows: number
  }

  export type SMECountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | SMECountOutputTypeCountDocumentsArgs
    deals?: boolean | SMECountOutputTypeCountDealsArgs
    certifications?: boolean | SMECountOutputTypeCountCertificationsArgs
    workflows?: boolean | SMECountOutputTypeCountWorkflowsArgs
  }

  // Custom InputTypes
  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMECountOutputType
     */
    select?: SMECountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }

  /**
   * SMECountOutputType without action
   */
  export type SMECountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * Count Type InvestorCountOutputType
   */

  export type InvestorCountOutputType = {
    dealInvestments: number
    workflows: number
  }

  export type InvestorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dealInvestments?: boolean | InvestorCountOutputTypeCountDealInvestmentsArgs
    workflows?: boolean | InvestorCountOutputTypeCountWorkflowsArgs
  }

  // Custom InputTypes
  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorCountOutputType
     */
    select?: InvestorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountDealInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
  }

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * Count Type AdvisorCountOutputType
   */

  export type AdvisorCountOutputType = {
    certifications: number
    workflows: number
  }

  export type AdvisorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certifications?: boolean | AdvisorCountOutputTypeCountCertificationsArgs
    workflows?: boolean | AdvisorCountOutputTypeCountWorkflowsArgs
  }

  // Custom InputTypes
  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvisorCountOutputType
     */
    select?: AdvisorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }

  /**
   * AdvisorCountOutputType without action
   */
  export type AdvisorCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    investors: number
    documents: number
    workflows: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investors?: boolean | DealCountOutputTypeCountInvestorsArgs
    documents?: boolean | DealCountOutputTypeCountDocumentsArgs
    workflows?: boolean | DealCountOutputTypeCountWorkflowsArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    smes?: boolean | Tenant$smesArgs<ExtArgs>
    investors?: boolean | Tenant$investorsArgs<ExtArgs>
    advisors?: boolean | Tenant$advisorsArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    workflows?: boolean | Tenant$workflowsArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    smes?: boolean | Tenant$smesArgs<ExtArgs>
    investors?: boolean | Tenant$investorsArgs<ExtArgs>
    advisors?: boolean | Tenant$advisorsArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    workflows?: boolean | Tenant$workflowsArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      smes: Prisma.$SMEPayload<ExtArgs>[]
      investors: Prisma.$InvestorPayload<ExtArgs>[]
      advisors: Prisma.$AdvisorPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    smes<T extends Tenant$smesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$smesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findMany"> | Null>
    investors<T extends Tenant$investorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findMany"> | Null>
    advisors<T extends Tenant$advisorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$advisorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findMany"> | Null>
    deals<T extends Tenant$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends Tenant$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Tenant$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.smes
   */
  export type Tenant$smesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    cursor?: SMEWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }

  /**
   * Tenant.investors
   */
  export type Tenant$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    cursor?: InvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Tenant.advisors
   */
  export type Tenant$advisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    cursor?: AdvisorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }

  /**
   * Tenant.deals
   */
  export type Tenant$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Tenant.workflows
   */
  export type Tenant$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Tenant.documents
   */
  export type Tenant$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: $Enums.Language | null
    did: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    language: $Enums.Language | null
    did: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    status: number
    language: number
    did: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    language?: true
    did?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    language: $Enums.Language
    did: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | User$smeArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    advisor?: boolean | User$advisorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    language?: boolean
    did?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | User$smeArgs<ExtArgs>
    investor?: boolean | User$investorArgs<ExtArgs>
    advisor?: boolean | User$advisorArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      language: $Enums.Language
      did: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sme<T extends User$smeArgs<ExtArgs> = {}>(args?: Subset<T, User$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    investor<T extends User$investorArgs<ExtArgs> = {}>(args?: Subset<T, User$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    advisor<T extends User$advisorArgs<ExtArgs> = {}>(args?: Subset<T, User$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly language: FieldRef<"User", 'Language'>
    readonly did: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.sme
   */
  export type User$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }

  /**
   * User.investor
   */
  export type User$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }

  /**
   * User.advisor
   */
  export type User$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SME
   */

  export type AggregateSME = {
    _count: SMECountAggregateOutputType | null
    _avg: SMEAvgAggregateOutputType | null
    _sum: SMESumAggregateOutputType | null
    _min: SMEMinAggregateOutputType | null
    _max: SMEMaxAggregateOutputType | null
  }

  export type SMEAvgAggregateOutputType = {
    fundingRequired: number | null
    score: number | null
  }

  export type SMESumAggregateOutputType = {
    fundingRequired: number | null
    score: number | null
  }

  export type SMEMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    sector: string | null
    stage: $Enums.SMEStage | null
    fundingRequired: number | null
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean | null
    certificationDate: Date | null
    status: $Enums.SMEStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SMEMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    sector: string | null
    stage: $Enums.SMEStage | null
    fundingRequired: number | null
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean | null
    certificationDate: Date | null
    status: $Enums.SMEStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SMECountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    sector: number
    stage: number
    fundingRequired: number
    description: number
    website: number
    location: number
    score: number
    certified: number
    certificationDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SMEAvgAggregateInputType = {
    fundingRequired?: true
    score?: true
  }

  export type SMESumAggregateInputType = {
    fundingRequired?: true
    score?: true
  }

  export type SMEMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SMEMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SMECountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    sector?: true
    stage?: true
    fundingRequired?: true
    description?: true
    website?: true
    location?: true
    score?: true
    certified?: true
    certificationDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SMEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SME to aggregate.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMES
    **/
    _count?: true | SMECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SMEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SMESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMEMaxAggregateInputType
  }

  export type GetSMEAggregateType<T extends SMEAggregateArgs> = {
        [P in keyof T & keyof AggregateSME]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSME[P]>
      : GetScalarType<T[P], AggregateSME[P]>
  }




  export type SMEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMEWhereInput
    orderBy?: SMEOrderByWithAggregationInput | SMEOrderByWithAggregationInput[]
    by: SMEScalarFieldEnum[] | SMEScalarFieldEnum
    having?: SMEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMECountAggregateInputType | true
    _avg?: SMEAvgAggregateInputType
    _sum?: SMESumAggregateInputType
    _min?: SMEMinAggregateInputType
    _max?: SMEMaxAggregateInputType
  }

  export type SMEGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description: string | null
    website: string | null
    location: string | null
    score: number | null
    certified: boolean
    certificationDate: Date | null
    status: $Enums.SMEStatus
    createdAt: Date
    updatedAt: Date
    _count: SMECountAggregateOutputType | null
    _avg: SMEAvgAggregateOutputType | null
    _sum: SMESumAggregateOutputType | null
    _min: SMEMinAggregateOutputType | null
    _max: SMEMaxAggregateOutputType | null
  }

  type GetSMEGroupByPayload<T extends SMEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMEGroupByOutputType[P]>
            : GetScalarType<T[P], SMEGroupByOutputType[P]>
        }
      >
    >


  export type SMESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | SME$documentsArgs<ExtArgs>
    deals?: boolean | SME$dealsArgs<ExtArgs>
    certifications?: boolean | SME$certificationsArgs<ExtArgs>
    workflows?: boolean | SME$workflowsArgs<ExtArgs>
    _count?: boolean | SMECountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sME"]>

  export type SMESelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sME"]>

  export type SMESelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    sector?: boolean
    stage?: boolean
    fundingRequired?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    score?: boolean
    certified?: boolean
    certificationDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SMEInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | SME$documentsArgs<ExtArgs>
    deals?: boolean | SME$dealsArgs<ExtArgs>
    certifications?: boolean | SME$certificationsArgs<ExtArgs>
    workflows?: boolean | SME$workflowsArgs<ExtArgs>
    _count?: boolean | SMECountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SMEIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SMEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SME"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      sector: string
      stage: $Enums.SMEStage
      fundingRequired: number
      description: string | null
      website: string | null
      location: string | null
      score: number | null
      certified: boolean
      certificationDate: Date | null
      status: $Enums.SMEStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sME"]>
    composites: {}
  }

  type SMEGetPayload<S extends boolean | null | undefined | SMEDefaultArgs> = $Result.GetResult<Prisma.$SMEPayload, S>

  type SMECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SMEFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SMECountAggregateInputType | true
    }

  export interface SMEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SME'], meta: { name: 'SME' } }
    /**
     * Find zero or one SME that matches the filter.
     * @param {SMEFindUniqueArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SMEFindUniqueArgs>(args: SelectSubset<T, SMEFindUniqueArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SME that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SMEFindUniqueOrThrowArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SMEFindUniqueOrThrowArgs>(args: SelectSubset<T, SMEFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SME that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindFirstArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SMEFindFirstArgs>(args?: SelectSubset<T, SMEFindFirstArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SME that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindFirstOrThrowArgs} args - Arguments to find a SME
     * @example
     * // Get one SME
     * const sME = await prisma.sME.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SMEFindFirstOrThrowArgs>(args?: SelectSubset<T, SMEFindFirstOrThrowArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SMES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMES
     * const sMES = await prisma.sME.findMany()
     * 
     * // Get first 10 SMES
     * const sMES = await prisma.sME.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMEWithIdOnly = await prisma.sME.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SMEFindManyArgs>(args?: SelectSubset<T, SMEFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SME.
     * @param {SMECreateArgs} args - Arguments to create a SME.
     * @example
     * // Create one SME
     * const SME = await prisma.sME.create({
     *   data: {
     *     // ... data to create a SME
     *   }
     * })
     * 
     */
    create<T extends SMECreateArgs>(args: SelectSubset<T, SMECreateArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SMES.
     * @param {SMECreateManyArgs} args - Arguments to create many SMES.
     * @example
     * // Create many SMES
     * const sME = await prisma.sME.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SMECreateManyArgs>(args?: SelectSubset<T, SMECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SMES and returns the data saved in the database.
     * @param {SMECreateManyAndReturnArgs} args - Arguments to create many SMES.
     * @example
     * // Create many SMES
     * const sME = await prisma.sME.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SMES and only return the `id`
     * const sMEWithIdOnly = await prisma.sME.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SMECreateManyAndReturnArgs>(args?: SelectSubset<T, SMECreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SME.
     * @param {SMEDeleteArgs} args - Arguments to delete one SME.
     * @example
     * // Delete one SME
     * const SME = await prisma.sME.delete({
     *   where: {
     *     // ... filter to delete one SME
     *   }
     * })
     * 
     */
    delete<T extends SMEDeleteArgs>(args: SelectSubset<T, SMEDeleteArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SME.
     * @param {SMEUpdateArgs} args - Arguments to update one SME.
     * @example
     * // Update one SME
     * const sME = await prisma.sME.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SMEUpdateArgs>(args: SelectSubset<T, SMEUpdateArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SMES.
     * @param {SMEDeleteManyArgs} args - Arguments to filter SMES to delete.
     * @example
     * // Delete a few SMES
     * const { count } = await prisma.sME.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SMEDeleteManyArgs>(args?: SelectSubset<T, SMEDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMES
     * const sME = await prisma.sME.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SMEUpdateManyArgs>(args: SelectSubset<T, SMEUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SME.
     * @param {SMEUpsertArgs} args - Arguments to update or create a SME.
     * @example
     * // Update or create a SME
     * const sME = await prisma.sME.upsert({
     *   create: {
     *     // ... data to create a SME
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SME we want to update
     *   }
     * })
     */
    upsert<T extends SMEUpsertArgs>(args: SelectSubset<T, SMEUpsertArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMECountArgs} args - Arguments to filter SMES to count.
     * @example
     * // Count the number of SMES
     * const count = await prisma.sME.count({
     *   where: {
     *     // ... the filter for the SMES we want to count
     *   }
     * })
    **/
    count<T extends SMECountArgs>(
      args?: Subset<T, SMECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMEAggregateArgs>(args: Subset<T, SMEAggregateArgs>): Prisma.PrismaPromise<GetSMEAggregateType<T>>

    /**
     * Group by SME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMEGroupByArgs['orderBy'] }
        : { orderBy?: SMEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SME model
   */
  readonly fields: SMEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SME.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documents<T extends SME$documentsArgs<ExtArgs> = {}>(args?: Subset<T, SME$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    deals<T extends SME$dealsArgs<ExtArgs> = {}>(args?: Subset<T, SME$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany"> | Null>
    certifications<T extends SME$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, SME$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends SME$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, SME$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SME model
   */ 
  interface SMEFieldRefs {
    readonly id: FieldRef<"SME", 'String'>
    readonly tenantId: FieldRef<"SME", 'String'>
    readonly userId: FieldRef<"SME", 'String'>
    readonly name: FieldRef<"SME", 'String'>
    readonly sector: FieldRef<"SME", 'String'>
    readonly stage: FieldRef<"SME", 'SMEStage'>
    readonly fundingRequired: FieldRef<"SME", 'Float'>
    readonly description: FieldRef<"SME", 'String'>
    readonly website: FieldRef<"SME", 'String'>
    readonly location: FieldRef<"SME", 'String'>
    readonly score: FieldRef<"SME", 'Float'>
    readonly certified: FieldRef<"SME", 'Boolean'>
    readonly certificationDate: FieldRef<"SME", 'DateTime'>
    readonly status: FieldRef<"SME", 'SMEStatus'>
    readonly createdAt: FieldRef<"SME", 'DateTime'>
    readonly updatedAt: FieldRef<"SME", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SME findUnique
   */
  export type SMEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where: SMEWhereUniqueInput
  }

  /**
   * SME findUniqueOrThrow
   */
  export type SMEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where: SMEWhereUniqueInput
  }

  /**
   * SME findFirst
   */
  export type SMEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMES.
     */
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }

  /**
   * SME findFirstOrThrow
   */
  export type SMEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SME to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMES.
     */
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }

  /**
   * SME findMany
   */
  export type SMEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter, which SMES to fetch.
     */
    where?: SMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMES to fetch.
     */
    orderBy?: SMEOrderByWithRelationInput | SMEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMES.
     */
    cursor?: SMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMES.
     */
    skip?: number
    distinct?: SMEScalarFieldEnum | SMEScalarFieldEnum[]
  }

  /**
   * SME create
   */
  export type SMECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The data needed to create a SME.
     */
    data: XOR<SMECreateInput, SMEUncheckedCreateInput>
  }

  /**
   * SME createMany
   */
  export type SMECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMES.
     */
    data: SMECreateManyInput | SMECreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SME createManyAndReturn
   */
  export type SMECreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SMES.
     */
    data: SMECreateManyInput | SMECreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SME update
   */
  export type SMEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The data needed to update a SME.
     */
    data: XOR<SMEUpdateInput, SMEUncheckedUpdateInput>
    /**
     * Choose, which SME to update.
     */
    where: SMEWhereUniqueInput
  }

  /**
   * SME updateMany
   */
  export type SMEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMES.
     */
    data: XOR<SMEUpdateManyMutationInput, SMEUncheckedUpdateManyInput>
    /**
     * Filter which SMES to update
     */
    where?: SMEWhereInput
  }

  /**
   * SME upsert
   */
  export type SMEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * The filter to search for the SME to update in case it exists.
     */
    where: SMEWhereUniqueInput
    /**
     * In case the SME found by the `where` argument doesn't exist, create a new SME with this data.
     */
    create: XOR<SMECreateInput, SMEUncheckedCreateInput>
    /**
     * In case the SME was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMEUpdateInput, SMEUncheckedUpdateInput>
  }

  /**
   * SME delete
   */
  export type SMEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    /**
     * Filter which SME to delete.
     */
    where: SMEWhereUniqueInput
  }

  /**
   * SME deleteMany
   */
  export type SMEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMES to delete
     */
    where?: SMEWhereInput
  }

  /**
   * SME.documents
   */
  export type SME$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * SME.deals
   */
  export type SME$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * SME.certifications
   */
  export type SME$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * SME.workflows
   */
  export type SME$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * SME without action
   */
  export type SMEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
  }


  /**
   * Model Investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    type: $Enums.InvestorType | null
    kycStatus: $Enums.KYCStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    type: $Enums.InvestorType | null
    kycStatus: $Enums.KYCStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    type: number
    kycStatus: number
    preferences: number
    portfolio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    type?: true
    kycStatus?: true
    preferences?: true
    portfolio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investor to aggregate.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type InvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithAggregationInput | InvestorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: InvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus: $Enums.KYCStatus
    preferences: JsonValue
    portfolio: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: InvestorCountAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends InvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type InvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestments?: boolean | Investor$dealInvestmentsArgs<ExtArgs>
    workflows?: boolean | Investor$workflowsArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    kycStatus?: boolean
    preferences?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    dealInvestments?: boolean | Investor$dealInvestmentsArgs<ExtArgs>
    workflows?: boolean | Investor$workflowsArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvestorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      dealInvestments: Prisma.$DealInvestorPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      type: $Enums.InvestorType
      kycStatus: $Enums.KYCStatus
      preferences: Prisma.JsonValue
      portfolio: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }

  type InvestorGetPayload<S extends boolean | null | undefined | InvestorDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayload, S>

  type InvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvestorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface InvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investor'], meta: { name: 'Investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {InvestorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorFindUniqueArgs>(args: SelectSubset<T, InvestorFindUniqueArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvestorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorFindFirstArgs>(args?: SelectSubset<T, InvestorFindFirstArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorFindManyArgs>(args?: SelectSubset<T, InvestorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investor.
     * @param {InvestorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
     */
    create<T extends InvestorCreateArgs>(args: SelectSubset<T, InvestorCreateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investors.
     * @param {InvestorCreateManyArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorCreateManyArgs>(args?: SelectSubset<T, InvestorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Investors and returns the data saved in the database.
     * @param {InvestorCreateManyAndReturnArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Investors and only return the `id`
     * const investorWithIdOnly = await prisma.investor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Investor.
     * @param {InvestorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
     */
    delete<T extends InvestorDeleteArgs>(args: SelectSubset<T, InvestorDeleteArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investor.
     * @param {InvestorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorUpdateArgs>(args: SelectSubset<T, InvestorUpdateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investors.
     * @param {InvestorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorDeleteManyArgs>(args?: SelectSubset<T, InvestorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorUpdateManyArgs>(args: SelectSubset<T, InvestorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investor.
     * @param {InvestorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
     */
    upsert<T extends InvestorUpsertArgs>(args: SelectSubset<T, InvestorUpsertArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends InvestorCountArgs>(
      args?: Subset<T, InvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investor model
   */
  readonly fields: InvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dealInvestments<T extends Investor$dealInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$dealInvestmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends Investor$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investor model
   */ 
  interface InvestorFieldRefs {
    readonly id: FieldRef<"Investor", 'String'>
    readonly tenantId: FieldRef<"Investor", 'String'>
    readonly userId: FieldRef<"Investor", 'String'>
    readonly name: FieldRef<"Investor", 'String'>
    readonly type: FieldRef<"Investor", 'InvestorType'>
    readonly kycStatus: FieldRef<"Investor", 'KYCStatus'>
    readonly preferences: FieldRef<"Investor", 'Json'>
    readonly portfolio: FieldRef<"Investor", 'Json'>
    readonly createdAt: FieldRef<"Investor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investor findUnique
   */
  export type InvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findUniqueOrThrow
   */
  export type InvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findFirst
   */
  export type InvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findFirstOrThrow
   */
  export type InvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findMany
   */
  export type InvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investors to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor create
   */
  export type InvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a Investor.
     */
    data: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
  }

  /**
   * Investor createMany
   */
  export type InvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Investor createManyAndReturn
   */
  export type InvestorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investor update
   */
  export type InvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a Investor.
     */
    data: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
    /**
     * Choose, which Investor to update.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor updateMany
   */
  export type InvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
  }

  /**
   * Investor upsert
   */
  export type InvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the Investor to update in case it exists.
     */
    where: InvestorWhereUniqueInput
    /**
     * In case the Investor found by the `where` argument doesn't exist, create a new Investor with this data.
     */
    create: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
    /**
     * In case the Investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
  }

  /**
   * Investor delete
   */
  export type InvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter which Investor to delete.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor deleteMany
   */
  export type InvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investors to delete
     */
    where?: InvestorWhereInput
  }

  /**
   * Investor.dealInvestments
   */
  export type Investor$dealInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    cursor?: DealInvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }

  /**
   * Investor.workflows
   */
  export type Investor$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Investor without action
   */
  export type InvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
  }


  /**
   * Model Advisor
   */

  export type AggregateAdvisor = {
    _count: AdvisorCountAggregateOutputType | null
    _min: AdvisorMinAggregateOutputType | null
    _max: AdvisorMaxAggregateOutputType | null
  }

  export type AdvisorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    status: $Enums.AdvisorStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    status: $Enums.AdvisorStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvisorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    specialization: number
    certificationList: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdvisorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvisorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    specialization?: true
    certificationList?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdvisorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advisor to aggregate.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advisors
    **/
    _count?: true | AdvisorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvisorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvisorMaxAggregateInputType
  }

  export type GetAdvisorAggregateType<T extends AdvisorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvisor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvisor[P]>
      : GetScalarType<T[P], AggregateAdvisor[P]>
  }




  export type AdvisorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvisorWhereInput
    orderBy?: AdvisorOrderByWithAggregationInput | AdvisorOrderByWithAggregationInput[]
    by: AdvisorScalarFieldEnum[] | AdvisorScalarFieldEnum
    having?: AdvisorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvisorCountAggregateInputType | true
    _min?: AdvisorMinAggregateInputType
    _max?: AdvisorMaxAggregateInputType
  }

  export type AdvisorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    name: string
    specialization: string[]
    certificationList: string[]
    status: $Enums.AdvisorStatus
    createdAt: Date
    updatedAt: Date
    _count: AdvisorCountAggregateOutputType | null
    _min: AdvisorMinAggregateOutputType | null
    _max: AdvisorMaxAggregateOutputType | null
  }

  type GetAdvisorGroupByPayload<T extends AdvisorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvisorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvisorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvisorGroupByOutputType[P]>
            : GetScalarType<T[P], AdvisorGroupByOutputType[P]>
        }
      >
    >


  export type AdvisorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    certifications?: boolean | Advisor$certificationsArgs<ExtArgs>
    workflows?: boolean | Advisor$workflowsArgs<ExtArgs>
    _count?: boolean | AdvisorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advisor"]>

  export type AdvisorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advisor"]>

  export type AdvisorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    specialization?: boolean
    certificationList?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdvisorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    certifications?: boolean | Advisor$certificationsArgs<ExtArgs>
    workflows?: boolean | Advisor$workflowsArgs<ExtArgs>
    _count?: boolean | AdvisorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdvisorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdvisorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advisor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      name: string
      specialization: string[]
      certificationList: string[]
      status: $Enums.AdvisorStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["advisor"]>
    composites: {}
  }

  type AdvisorGetPayload<S extends boolean | null | undefined | AdvisorDefaultArgs> = $Result.GetResult<Prisma.$AdvisorPayload, S>

  type AdvisorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvisorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvisorCountAggregateInputType | true
    }

  export interface AdvisorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advisor'], meta: { name: 'Advisor' } }
    /**
     * Find zero or one Advisor that matches the filter.
     * @param {AdvisorFindUniqueArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvisorFindUniqueArgs>(args: SelectSubset<T, AdvisorFindUniqueArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Advisor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvisorFindUniqueOrThrowArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvisorFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvisorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Advisor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindFirstArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvisorFindFirstArgs>(args?: SelectSubset<T, AdvisorFindFirstArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Advisor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindFirstOrThrowArgs} args - Arguments to find a Advisor
     * @example
     * // Get one Advisor
     * const advisor = await prisma.advisor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvisorFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvisorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Advisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advisors
     * const advisors = await prisma.advisor.findMany()
     * 
     * // Get first 10 Advisors
     * const advisors = await prisma.advisor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advisorWithIdOnly = await prisma.advisor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvisorFindManyArgs>(args?: SelectSubset<T, AdvisorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Advisor.
     * @param {AdvisorCreateArgs} args - Arguments to create a Advisor.
     * @example
     * // Create one Advisor
     * const Advisor = await prisma.advisor.create({
     *   data: {
     *     // ... data to create a Advisor
     *   }
     * })
     * 
     */
    create<T extends AdvisorCreateArgs>(args: SelectSubset<T, AdvisorCreateArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Advisors.
     * @param {AdvisorCreateManyArgs} args - Arguments to create many Advisors.
     * @example
     * // Create many Advisors
     * const advisor = await prisma.advisor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvisorCreateManyArgs>(args?: SelectSubset<T, AdvisorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Advisors and returns the data saved in the database.
     * @param {AdvisorCreateManyAndReturnArgs} args - Arguments to create many Advisors.
     * @example
     * // Create many Advisors
     * const advisor = await prisma.advisor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Advisors and only return the `id`
     * const advisorWithIdOnly = await prisma.advisor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvisorCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvisorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Advisor.
     * @param {AdvisorDeleteArgs} args - Arguments to delete one Advisor.
     * @example
     * // Delete one Advisor
     * const Advisor = await prisma.advisor.delete({
     *   where: {
     *     // ... filter to delete one Advisor
     *   }
     * })
     * 
     */
    delete<T extends AdvisorDeleteArgs>(args: SelectSubset<T, AdvisorDeleteArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Advisor.
     * @param {AdvisorUpdateArgs} args - Arguments to update one Advisor.
     * @example
     * // Update one Advisor
     * const advisor = await prisma.advisor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvisorUpdateArgs>(args: SelectSubset<T, AdvisorUpdateArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Advisors.
     * @param {AdvisorDeleteManyArgs} args - Arguments to filter Advisors to delete.
     * @example
     * // Delete a few Advisors
     * const { count } = await prisma.advisor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvisorDeleteManyArgs>(args?: SelectSubset<T, AdvisorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advisors
     * const advisor = await prisma.advisor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvisorUpdateManyArgs>(args: SelectSubset<T, AdvisorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advisor.
     * @param {AdvisorUpsertArgs} args - Arguments to update or create a Advisor.
     * @example
     * // Update or create a Advisor
     * const advisor = await prisma.advisor.upsert({
     *   create: {
     *     // ... data to create a Advisor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advisor we want to update
     *   }
     * })
     */
    upsert<T extends AdvisorUpsertArgs>(args: SelectSubset<T, AdvisorUpsertArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Advisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorCountArgs} args - Arguments to filter Advisors to count.
     * @example
     * // Count the number of Advisors
     * const count = await prisma.advisor.count({
     *   where: {
     *     // ... the filter for the Advisors we want to count
     *   }
     * })
    **/
    count<T extends AdvisorCountArgs>(
      args?: Subset<T, AdvisorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvisorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvisorAggregateArgs>(args: Subset<T, AdvisorAggregateArgs>): Prisma.PrismaPromise<GetAdvisorAggregateType<T>>

    /**
     * Group by Advisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvisorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvisorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvisorGroupByArgs['orderBy'] }
        : { orderBy?: AdvisorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvisorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvisorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advisor model
   */
  readonly fields: AdvisorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advisor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvisorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    certifications<T extends Advisor$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends Advisor$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Advisor$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Advisor model
   */ 
  interface AdvisorFieldRefs {
    readonly id: FieldRef<"Advisor", 'String'>
    readonly tenantId: FieldRef<"Advisor", 'String'>
    readonly userId: FieldRef<"Advisor", 'String'>
    readonly name: FieldRef<"Advisor", 'String'>
    readonly specialization: FieldRef<"Advisor", 'String[]'>
    readonly certificationList: FieldRef<"Advisor", 'String[]'>
    readonly status: FieldRef<"Advisor", 'AdvisorStatus'>
    readonly createdAt: FieldRef<"Advisor", 'DateTime'>
    readonly updatedAt: FieldRef<"Advisor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Advisor findUnique
   */
  export type AdvisorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where: AdvisorWhereUniqueInput
  }

  /**
   * Advisor findUniqueOrThrow
   */
  export type AdvisorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where: AdvisorWhereUniqueInput
  }

  /**
   * Advisor findFirst
   */
  export type AdvisorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advisors.
     */
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }

  /**
   * Advisor findFirstOrThrow
   */
  export type AdvisorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisor to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advisors.
     */
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }

  /**
   * Advisor findMany
   */
  export type AdvisorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter, which Advisors to fetch.
     */
    where?: AdvisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advisors to fetch.
     */
    orderBy?: AdvisorOrderByWithRelationInput | AdvisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advisors.
     */
    cursor?: AdvisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advisors.
     */
    skip?: number
    distinct?: AdvisorScalarFieldEnum | AdvisorScalarFieldEnum[]
  }

  /**
   * Advisor create
   */
  export type AdvisorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The data needed to create a Advisor.
     */
    data: XOR<AdvisorCreateInput, AdvisorUncheckedCreateInput>
  }

  /**
   * Advisor createMany
   */
  export type AdvisorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advisors.
     */
    data: AdvisorCreateManyInput | AdvisorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advisor createManyAndReturn
   */
  export type AdvisorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Advisors.
     */
    data: AdvisorCreateManyInput | AdvisorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Advisor update
   */
  export type AdvisorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The data needed to update a Advisor.
     */
    data: XOR<AdvisorUpdateInput, AdvisorUncheckedUpdateInput>
    /**
     * Choose, which Advisor to update.
     */
    where: AdvisorWhereUniqueInput
  }

  /**
   * Advisor updateMany
   */
  export type AdvisorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advisors.
     */
    data: XOR<AdvisorUpdateManyMutationInput, AdvisorUncheckedUpdateManyInput>
    /**
     * Filter which Advisors to update
     */
    where?: AdvisorWhereInput
  }

  /**
   * Advisor upsert
   */
  export type AdvisorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * The filter to search for the Advisor to update in case it exists.
     */
    where: AdvisorWhereUniqueInput
    /**
     * In case the Advisor found by the `where` argument doesn't exist, create a new Advisor with this data.
     */
    create: XOR<AdvisorCreateInput, AdvisorUncheckedCreateInput>
    /**
     * In case the Advisor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvisorUpdateInput, AdvisorUncheckedUpdateInput>
  }

  /**
   * Advisor delete
   */
  export type AdvisorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    /**
     * Filter which Advisor to delete.
     */
    where: AdvisorWhereUniqueInput
  }

  /**
   * Advisor deleteMany
   */
  export type AdvisorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advisors to delete
     */
    where?: AdvisorWhereInput
  }

  /**
   * Advisor.certifications
   */
  export type Advisor$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Advisor.workflows
   */
  export type Advisor$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Advisor without action
   */
  export type AdvisorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    amount: number | null
    equity: number | null
    successFee: number | null
  }

  export type DealSumAggregateOutputType = {
    amount: number | null
    equity: number | null
    successFee: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    title: string | null
    description: string | null
    amount: number | null
    equity: number | null
    status: $Enums.DealStatus | null
    successFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    smeId: string | null
    title: string | null
    description: string | null
    amount: number | null
    equity: number | null
    status: $Enums.DealStatus | null
    successFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    tenantId: number
    smeId: number
    title: number
    description: number
    amount: number
    equity: number
    status: number
    successFee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    amount?: true
    equity?: true
    successFee?: true
  }

  export type DealSumAggregateInputType = {
    amount?: true
    equity?: true
    successFee?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    tenantId?: true
    smeId?: true
    title?: true
    description?: true
    amount?: true
    equity?: true
    status?: true
    successFee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    tenantId: string
    smeId: string
    title: string
    description: string | null
    amount: number
    equity: number | null
    status: $Enums.DealStatus
    successFee: number | null
    createdAt: Date
    updatedAt: Date
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investors?: boolean | Deal$investorsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    workflows?: boolean | Deal$workflowsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    tenantId?: boolean
    smeId?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    equity?: boolean
    status?: boolean
    successFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    investors?: boolean | Deal$investorsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    workflows?: boolean | Deal$workflowsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | SMEDefaultArgs<ExtArgs>
  }

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs>
      investors: Prisma.$DealInvestorPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      smeId: string
      title: string
      description: string | null
      amount: number
      equity: number | null
      status: $Enums.DealStatus
      successFee: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deals and returns the data saved in the database.
     * @param {DealCreateManyAndReturnArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealCreateManyAndReturnArgs>(args?: SelectSubset<T, DealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    investors<T extends Deal$investorsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Deal$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends Deal$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */ 
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly tenantId: FieldRef<"Deal", 'String'>
    readonly smeId: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly description: FieldRef<"Deal", 'String'>
    readonly amount: FieldRef<"Deal", 'Float'>
    readonly equity: FieldRef<"Deal", 'Float'>
    readonly status: FieldRef<"Deal", 'DealStatus'>
    readonly successFee: FieldRef<"Deal", 'Float'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal createManyAndReturn
   */
  export type DealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
  }

  /**
   * Deal.investors
   */
  export type Deal$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    cursor?: DealInvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }

  /**
   * Deal.documents
   */
  export type Deal$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Deal.workflows
   */
  export type Deal$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model DealInvestor
   */

  export type AggregateDealInvestor = {
    _count: DealInvestorCountAggregateOutputType | null
    _avg: DealInvestorAvgAggregateOutputType | null
    _sum: DealInvestorSumAggregateOutputType | null
    _min: DealInvestorMinAggregateOutputType | null
    _max: DealInvestorMaxAggregateOutputType | null
  }

  export type DealInvestorAvgAggregateOutputType = {
    amount: number | null
  }

  export type DealInvestorSumAggregateOutputType = {
    amount: number | null
  }

  export type DealInvestorMinAggregateOutputType = {
    id: string | null
    dealId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.InvestmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealInvestorMaxAggregateOutputType = {
    id: string | null
    dealId: string | null
    investorId: string | null
    amount: number | null
    status: $Enums.InvestmentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealInvestorCountAggregateOutputType = {
    id: number
    dealId: number
    investorId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealInvestorAvgAggregateInputType = {
    amount?: true
  }

  export type DealInvestorSumAggregateInputType = {
    amount?: true
  }

  export type DealInvestorMinAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealInvestorMaxAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealInvestorCountAggregateInputType = {
    id?: true
    dealId?: true
    investorId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealInvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealInvestor to aggregate.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DealInvestors
    **/
    _count?: true | DealInvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealInvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealInvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealInvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealInvestorMaxAggregateInputType
  }

  export type GetDealInvestorAggregateType<T extends DealInvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateDealInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealInvestor[P]>
      : GetScalarType<T[P], AggregateDealInvestor[P]>
  }




  export type DealInvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealInvestorWhereInput
    orderBy?: DealInvestorOrderByWithAggregationInput | DealInvestorOrderByWithAggregationInput[]
    by: DealInvestorScalarFieldEnum[] | DealInvestorScalarFieldEnum
    having?: DealInvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealInvestorCountAggregateInputType | true
    _avg?: DealInvestorAvgAggregateInputType
    _sum?: DealInvestorSumAggregateInputType
    _min?: DealInvestorMinAggregateInputType
    _max?: DealInvestorMaxAggregateInputType
  }

  export type DealInvestorGroupByOutputType = {
    id: string
    dealId: string
    investorId: string
    amount: number
    status: $Enums.InvestmentStatus
    createdAt: Date
    updatedAt: Date
    _count: DealInvestorCountAggregateOutputType | null
    _avg: DealInvestorAvgAggregateOutputType | null
    _sum: DealInvestorSumAggregateOutputType | null
    _min: DealInvestorMinAggregateOutputType | null
    _max: DealInvestorMaxAggregateOutputType | null
  }

  type GetDealInvestorGroupByPayload<T extends DealInvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealInvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealInvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealInvestorGroupByOutputType[P]>
            : GetScalarType<T[P], DealInvestorGroupByOutputType[P]>
        }
      >
    >


  export type DealInvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealInvestor"]>

  export type DealInvestorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealInvestor"]>

  export type DealInvestorSelectScalar = {
    id?: boolean
    dealId?: boolean
    investorId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealInvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }
  export type DealInvestorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deal?: boolean | DealDefaultArgs<ExtArgs>
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }

  export type $DealInvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DealInvestor"
    objects: {
      deal: Prisma.$DealPayload<ExtArgs>
      investor: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dealId: string
      investorId: string
      amount: number
      status: $Enums.InvestmentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dealInvestor"]>
    composites: {}
  }

  type DealInvestorGetPayload<S extends boolean | null | undefined | DealInvestorDefaultArgs> = $Result.GetResult<Prisma.$DealInvestorPayload, S>

  type DealInvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealInvestorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealInvestorCountAggregateInputType | true
    }

  export interface DealInvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DealInvestor'], meta: { name: 'DealInvestor' } }
    /**
     * Find zero or one DealInvestor that matches the filter.
     * @param {DealInvestorFindUniqueArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealInvestorFindUniqueArgs>(args: SelectSubset<T, DealInvestorFindUniqueArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DealInvestor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealInvestorFindUniqueOrThrowArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealInvestorFindUniqueOrThrowArgs>(args: SelectSubset<T, DealInvestorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DealInvestor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindFirstArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealInvestorFindFirstArgs>(args?: SelectSubset<T, DealInvestorFindFirstArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DealInvestor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindFirstOrThrowArgs} args - Arguments to find a DealInvestor
     * @example
     * // Get one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealInvestorFindFirstOrThrowArgs>(args?: SelectSubset<T, DealInvestorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DealInvestors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DealInvestors
     * const dealInvestors = await prisma.dealInvestor.findMany()
     * 
     * // Get first 10 DealInvestors
     * const dealInvestors = await prisma.dealInvestor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealInvestorWithIdOnly = await prisma.dealInvestor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealInvestorFindManyArgs>(args?: SelectSubset<T, DealInvestorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DealInvestor.
     * @param {DealInvestorCreateArgs} args - Arguments to create a DealInvestor.
     * @example
     * // Create one DealInvestor
     * const DealInvestor = await prisma.dealInvestor.create({
     *   data: {
     *     // ... data to create a DealInvestor
     *   }
     * })
     * 
     */
    create<T extends DealInvestorCreateArgs>(args: SelectSubset<T, DealInvestorCreateArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DealInvestors.
     * @param {DealInvestorCreateManyArgs} args - Arguments to create many DealInvestors.
     * @example
     * // Create many DealInvestors
     * const dealInvestor = await prisma.dealInvestor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealInvestorCreateManyArgs>(args?: SelectSubset<T, DealInvestorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DealInvestors and returns the data saved in the database.
     * @param {DealInvestorCreateManyAndReturnArgs} args - Arguments to create many DealInvestors.
     * @example
     * // Create many DealInvestors
     * const dealInvestor = await prisma.dealInvestor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DealInvestors and only return the `id`
     * const dealInvestorWithIdOnly = await prisma.dealInvestor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealInvestorCreateManyAndReturnArgs>(args?: SelectSubset<T, DealInvestorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DealInvestor.
     * @param {DealInvestorDeleteArgs} args - Arguments to delete one DealInvestor.
     * @example
     * // Delete one DealInvestor
     * const DealInvestor = await prisma.dealInvestor.delete({
     *   where: {
     *     // ... filter to delete one DealInvestor
     *   }
     * })
     * 
     */
    delete<T extends DealInvestorDeleteArgs>(args: SelectSubset<T, DealInvestorDeleteArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DealInvestor.
     * @param {DealInvestorUpdateArgs} args - Arguments to update one DealInvestor.
     * @example
     * // Update one DealInvestor
     * const dealInvestor = await prisma.dealInvestor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealInvestorUpdateArgs>(args: SelectSubset<T, DealInvestorUpdateArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DealInvestors.
     * @param {DealInvestorDeleteManyArgs} args - Arguments to filter DealInvestors to delete.
     * @example
     * // Delete a few DealInvestors
     * const { count } = await prisma.dealInvestor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealInvestorDeleteManyArgs>(args?: SelectSubset<T, DealInvestorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealInvestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DealInvestors
     * const dealInvestor = await prisma.dealInvestor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealInvestorUpdateManyArgs>(args: SelectSubset<T, DealInvestorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DealInvestor.
     * @param {DealInvestorUpsertArgs} args - Arguments to update or create a DealInvestor.
     * @example
     * // Update or create a DealInvestor
     * const dealInvestor = await prisma.dealInvestor.upsert({
     *   create: {
     *     // ... data to create a DealInvestor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DealInvestor we want to update
     *   }
     * })
     */
    upsert<T extends DealInvestorUpsertArgs>(args: SelectSubset<T, DealInvestorUpsertArgs<ExtArgs>>): Prisma__DealInvestorClient<$Result.GetResult<Prisma.$DealInvestorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DealInvestors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorCountArgs} args - Arguments to filter DealInvestors to count.
     * @example
     * // Count the number of DealInvestors
     * const count = await prisma.dealInvestor.count({
     *   where: {
     *     // ... the filter for the DealInvestors we want to count
     *   }
     * })
    **/
    count<T extends DealInvestorCountArgs>(
      args?: Subset<T, DealInvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealInvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DealInvestor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealInvestorAggregateArgs>(args: Subset<T, DealInvestorAggregateArgs>): Prisma.PrismaPromise<GetDealInvestorAggregateType<T>>

    /**
     * Group by DealInvestor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealInvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealInvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealInvestorGroupByArgs['orderBy'] }
        : { orderBy?: DealInvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealInvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DealInvestor model
   */
  readonly fields: DealInvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DealInvestor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealInvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deal<T extends DealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealDefaultArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DealInvestor model
   */ 
  interface DealInvestorFieldRefs {
    readonly id: FieldRef<"DealInvestor", 'String'>
    readonly dealId: FieldRef<"DealInvestor", 'String'>
    readonly investorId: FieldRef<"DealInvestor", 'String'>
    readonly amount: FieldRef<"DealInvestor", 'Float'>
    readonly status: FieldRef<"DealInvestor", 'InvestmentStatus'>
    readonly createdAt: FieldRef<"DealInvestor", 'DateTime'>
    readonly updatedAt: FieldRef<"DealInvestor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DealInvestor findUnique
   */
  export type DealInvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where: DealInvestorWhereUniqueInput
  }

  /**
   * DealInvestor findUniqueOrThrow
   */
  export type DealInvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where: DealInvestorWhereUniqueInput
  }

  /**
   * DealInvestor findFirst
   */
  export type DealInvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealInvestors.
     */
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }

  /**
   * DealInvestor findFirstOrThrow
   */
  export type DealInvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestor to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealInvestors.
     */
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }

  /**
   * DealInvestor findMany
   */
  export type DealInvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter, which DealInvestors to fetch.
     */
    where?: DealInvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealInvestors to fetch.
     */
    orderBy?: DealInvestorOrderByWithRelationInput | DealInvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DealInvestors.
     */
    cursor?: DealInvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealInvestors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealInvestors.
     */
    skip?: number
    distinct?: DealInvestorScalarFieldEnum | DealInvestorScalarFieldEnum[]
  }

  /**
   * DealInvestor create
   */
  export type DealInvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a DealInvestor.
     */
    data: XOR<DealInvestorCreateInput, DealInvestorUncheckedCreateInput>
  }

  /**
   * DealInvestor createMany
   */
  export type DealInvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DealInvestors.
     */
    data: DealInvestorCreateManyInput | DealInvestorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DealInvestor createManyAndReturn
   */
  export type DealInvestorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DealInvestors.
     */
    data: DealInvestorCreateManyInput | DealInvestorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DealInvestor update
   */
  export type DealInvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a DealInvestor.
     */
    data: XOR<DealInvestorUpdateInput, DealInvestorUncheckedUpdateInput>
    /**
     * Choose, which DealInvestor to update.
     */
    where: DealInvestorWhereUniqueInput
  }

  /**
   * DealInvestor updateMany
   */
  export type DealInvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DealInvestors.
     */
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyInput>
    /**
     * Filter which DealInvestors to update
     */
    where?: DealInvestorWhereInput
  }

  /**
   * DealInvestor upsert
   */
  export type DealInvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the DealInvestor to update in case it exists.
     */
    where: DealInvestorWhereUniqueInput
    /**
     * In case the DealInvestor found by the `where` argument doesn't exist, create a new DealInvestor with this data.
     */
    create: XOR<DealInvestorCreateInput, DealInvestorUncheckedCreateInput>
    /**
     * In case the DealInvestor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealInvestorUpdateInput, DealInvestorUncheckedUpdateInput>
  }

  /**
   * DealInvestor delete
   */
  export type DealInvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
    /**
     * Filter which DealInvestor to delete.
     */
    where: DealInvestorWhereUniqueInput
  }

  /**
   * DealInvestor deleteMany
   */
  export type DealInvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealInvestors to delete
     */
    where?: DealInvestorWhereInput
  }

  /**
   * DealInvestor without action
   */
  export type DealInvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealInvestor
     */
    select?: DealInvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInvestorInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.DocumentType | null
    url: string | null
    size: number | null
    mimeType: string | null
    smeId: string | null
    dealId: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.DocumentType | null
    url: string | null
    size: number | null
    mimeType: string | null
    smeId: string | null
    dealId: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    type: number
    url: number
    size: number
    mimeType: number
    smeId: number
    dealId: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    url?: true
    size?: true
    mimeType?: true
    smeId?: true
    dealId?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId: string | null
    dealId: string | null
    uploadedBy: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    smeId?: boolean
    dealId?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Document$smeArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      type: $Enums.DocumentType
      url: string
      size: number
      mimeType: string
      smeId: string | null
      dealId: string | null
      uploadedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sme<T extends Document$smeArgs<ExtArgs> = {}>(args?: Subset<T, Document$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deal<T extends Document$dealArgs<ExtArgs> = {}>(args?: Subset<T, Document$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly tenantId: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly url: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly smeId: FieldRef<"Document", 'String'>
    readonly dealId: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.sme
   */
  export type Document$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }

  /**
   * Document.deal
   */
  export type Document$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _avg: CertificationAvgAggregateOutputType | null
    _sum: CertificationSumAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationAvgAggregateOutputType = {
    score: number | null
  }

  export type CertificationSumAggregateOutputType = {
    score: number | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    status: $Enums.CertificationStatus | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    smeId: string | null
    advisorId: string | null
    status: $Enums.CertificationStatus | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    smeId: number
    advisorId: number
    status: number
    score: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificationAvgAggregateInputType = {
    score?: true
  }

  export type CertificationSumAggregateInputType = {
    score?: true
  }

  export type CertificationMinAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    smeId?: true
    advisorId?: true
    status?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _avg?: CertificationAvgAggregateInputType
    _sum?: CertificationSumAggregateInputType
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    smeId: string
    advisorId: string
    status: $Enums.CertificationStatus
    score: number | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificationCountAggregateOutputType | null
    _avg: CertificationAvgAggregateOutputType | null
    _sum: CertificationSumAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    smeId?: boolean
    advisorId?: boolean
    status?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sme?: boolean | SMEDefaultArgs<ExtArgs>
    advisor?: boolean | AdvisorDefaultArgs<ExtArgs>
  }

  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      sme: Prisma.$SMEPayload<ExtArgs>
      advisor: Prisma.$AdvisorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      smeId: string
      advisorId: string
      status: $Enums.CertificationStatus
      score: number | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }

  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationFindUniqueArgs>(args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationFindFirstArgs>(args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationFindManyArgs>(args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
     */
    create<T extends CertificationCreateArgs>(args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certifications.
     * @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationCreateManyArgs>(args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {CertificationCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
     */
    delete<T extends CertificationDeleteArgs>(args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationUpdateArgs>(args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationDeleteManyArgs>(args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationUpdateManyArgs>(args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
     */
    upsert<T extends CertificationUpsertArgs>(args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sme<T extends SMEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SMEDefaultArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    advisor<T extends AdvisorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvisorDefaultArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certification model
   */ 
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly smeId: FieldRef<"Certification", 'String'>
    readonly advisorId: FieldRef<"Certification", 'String'>
    readonly status: FieldRef<"Certification", 'CertificationStatus'>
    readonly score: FieldRef<"Certification", 'Float'>
    readonly comments: FieldRef<"Certification", 'String'>
    readonly createdAt: FieldRef<"Certification", 'DateTime'>
    readonly updatedAt: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }

  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certification createManyAndReturn
   */
  export type CertificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
  }

  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }

  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
  }

  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
  }


  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.WorkflowType | null
    status: $Enums.WorkflowStatus | null
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.WorkflowType | null
    status: $Enums.WorkflowStatus | null
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    status: number
    data: number
    smeId: number
    investorId: number
    advisorId: number
    dealId: number
    didWorkflowId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    status?: true
    data?: true
    smeId?: true
    investorId?: true
    advisorId?: true
    dealId?: true
    didWorkflowId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.WorkflowType
    status: $Enums.WorkflowStatus
    data: JsonValue
    smeId: string | null
    investorId: string | null
    advisorId: string | null
    dealId: string | null
    didWorkflowId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowCountAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    smeId?: boolean
    investorId?: boolean
    advisorId?: boolean
    dealId?: boolean
    didWorkflowId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }
  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sme?: boolean | Workflow$smeArgs<ExtArgs>
    investor?: boolean | Workflow$investorArgs<ExtArgs>
    advisor?: boolean | Workflow$advisorArgs<ExtArgs>
    deal?: boolean | Workflow$dealArgs<ExtArgs>
  }

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sme: Prisma.$SMEPayload<ExtArgs> | null
      investor: Prisma.$InvestorPayload<ExtArgs> | null
      advisor: Prisma.$AdvisorPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.WorkflowType
      status: $Enums.WorkflowStatus
      data: Prisma.JsonValue
      smeId: string | null
      investorId: string | null
      advisorId: string | null
      dealId: string | null
      didWorkflowId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sme<T extends Workflow$smeArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$smeArgs<ExtArgs>>): Prisma__SMEClient<$Result.GetResult<Prisma.$SMEPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    investor<T extends Workflow$investorArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$investorArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    advisor<T extends Workflow$advisorArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$advisorArgs<ExtArgs>>): Prisma__AdvisorClient<$Result.GetResult<Prisma.$AdvisorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deal<T extends Workflow$dealArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */ 
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly tenantId: FieldRef<"Workflow", 'String'>
    readonly type: FieldRef<"Workflow", 'WorkflowType'>
    readonly status: FieldRef<"Workflow", 'WorkflowStatus'>
    readonly data: FieldRef<"Workflow", 'Json'>
    readonly smeId: FieldRef<"Workflow", 'String'>
    readonly investorId: FieldRef<"Workflow", 'String'>
    readonly advisorId: FieldRef<"Workflow", 'String'>
    readonly dealId: FieldRef<"Workflow", 'String'>
    readonly didWorkflowId: FieldRef<"Workflow", 'String'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
  }

  /**
   * Workflow.sme
   */
  export type Workflow$smeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SME
     */
    select?: SMESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMEInclude<ExtArgs> | null
    where?: SMEWhereInput
  }

  /**
   * Workflow.investor
   */
  export type Workflow$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
  }

  /**
   * Workflow.advisor
   */
  export type Workflow$advisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advisor
     */
    select?: AdvisorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvisorInclude<ExtArgs> | null
    where?: AdvisorWhereInput
  }

  /**
   * Workflow.deal
   */
  export type Workflow$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    language: 'language',
    did: 'did',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SMEScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    sector: 'sector',
    stage: 'stage',
    fundingRequired: 'fundingRequired',
    description: 'description',
    website: 'website',
    location: 'location',
    score: 'score',
    certified: 'certified',
    certificationDate: 'certificationDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SMEScalarFieldEnum = (typeof SMEScalarFieldEnum)[keyof typeof SMEScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    type: 'type',
    kycStatus: 'kycStatus',
    preferences: 'preferences',
    portfolio: 'portfolio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const AdvisorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    specialization: 'specialization',
    certificationList: 'certificationList',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdvisorScalarFieldEnum = (typeof AdvisorScalarFieldEnum)[keyof typeof AdvisorScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    smeId: 'smeId',
    title: 'title',
    description: 'description',
    amount: 'amount',
    equity: 'equity',
    status: 'status',
    successFee: 'successFee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const DealInvestorScalarFieldEnum: {
    id: 'id',
    dealId: 'dealId',
    investorId: 'investorId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealInvestorScalarFieldEnum = (typeof DealInvestorScalarFieldEnum)[keyof typeof DealInvestorScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    type: 'type',
    url: 'url',
    size: 'size',
    mimeType: 'mimeType',
    smeId: 'smeId',
    dealId: 'dealId',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    smeId: 'smeId',
    advisorId: 'advisorId',
    status: 'status',
    score: 'score',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    status: 'status',
    data: 'data',
    smeId: 'smeId',
    investorId: 'investorId',
    advisorId: 'advisorId',
    dealId: 'dealId',
    didWorkflowId: 'didWorkflowId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'SMEStage'
   */
  export type EnumSMEStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStage'>
    


  /**
   * Reference to a field of type 'SMEStage[]'
   */
  export type ListEnumSMEStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStage[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SMEStatus'
   */
  export type EnumSMEStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStatus'>
    


  /**
   * Reference to a field of type 'SMEStatus[]'
   */
  export type ListEnumSMEStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SMEStatus[]'>
    


  /**
   * Reference to a field of type 'InvestorType'
   */
  export type EnumInvestorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestorType'>
    


  /**
   * Reference to a field of type 'InvestorType[]'
   */
  export type ListEnumInvestorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestorType[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'AdvisorStatus'
   */
  export type EnumAdvisorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvisorStatus'>
    


  /**
   * Reference to a field of type 'AdvisorStatus[]'
   */
  export type ListEnumAdvisorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvisorStatus[]'>
    


  /**
   * Reference to a field of type 'DealStatus'
   */
  export type EnumDealStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealStatus'>
    


  /**
   * Reference to a field of type 'DealStatus[]'
   */
  export type ListEnumDealStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealStatus[]'>
    


  /**
   * Reference to a field of type 'InvestmentStatus'
   */
  export type EnumInvestmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestmentStatus'>
    


  /**
   * Reference to a field of type 'InvestmentStatus[]'
   */
  export type ListEnumInvestmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvestmentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CertificationStatus'
   */
  export type EnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus'>
    


  /**
   * Reference to a field of type 'CertificationStatus[]'
   */
  export type ListEnumCertificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificationStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowType'
   */
  export type EnumWorkflowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowType'>
    


  /**
   * Reference to a field of type 'WorkflowType[]'
   */
  export type ListEnumWorkflowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowType[]'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    smes?: SMEListRelationFilter
    investors?: InvestorListRelationFilter
    advisors?: AdvisorListRelationFilter
    deals?: DealListRelationFilter
    workflows?: WorkflowListRelationFilter
    documents?: DocumentListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    smes?: SMEOrderByRelationAggregateInput
    investors?: InvestorOrderByRelationAggregateInput
    advisors?: AdvisorOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    smes?: SMEListRelationFilter
    investors?: InvestorListRelationFilter
    advisors?: AdvisorListRelationFilter
    deals?: DealListRelationFilter
    workflows?: WorkflowListRelationFilter
    documents?: DocumentListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    settings?: JsonWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
  }, "id" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageWithAggregatesFilter<"User"> | $Enums.Language
    did?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SMEWhereInput = {
    AND?: SMEWhereInput | SMEWhereInput[]
    OR?: SMEWhereInput[]
    NOT?: SMEWhereInput | SMEWhereInput[]
    id?: StringFilter<"SME"> | string
    tenantId?: StringFilter<"SME"> | string
    userId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: DocumentListRelationFilter
    deals?: DealListRelationFilter
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
  }

  export type SMEOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    certified?: SortOrder
    certificationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
  }

  export type SMEWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SMEWhereInput | SMEWhereInput[]
    OR?: SMEWhereInput[]
    NOT?: SMEWhereInput | SMEWhereInput[]
    tenantId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    documents?: DocumentListRelationFilter
    deals?: DealListRelationFilter
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
  }, "id" | "userId">

  export type SMEOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    certified?: SortOrder
    certificationDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SMECountOrderByAggregateInput
    _avg?: SMEAvgOrderByAggregateInput
    _max?: SMEMaxOrderByAggregateInput
    _min?: SMEMinOrderByAggregateInput
    _sum?: SMESumOrderByAggregateInput
  }

  export type SMEScalarWhereWithAggregatesInput = {
    AND?: SMEScalarWhereWithAggregatesInput | SMEScalarWhereWithAggregatesInput[]
    OR?: SMEScalarWhereWithAggregatesInput[]
    NOT?: SMEScalarWhereWithAggregatesInput | SMEScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SME"> | string
    tenantId?: StringWithAggregatesFilter<"SME"> | string
    userId?: StringWithAggregatesFilter<"SME"> | string
    name?: StringWithAggregatesFilter<"SME"> | string
    sector?: StringWithAggregatesFilter<"SME"> | string
    stage?: EnumSMEStageWithAggregatesFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatWithAggregatesFilter<"SME"> | number
    description?: StringNullableWithAggregatesFilter<"SME"> | string | null
    website?: StringNullableWithAggregatesFilter<"SME"> | string | null
    location?: StringNullableWithAggregatesFilter<"SME"> | string | null
    score?: FloatNullableWithAggregatesFilter<"SME"> | number | null
    certified?: BoolWithAggregatesFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableWithAggregatesFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusWithAggregatesFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeWithAggregatesFilter<"SME"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SME"> | Date | string
  }

  export type InvestorWhereInput = {
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    id?: StringFilter<"Investor"> | string
    tenantId?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestments?: DealInvestorListRelationFilter
    workflows?: WorkflowListRelationFilter
  }

  export type InvestorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    dealInvestments?: DealInvestorOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
  }

  export type InvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    tenantId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    dealInvestments?: DealInvestorListRelationFilter
    workflows?: WorkflowListRelationFilter
  }, "id" | "userId">

  export type InvestorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorCountOrderByAggregateInput
    _max?: InvestorMaxOrderByAggregateInput
    _min?: InvestorMinOrderByAggregateInput
  }

  export type InvestorScalarWhereWithAggregatesInput = {
    AND?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    OR?: InvestorScalarWhereWithAggregatesInput[]
    NOT?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investor"> | string
    tenantId?: StringWithAggregatesFilter<"Investor"> | string
    userId?: StringWithAggregatesFilter<"Investor"> | string
    name?: StringWithAggregatesFilter<"Investor"> | string
    type?: EnumInvestorTypeWithAggregatesFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusWithAggregatesFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonWithAggregatesFilter<"Investor">
    portfolio?: JsonWithAggregatesFilter<"Investor">
    createdAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
  }

  export type AdvisorWhereInput = {
    AND?: AdvisorWhereInput | AdvisorWhereInput[]
    OR?: AdvisorWhereInput[]
    NOT?: AdvisorWhereInput | AdvisorWhereInput[]
    id?: StringFilter<"Advisor"> | string
    tenantId?: StringFilter<"Advisor"> | string
    userId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
  }

  export type AdvisorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    certifications?: CertificationOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
  }

  export type AdvisorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdvisorWhereInput | AdvisorWhereInput[]
    OR?: AdvisorWhereInput[]
    NOT?: AdvisorWhereInput | AdvisorWhereInput[]
    tenantId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    certifications?: CertificationListRelationFilter
    workflows?: WorkflowListRelationFilter
  }, "id" | "userId">

  export type AdvisorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdvisorCountOrderByAggregateInput
    _max?: AdvisorMaxOrderByAggregateInput
    _min?: AdvisorMinOrderByAggregateInput
  }

  export type AdvisorScalarWhereWithAggregatesInput = {
    AND?: AdvisorScalarWhereWithAggregatesInput | AdvisorScalarWhereWithAggregatesInput[]
    OR?: AdvisorScalarWhereWithAggregatesInput[]
    NOT?: AdvisorScalarWhereWithAggregatesInput | AdvisorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Advisor"> | string
    tenantId?: StringWithAggregatesFilter<"Advisor"> | string
    userId?: StringWithAggregatesFilter<"Advisor"> | string
    name?: StringWithAggregatesFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusWithAggregatesFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeWithAggregatesFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Advisor"> | Date | string
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investors?: DealInvestorListRelationFilter
    documents?: DocumentListRelationFilter
    workflows?: WorkflowListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    equity?: SortOrderInput | SortOrder
    status?: SortOrder
    successFee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investors?: DealInvestorOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    investors?: DealInvestorListRelationFilter
    documents?: DocumentListRelationFilter
    workflows?: WorkflowListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    equity?: SortOrderInput | SortOrder
    status?: SortOrder
    successFee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    tenantId?: StringWithAggregatesFilter<"Deal"> | string
    smeId?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    description?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    amount?: FloatWithAggregatesFilter<"Deal"> | number
    equity?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    status?: EnumDealStatusWithAggregatesFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
  }

  export type DealInvestorWhereInput = {
    AND?: DealInvestorWhereInput | DealInvestorWhereInput[]
    OR?: DealInvestorWhereInput[]
    NOT?: DealInvestorWhereInput | DealInvestorWhereInput[]
    id?: StringFilter<"DealInvestor"> | string
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
    deal?: XOR<DealRelationFilter, DealWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }

  export type DealInvestorOrderByWithRelationInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deal?: DealOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
  }

  export type DealInvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dealId_investorId?: DealInvestorDealIdInvestorIdCompoundUniqueInput
    AND?: DealInvestorWhereInput | DealInvestorWhereInput[]
    OR?: DealInvestorWhereInput[]
    NOT?: DealInvestorWhereInput | DealInvestorWhereInput[]
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
    deal?: XOR<DealRelationFilter, DealWhereInput>
    investor?: XOR<InvestorRelationFilter, InvestorWhereInput>
  }, "id" | "dealId_investorId">

  export type DealInvestorOrderByWithAggregationInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealInvestorCountOrderByAggregateInput
    _avg?: DealInvestorAvgOrderByAggregateInput
    _max?: DealInvestorMaxOrderByAggregateInput
    _min?: DealInvestorMinOrderByAggregateInput
    _sum?: DealInvestorSumOrderByAggregateInput
  }

  export type DealInvestorScalarWhereWithAggregatesInput = {
    AND?: DealInvestorScalarWhereWithAggregatesInput | DealInvestorScalarWhereWithAggregatesInput[]
    OR?: DealInvestorScalarWhereWithAggregatesInput[]
    NOT?: DealInvestorScalarWhereWithAggregatesInput | DealInvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DealInvestor"> | string
    dealId?: StringWithAggregatesFilter<"DealInvestor"> | string
    investorId?: StringWithAggregatesFilter<"DealInvestor"> | string
    amount?: FloatWithAggregatesFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusWithAggregatesFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeWithAggregatesFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DealInvestor"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    tenantId?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    url?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    smeId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedBy?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sme?: SMEOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    sme?: XOR<SMERelationFilter, SMEWhereInput>
    advisor?: XOR<AdvisorRelationFilter, AdvisorWhereInput>
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _avg?: CertificationAvgOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
    _sum?: CertificationSumOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    smeId?: StringWithAggregatesFilter<"Certification"> | string
    advisorId?: StringWithAggregatesFilter<"Certification"> | string
    status?: EnumCertificationStatusWithAggregatesFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableWithAggregatesFilter<"Certification"> | number | null
    comments?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrderInput | SortOrder
    investorId?: SortOrderInput | SortOrder
    advisorId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    didWorkflowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sme?: SMEOrderByWithRelationInput
    investor?: InvestorOrderByWithRelationInput
    advisor?: AdvisorOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    sme?: XOR<SMENullableRelationFilter, SMEWhereInput> | null
    investor?: XOR<InvestorNullableRelationFilter, InvestorWhereInput> | null
    advisor?: XOR<AdvisorNullableRelationFilter, AdvisorWhereInput> | null
    deal?: XOR<DealNullableRelationFilter, DealWhereInput> | null
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrderInput | SortOrder
    investorId?: SortOrderInput | SortOrder
    advisorId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    didWorkflowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    tenantId?: StringWithAggregatesFilter<"Workflow"> | string
    type?: EnumWorkflowTypeWithAggregatesFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusWithAggregatesFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonWithAggregatesFilter<"Workflow">
    smeId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    investorId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    advisorId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMECreateInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMEUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type SMECreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMEUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMEUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorCreateInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
  }

  export type DealInvestorUncheckedCreateInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
  }

  export type DealInvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyInput = {
    id?: string
    dealId: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    sme?: SMECreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutCertificationsInput
    advisor: AdvisorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    smeId: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutCertificationsNestedInput
    advisor?: AdvisorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyInput = {
    id?: string
    smeId: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateManyInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SMEListRelationFilter = {
    every?: SMEWhereInput
    some?: SMEWhereInput
    none?: SMEWhereInput
  }

  export type InvestorListRelationFilter = {
    every?: InvestorWhereInput
    some?: InvestorWhereInput
    none?: InvestorWhereInput
  }

  export type AdvisorListRelationFilter = {
    every?: AdvisorWhereInput
    some?: AdvisorWhereInput
    none?: AdvisorWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMEOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvisorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type EnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SMENullableRelationFilter = {
    is?: SMEWhereInput | null
    isNot?: SMEWhereInput | null
  }

  export type InvestorNullableRelationFilter = {
    is?: InvestorWhereInput | null
    isNot?: InvestorWhereInput | null
  }

  export type AdvisorNullableRelationFilter = {
    is?: AdvisorWhereInput | null
    isNot?: AdvisorWhereInput | null
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    language?: SortOrder
    did?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type EnumSMEStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageFilter<$PrismaModel> | $Enums.SMEStage
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSMEStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusFilter<$PrismaModel> | $Enums.SMEStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMECountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMEAvgOrderByAggregateInput = {
    fundingRequired?: SortOrder
    score?: SortOrder
  }

  export type SMEMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMEMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    fundingRequired?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    score?: SortOrder
    certified?: SortOrder
    certificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMESumOrderByAggregateInput = {
    fundingRequired?: SortOrder
    score?: SortOrder
  }

  export type EnumSMEStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageWithAggregatesFilter<$PrismaModel> | $Enums.SMEStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStageFilter<$PrismaModel>
    _max?: NestedEnumSMEStageFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSMEStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel> | $Enums.SMEStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStatusFilter<$PrismaModel>
    _max?: NestedEnumSMEStatusFilter<$PrismaModel>
  }

  export type EnumInvestorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeFilter<$PrismaModel> | $Enums.InvestorType
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type DealInvestorListRelationFilter = {
    every?: DealInvestorWhereInput
    some?: DealInvestorWhereInput
    none?: DealInvestorWhereInput
  }

  export type DealInvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    preferences?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    kycStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvestorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvestorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestorTypeFilter<$PrismaModel>
    _max?: NestedEnumInvestorTypeFilter<$PrismaModel>
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumAdvisorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusFilter<$PrismaModel> | $Enums.AdvisorStatus
  }

  export type AdvisorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    certificationList?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvisorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdvisorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvisorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvisorStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvisorStatusFilter<$PrismaModel>
  }

  export type EnumDealStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusFilter<$PrismaModel> | $Enums.DealStatus
  }

  export type SMERelationFilter = {
    is?: SMEWhereInput
    isNot?: SMEWhereInput
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    amount?: SortOrder
    equity?: SortOrder
    successFee?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    smeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    equity?: SortOrder
    status?: SortOrder
    successFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    amount?: SortOrder
    equity?: SortOrder
    successFee?: SortOrder
  }

  export type EnumDealStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealStatusFilter<$PrismaModel>
    _max?: NestedEnumDealStatusFilter<$PrismaModel>
  }

  export type EnumInvestmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusFilter<$PrismaModel> | $Enums.InvestmentStatus
  }

  export type DealRelationFilter = {
    is?: DealWhereInput
    isNot?: DealWhereInput
  }

  export type InvestorRelationFilter = {
    is?: InvestorWhereInput
    isNot?: InvestorWhereInput
  }

  export type DealInvestorDealIdInvestorIdCompoundUniqueInput = {
    dealId: string
    investorId: string
  }

  export type DealInvestorCountOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DealInvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorMinOrderByAggregateInput = {
    id?: SortOrder
    dealId?: SortOrder
    investorId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealInvestorSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvestmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestmentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DealNullableRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    smeId?: SortOrder
    dealId?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type AdvisorRelationFilter = {
    is?: AdvisorWhereInput
    isNot?: AdvisorWhereInput
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    smeId?: SortOrder
    advisorId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type EnumWorkflowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeFilter<$PrismaModel> | $Enums.WorkflowType
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    smeId?: SortOrder
    investorId?: SortOrder
    advisorId?: SortOrder
    dealId?: SortOrder
    didWorkflowId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkflowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTypeFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SMECreateNestedManyWithoutTenantInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
  }

  export type InvestorCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type AdvisorCreateNestedManyWithoutTenantInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SMEUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
  }

  export type InvestorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type AdvisorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SMEUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    upsert?: SMEUpsertWithWhereUniqueWithoutTenantInput | SMEUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    set?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    disconnect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    delete?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    update?: SMEUpdateWithWhereUniqueWithoutTenantInput | SMEUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SMEUpdateManyWithWhereWithoutTenantInput | SMEUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SMEScalarWhereInput | SMEScalarWhereInput[]
  }

  export type InvestorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutTenantInput | InvestorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutTenantInput | InvestorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutTenantInput | InvestorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type AdvisorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    upsert?: AdvisorUpsertWithWhereUniqueWithoutTenantInput | AdvisorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    set?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    disconnect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    delete?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    update?: AdvisorUpdateWithWhereUniqueWithoutTenantInput | AdvisorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AdvisorUpdateManyWithWhereWithoutTenantInput | AdvisorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
  }

  export type DealUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutTenantInput | WorkflowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutTenantInput | WorkflowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutTenantInput | WorkflowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SMEUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput> | SMECreateWithoutTenantInput[] | SMEUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SMECreateOrConnectWithoutTenantInput | SMECreateOrConnectWithoutTenantInput[]
    upsert?: SMEUpsertWithWhereUniqueWithoutTenantInput | SMEUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SMECreateManyTenantInputEnvelope
    set?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    disconnect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    delete?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    connect?: SMEWhereUniqueInput | SMEWhereUniqueInput[]
    update?: SMEUpdateWithWhereUniqueWithoutTenantInput | SMEUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SMEUpdateManyWithWhereWithoutTenantInput | SMEUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SMEScalarWhereInput | SMEScalarWhereInput[]
  }

  export type InvestorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput> | InvestorCreateWithoutTenantInput[] | InvestorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutTenantInput | InvestorCreateOrConnectWithoutTenantInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutTenantInput | InvestorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvestorCreateManyTenantInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutTenantInput | InvestorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutTenantInput | InvestorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type AdvisorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput> | AdvisorCreateWithoutTenantInput[] | AdvisorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AdvisorCreateOrConnectWithoutTenantInput | AdvisorCreateOrConnectWithoutTenantInput[]
    upsert?: AdvisorUpsertWithWhereUniqueWithoutTenantInput | AdvisorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AdvisorCreateManyTenantInputEnvelope
    set?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    disconnect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    delete?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    connect?: AdvisorWhereUniqueInput | AdvisorWhereUniqueInput[]
    update?: AdvisorUpdateWithWhereUniqueWithoutTenantInput | AdvisorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AdvisorUpdateManyWithWhereWithoutTenantInput | AdvisorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput> | WorkflowCreateWithoutTenantInput[] | WorkflowUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutTenantInput | WorkflowCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutTenantInput | WorkflowUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowCreateManyTenantInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutTenantInput | WorkflowUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutTenantInput | WorkflowUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutUserInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutUserInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    connect?: AdvisorWhereUniqueInput
  }

  export type SMEUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    connect?: AdvisorWhereUniqueInput
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumLanguageFieldUpdateOperationsInput = {
    set?: $Enums.Language
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type SMEUpdateOneWithoutUserNestedInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    upsert?: SMEUpsertWithoutUserInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutUserInput, SMEUpdateWithoutUserInput>, SMEUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    upsert?: AdvisorUpsertWithoutUserInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutUserInput, AdvisorUpdateWithoutUserInput>, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type SMEUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    connectOrCreate?: SMECreateOrConnectWithoutUserInput
    upsert?: SMEUpsertWithoutUserInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutUserInput, SMEUpdateWithoutUserInput>, SMEUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput
    upsert?: InvestorUpsertWithoutUserInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutUserInput, InvestorUpdateWithoutUserInput>, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutUserInput
    upsert?: AdvisorUpsertWithoutUserInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutUserInput, AdvisorUpdateWithoutUserInput>, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type TenantCreateNestedOneWithoutSmesInput = {
    create?: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSmeInput = {
    create?: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmeInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutSmeInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutSmeInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutSmeInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutSmeInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutSmeInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type EnumSMEStageFieldUpdateOperationsInput = {
    set?: $Enums.SMEStage
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSMEStatusFieldUpdateOperationsInput = {
    set?: $Enums.SMEStatus
  }

  export type TenantUpdateOneRequiredWithoutSmesNestedInput = {
    create?: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmesInput
    upsert?: TenantUpsertWithoutSmesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSmesInput, TenantUpdateWithoutSmesInput>, TenantUncheckedUpdateWithoutSmesInput>
  }

  export type UserUpdateOneRequiredWithoutSmeNestedInput = {
    create?: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmeInput
    upsert?: UserUpsertWithoutSmeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmeInput, UserUpdateWithoutSmeInput>, UserUncheckedUpdateWithoutSmeInput>
  }

  export type DocumentUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSmeInput | DocumentUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSmeInput | DocumentUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSmeInput | DocumentUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutSmeInput | DealUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutSmeInput | DealUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DealUpdateManyWithWhereWithoutSmeInput | DealUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutSmeNestedInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutSmeInput | CertificationUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutSmeInput | CertificationUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutSmeInput | CertificationUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutSmeNestedInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutSmeInput | WorkflowUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutSmeInput | WorkflowUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutSmeInput | WorkflowUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput> | DocumentCreateWithoutSmeInput[] | DocumentUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSmeInput | DocumentCreateOrConnectWithoutSmeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSmeInput | DocumentUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DocumentCreateManySmeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSmeInput | DocumentUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSmeInput | DocumentUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput> | DealCreateWithoutSmeInput[] | DealUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: DealCreateOrConnectWithoutSmeInput | DealCreateOrConnectWithoutSmeInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutSmeInput | DealUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: DealCreateManySmeInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutSmeInput | DealUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: DealUpdateManyWithWhereWithoutSmeInput | DealUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput> | CertificationCreateWithoutSmeInput[] | CertificationUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutSmeInput | CertificationCreateOrConnectWithoutSmeInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutSmeInput | CertificationUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: CertificationCreateManySmeInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutSmeInput | CertificationUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutSmeInput | CertificationUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutSmeNestedInput = {
    create?: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput> | WorkflowCreateWithoutSmeInput[] | WorkflowUncheckedCreateWithoutSmeInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutSmeInput | WorkflowCreateOrConnectWithoutSmeInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutSmeInput | WorkflowUpsertWithWhereUniqueWithoutSmeInput[]
    createMany?: WorkflowCreateManySmeInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutSmeInput | WorkflowUpdateWithWhereUniqueWithoutSmeInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutSmeInput | WorkflowUpdateManyWithWhereWithoutSmeInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvestorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvestorInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    connect?: UserWhereUniqueInput
  }

  export type DealInvestorCreateNestedManyWithoutInvestorInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutInvestorInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DealInvestorUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type EnumInvestorTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvestorType
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type TenantUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvestorsInput
    upsert?: TenantUpsertWithoutInvestorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvestorsInput, TenantUpdateWithoutInvestorsInput>, TenantUncheckedUpdateWithoutInvestorsInput>
  }

  export type UserUpdateOneRequiredWithoutInvestorNestedInput = {
    create?: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorInput
    upsert?: UserUpsertWithoutInvestorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorInput, UserUpdateWithoutInvestorInput>, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type DealInvestorUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutInvestorInput | DealInvestorUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutInvestorInput | DealInvestorUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutInvestorInput | DealInvestorUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutInvestorInput | WorkflowUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutInvestorInput | WorkflowUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutInvestorInput | WorkflowUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput> | DealInvestorCreateWithoutInvestorInput[] | DealInvestorUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutInvestorInput | DealInvestorCreateOrConnectWithoutInvestorInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutInvestorInput | DealInvestorUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: DealInvestorCreateManyInvestorInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutInvestorInput | DealInvestorUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutInvestorInput | DealInvestorUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput> | WorkflowCreateWithoutInvestorInput[] | WorkflowUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutInvestorInput | WorkflowCreateOrConnectWithoutInvestorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutInvestorInput | WorkflowUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: WorkflowCreateManyInvestorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutInvestorInput | WorkflowUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutInvestorInput | WorkflowUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type AdvisorCreatespecializationInput = {
    set: string[]
  }

  export type AdvisorCreatecertificationListInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutAdvisorsInput = {
    create?: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAdvisorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdvisorInput = {
    create?: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvisorInput
    connect?: UserWhereUniqueInput
  }

  export type CertificationCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutAdvisorInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type AdvisorUpdatespecializationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdvisorUpdatecertificationListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAdvisorStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdvisorStatus
  }

  export type TenantUpdateOneRequiredWithoutAdvisorsNestedInput = {
    create?: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAdvisorsInput
    upsert?: TenantUpsertWithoutAdvisorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAdvisorsInput, TenantUpdateWithoutAdvisorsInput>, TenantUncheckedUpdateWithoutAdvisorsInput>
  }

  export type UserUpdateOneRequiredWithoutAdvisorNestedInput = {
    create?: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvisorInput
    upsert?: UserUpsertWithoutAdvisorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdvisorInput, UserUpdateWithoutAdvisorInput>, UserUncheckedUpdateWithoutAdvisorInput>
  }

  export type CertificationUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutAdvisorInput | CertificationUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutAdvisorInput | CertificationUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutAdvisorInput | CertificationUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAdvisorInput | WorkflowUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAdvisorInput | WorkflowUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAdvisorInput | WorkflowUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput> | CertificationCreateWithoutAdvisorInput[] | CertificationUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutAdvisorInput | CertificationCreateOrConnectWithoutAdvisorInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutAdvisorInput | CertificationUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: CertificationCreateManyAdvisorInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutAdvisorInput | CertificationUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutAdvisorInput | CertificationUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput = {
    create?: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput> | WorkflowCreateWithoutAdvisorInput[] | WorkflowUncheckedCreateWithoutAdvisorInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAdvisorInput | WorkflowCreateOrConnectWithoutAdvisorInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAdvisorInput | WorkflowUpsertWithWhereUniqueWithoutAdvisorInput[]
    createMany?: WorkflowCreateManyAdvisorInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAdvisorInput | WorkflowUpdateWithWhereUniqueWithoutAdvisorInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAdvisorInput | WorkflowUpdateManyWithWhereWithoutAdvisorInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDealsInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutDealsInput = {
    create?: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDealsInput
    connect?: SMEWhereUniqueInput
  }

  export type DealInvestorCreateNestedManyWithoutDealInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutDealInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type DealInvestorUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type EnumDealStatusFieldUpdateOperationsInput = {
    set?: $Enums.DealStatus
  }

  export type TenantUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    upsert?: TenantUpsertWithoutDealsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDealsInput, TenantUpdateWithoutDealsInput>, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type SMEUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDealsInput
    upsert?: SMEUpsertWithoutDealsInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDealsInput, SMEUpdateWithoutDealsInput>, SMEUncheckedUpdateWithoutDealsInput>
  }

  export type DealInvestorUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutDealInput | DealInvestorUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutDealInput | DealInvestorUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutDealInput | DealInvestorUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutDealNestedInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutDealInput | WorkflowUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutDealInput | WorkflowUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutDealInput | WorkflowUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DealInvestorUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput> | DealInvestorCreateWithoutDealInput[] | DealInvestorUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DealInvestorCreateOrConnectWithoutDealInput | DealInvestorCreateOrConnectWithoutDealInput[]
    upsert?: DealInvestorUpsertWithWhereUniqueWithoutDealInput | DealInvestorUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DealInvestorCreateManyDealInputEnvelope
    set?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    disconnect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    delete?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    connect?: DealInvestorWhereUniqueInput | DealInvestorWhereUniqueInput[]
    update?: DealInvestorUpdateWithWhereUniqueWithoutDealInput | DealInvestorUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DealInvestorUpdateManyWithWhereWithoutDealInput | DealInvestorUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput> | WorkflowCreateWithoutDealInput[] | WorkflowUncheckedCreateWithoutDealInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutDealInput | WorkflowCreateOrConnectWithoutDealInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutDealInput | WorkflowUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: WorkflowCreateManyDealInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutDealInput | WorkflowUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutDealInput | WorkflowUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type DealCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInvestorsInput
    connect?: DealWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutDealInvestmentsInput = {
    create?: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutDealInvestmentsInput
    connect?: InvestorWhereUniqueInput
  }

  export type EnumInvestmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvestmentStatus
  }

  export type DealUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInvestorsInput
    upsert?: DealUpsertWithoutInvestorsInput
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutInvestorsInput, DealUpdateWithoutInvestorsInput>, DealUncheckedUpdateWithoutInvestorsInput>
  }

  export type InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput = {
    create?: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutDealInvestmentsInput
    upsert?: InvestorUpsertWithoutDealInvestmentsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutDealInvestmentsInput, InvestorUpdateWithoutDealInvestmentsInput>, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
  }

  export type TenantCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutDocumentsInput = {
    create?: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDocumentsInput
    connect?: SMEWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    connect?: DealWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    upsert?: TenantUpsertWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentsInput, TenantUpdateWithoutDocumentsInput>, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMEUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SMECreateOrConnectWithoutDocumentsInput
    upsert?: SMEUpsertWithoutDocumentsInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutDocumentsInput, SMEUpdateWithoutDocumentsInput>, SMEUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    upsert?: DealUpsertWithoutDocumentsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutDocumentsInput, DealUpdateWithoutDocumentsInput>, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMECreateNestedOneWithoutCertificationsInput = {
    create?: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: SMECreateOrConnectWithoutCertificationsInput
    connect?: SMEWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutCertificationsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type EnumCertificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.CertificationStatus
  }

  export type SMEUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: SMECreateOrConnectWithoutCertificationsInput
    upsert?: SMEUpsertWithoutCertificationsInput
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutCertificationsInput, SMEUpdateWithoutCertificationsInput>, SMEUncheckedUpdateWithoutCertificationsInput>
  }

  export type AdvisorUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutCertificationsInput
    upsert?: AdvisorUpsertWithoutCertificationsInput
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutCertificationsInput, AdvisorUpdateWithoutCertificationsInput>, AdvisorUncheckedUpdateWithoutCertificationsInput>
  }

  export type TenantCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowsInput
    connect?: TenantWhereUniqueInput
  }

  export type SMECreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: SMECreateOrConnectWithoutWorkflowsInput
    connect?: SMEWhereUniqueInput
  }

  export type InvestorCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutWorkflowsInput
    connect?: InvestorWhereUniqueInput
  }

  export type AdvisorCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutWorkflowsInput
    connect?: AdvisorWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: DealCreateOrConnectWithoutWorkflowsInput
    connect?: DealWhereUniqueInput
  }

  export type EnumWorkflowTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowType
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type TenantUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowsInput
    upsert?: TenantUpsertWithoutWorkflowsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWorkflowsInput, TenantUpdateWithoutWorkflowsInput>, TenantUncheckedUpdateWithoutWorkflowsInput>
  }

  export type SMEUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: SMECreateOrConnectWithoutWorkflowsInput
    upsert?: SMEUpsertWithoutWorkflowsInput
    disconnect?: SMEWhereInput | boolean
    delete?: SMEWhereInput | boolean
    connect?: SMEWhereUniqueInput
    update?: XOR<XOR<SMEUpdateToOneWithWhereWithoutWorkflowsInput, SMEUpdateWithoutWorkflowsInput>, SMEUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutWorkflowsInput
    upsert?: InvestorUpsertWithoutWorkflowsInput
    disconnect?: InvestorWhereInput | boolean
    delete?: InvestorWhereInput | boolean
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutWorkflowsInput, InvestorUpdateWithoutWorkflowsInput>, InvestorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AdvisorUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AdvisorCreateOrConnectWithoutWorkflowsInput
    upsert?: AdvisorUpsertWithoutWorkflowsInput
    disconnect?: AdvisorWhereInput | boolean
    delete?: AdvisorWhereInput | boolean
    connect?: AdvisorWhereUniqueInput
    update?: XOR<XOR<AdvisorUpdateToOneWithWhereWithoutWorkflowsInput, AdvisorUpdateWithoutWorkflowsInput>, AdvisorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type DealUpdateOneWithoutWorkflowsNestedInput = {
    create?: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: DealCreateOrConnectWithoutWorkflowsInput
    upsert?: DealUpsertWithoutWorkflowsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutWorkflowsInput, DealUpdateWithoutWorkflowsInput>, DealUncheckedUpdateWithoutWorkflowsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type NestedEnumSMEStageFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageFilter<$PrismaModel> | $Enums.SMEStage
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSMEStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusFilter<$PrismaModel> | $Enums.SMEStatus
  }

  export type NestedEnumSMEStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStage | EnumSMEStageFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStage[] | ListEnumSMEStageFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStageWithAggregatesFilter<$PrismaModel> | $Enums.SMEStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStageFilter<$PrismaModel>
    _max?: NestedEnumSMEStageFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SMEStatus | EnumSMEStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SMEStatus[] | ListEnumSMEStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSMEStatusWithAggregatesFilter<$PrismaModel> | $Enums.SMEStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSMEStatusFilter<$PrismaModel>
    _max?: NestedEnumSMEStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvestorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeFilter<$PrismaModel> | $Enums.InvestorType
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestorType | EnumInvestorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestorType[] | ListEnumInvestorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestorTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvestorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestorTypeFilter<$PrismaModel>
    _max?: NestedEnumInvestorTypeFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdvisorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusFilter<$PrismaModel> | $Enums.AdvisorStatus
  }

  export type NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvisorStatus | EnumAdvisorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvisorStatus[] | ListEnumAdvisorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvisorStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvisorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvisorStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvisorStatusFilter<$PrismaModel>
  }

  export type NestedEnumDealStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusFilter<$PrismaModel> | $Enums.DealStatus
  }

  export type NestedEnumDealStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealStatus | EnumDealStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealStatus[] | ListEnumDealStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealStatusFilter<$PrismaModel>
    _max?: NestedEnumDealStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvestmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusFilter<$PrismaModel> | $Enums.InvestmentStatus
  }

  export type NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvestmentStatus | EnumInvestmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvestmentStatus[] | ListEnumInvestmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvestmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvestmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvestmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInvestmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCertificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusFilter<$PrismaModel> | $Enums.CertificationStatus
  }

  export type NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificationStatus | EnumCertificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificationStatus[] | ListEnumCertificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CertificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificationStatusFilter<$PrismaModel>
    _max?: NestedEnumCertificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeFilter<$PrismaModel> | $Enums.WorkflowType
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowType | EnumWorkflowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowType[] | ListEnumWorkflowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SMECreateWithoutTenantInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutTenantInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput>
  }

  export type SMECreateManyTenantInputEnvelope = {
    data: SMECreateManyTenantInput | SMECreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvestorCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput>
  }

  export type InvestorCreateManyTenantInputEnvelope = {
    data: InvestorCreateManyTenantInput | InvestorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AdvisorCreateWithoutTenantInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput>
  }

  export type AdvisorCreateManyTenantInputEnvelope = {
    data: AdvisorCreateManyTenantInput | AdvisorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutTenantInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTenantInput = {
    id?: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTenantInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealCreateManyTenantInputEnvelope = {
    data: DealCreateManyTenantInput | DealCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowCreateManyTenantInputEnvelope = {
    data: WorkflowCreateManyTenantInput | WorkflowCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMECreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentCreateManyTenantInputEnvelope = {
    data: DocumentCreateManyTenantInput | DocumentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    did?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SMEUpsertWithWhereUniqueWithoutTenantInput = {
    where: SMEWhereUniqueInput
    update: XOR<SMEUpdateWithoutTenantInput, SMEUncheckedUpdateWithoutTenantInput>
    create: XOR<SMECreateWithoutTenantInput, SMEUncheckedCreateWithoutTenantInput>
  }

  export type SMEUpdateWithWhereUniqueWithoutTenantInput = {
    where: SMEWhereUniqueInput
    data: XOR<SMEUpdateWithoutTenantInput, SMEUncheckedUpdateWithoutTenantInput>
  }

  export type SMEUpdateManyWithWhereWithoutTenantInput = {
    where: SMEScalarWhereInput
    data: XOR<SMEUpdateManyMutationInput, SMEUncheckedUpdateManyWithoutTenantInput>
  }

  export type SMEScalarWhereInput = {
    AND?: SMEScalarWhereInput | SMEScalarWhereInput[]
    OR?: SMEScalarWhereInput[]
    NOT?: SMEScalarWhereInput | SMEScalarWhereInput[]
    id?: StringFilter<"SME"> | string
    tenantId?: StringFilter<"SME"> | string
    userId?: StringFilter<"SME"> | string
    name?: StringFilter<"SME"> | string
    sector?: StringFilter<"SME"> | string
    stage?: EnumSMEStageFilter<"SME"> | $Enums.SMEStage
    fundingRequired?: FloatFilter<"SME"> | number
    description?: StringNullableFilter<"SME"> | string | null
    website?: StringNullableFilter<"SME"> | string | null
    location?: StringNullableFilter<"SME"> | string | null
    score?: FloatNullableFilter<"SME"> | number | null
    certified?: BoolFilter<"SME"> | boolean
    certificationDate?: DateTimeNullableFilter<"SME"> | Date | string | null
    status?: EnumSMEStatusFilter<"SME"> | $Enums.SMEStatus
    createdAt?: DateTimeFilter<"SME"> | Date | string
    updatedAt?: DateTimeFilter<"SME"> | Date | string
  }

  export type InvestorUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    update: XOR<InvestorUpdateWithoutTenantInput, InvestorUncheckedUpdateWithoutTenantInput>
    create: XOR<InvestorCreateWithoutTenantInput, InvestorUncheckedCreateWithoutTenantInput>
  }

  export type InvestorUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvestorWhereUniqueInput
    data: XOR<InvestorUpdateWithoutTenantInput, InvestorUncheckedUpdateWithoutTenantInput>
  }

  export type InvestorUpdateManyWithWhereWithoutTenantInput = {
    where: InvestorScalarWhereInput
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvestorScalarWhereInput = {
    AND?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    OR?: InvestorScalarWhereInput[]
    NOT?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    id?: StringFilter<"Investor"> | string
    tenantId?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: EnumInvestorTypeFilter<"Investor"> | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFilter<"Investor"> | $Enums.KYCStatus
    preferences?: JsonFilter<"Investor">
    portfolio?: JsonFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
  }

  export type AdvisorUpsertWithWhereUniqueWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    update: XOR<AdvisorUpdateWithoutTenantInput, AdvisorUncheckedUpdateWithoutTenantInput>
    create: XOR<AdvisorCreateWithoutTenantInput, AdvisorUncheckedCreateWithoutTenantInput>
  }

  export type AdvisorUpdateWithWhereUniqueWithoutTenantInput = {
    where: AdvisorWhereUniqueInput
    data: XOR<AdvisorUpdateWithoutTenantInput, AdvisorUncheckedUpdateWithoutTenantInput>
  }

  export type AdvisorUpdateManyWithWhereWithoutTenantInput = {
    where: AdvisorScalarWhereInput
    data: XOR<AdvisorUpdateManyMutationInput, AdvisorUncheckedUpdateManyWithoutTenantInput>
  }

  export type AdvisorScalarWhereInput = {
    AND?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
    OR?: AdvisorScalarWhereInput[]
    NOT?: AdvisorScalarWhereInput | AdvisorScalarWhereInput[]
    id?: StringFilter<"Advisor"> | string
    tenantId?: StringFilter<"Advisor"> | string
    userId?: StringFilter<"Advisor"> | string
    name?: StringFilter<"Advisor"> | string
    specialization?: StringNullableListFilter<"Advisor">
    certificationList?: StringNullableListFilter<"Advisor">
    status?: EnumAdvisorStatusFilter<"Advisor"> | $Enums.AdvisorStatus
    createdAt?: DateTimeFilter<"Advisor"> | Date | string
    updatedAt?: DateTimeFilter<"Advisor"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealUpdateWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
  }

  export type DealUpdateManyWithWhereWithoutTenantInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutTenantInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    smeId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    amount?: FloatFilter<"Deal"> | number
    equity?: FloatNullableFilter<"Deal"> | number | null
    status?: EnumDealStatusFilter<"Deal"> | $Enums.DealStatus
    successFee?: FloatNullableFilter<"Deal"> | number | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutTenantInput, WorkflowUncheckedUpdateWithoutTenantInput>
    create: XOR<WorkflowCreateWithoutTenantInput, WorkflowUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutTenantInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutTenantInput, WorkflowUncheckedUpdateWithoutTenantInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutTenantInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutTenantInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: StringFilter<"Workflow"> | string
    tenantId?: StringFilter<"Workflow"> | string
    type?: EnumWorkflowTypeFilter<"Workflow"> | $Enums.WorkflowType
    status?: EnumWorkflowStatusFilter<"Workflow"> | $Enums.WorkflowStatus
    data?: JsonFilter<"Workflow">
    smeId?: StringNullableFilter<"Workflow"> | string | null
    investorId?: StringNullableFilter<"Workflow"> | string | null
    advisorId?: StringNullableFilter<"Workflow"> | string | null
    dealId?: StringNullableFilter<"Workflow"> | string | null
    didWorkflowId?: StringNullableFilter<"Workflow"> | string | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    url?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    smeId?: StringNullableFilter<"Document"> | string | null
    dealId?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type SMECreateWithoutUserInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutUserInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
  }

  export type InvestorCreateWithoutUserInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutUserInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
  }

  export type AdvisorCreateWithoutUserInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutUserInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutUserInput = {
    update: XOR<SMEUpdateWithoutUserInput, SMEUncheckedUpdateWithoutUserInput>
    create: XOR<SMECreateWithoutUserInput, SMEUncheckedCreateWithoutUserInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutUserInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutUserInput, SMEUncheckedUpdateWithoutUserInput>
  }

  export type SMEUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutUserInput = {
    update: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type AdvisorUpsertWithoutUserInput = {
    update: XOR<AdvisorUpdateWithoutUserInput, AdvisorUncheckedUpdateWithoutUserInput>
    create: XOR<AdvisorCreateWithoutUserInput, AdvisorUncheckedCreateWithoutUserInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutUserInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutUserInput, AdvisorUncheckedUpdateWithoutUserInput>
  }

  export type AdvisorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type TenantCreateWithoutSmesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSmesInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSmesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
  }

  export type UserCreateWithoutSmeInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    investor?: InvestorCreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSmeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
  }

  export type DocumentCreateWithoutSmeInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput>
  }

  export type DocumentCreateManySmeInputEnvelope = {
    data: DocumentCreateManySmeInput | DocumentCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutSmeInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSmeInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput>
  }

  export type DealCreateManySmeInputEnvelope = {
    data: DealCreateManySmeInput | DealCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type CertificationCreateWithoutSmeInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    advisor: AdvisorCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutSmeInput = {
    id?: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput>
  }

  export type CertificationCreateManySmeInputEnvelope = {
    data: CertificationCreateManySmeInput | CertificationCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutSmeInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutSmeInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput>
  }

  export type WorkflowCreateManySmeInputEnvelope = {
    data: WorkflowCreateManySmeInput | WorkflowCreateManySmeInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSmesInput = {
    update: XOR<TenantUpdateWithoutSmesInput, TenantUncheckedUpdateWithoutSmesInput>
    create: XOR<TenantCreateWithoutSmesInput, TenantUncheckedCreateWithoutSmesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSmesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSmesInput, TenantUncheckedUpdateWithoutSmesInput>
  }

  export type TenantUpdateWithoutSmesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSmesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutSmeInput = {
    update: XOR<UserUpdateWithoutSmeInput, UserUncheckedUpdateWithoutSmeInput>
    create: XOR<UserCreateWithoutSmeInput, UserUncheckedCreateWithoutSmeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmeInput, UserUncheckedUpdateWithoutSmeInput>
  }

  export type UserUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutSmeInput, DocumentUncheckedUpdateWithoutSmeInput>
    create: XOR<DocumentCreateWithoutSmeInput, DocumentUncheckedCreateWithoutSmeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutSmeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutSmeInput, DocumentUncheckedUpdateWithoutSmeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutSmeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSmeInput>
  }

  export type DealUpsertWithWhereUniqueWithoutSmeInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutSmeInput, DealUncheckedUpdateWithoutSmeInput>
    create: XOR<DealCreateWithoutSmeInput, DealUncheckedCreateWithoutSmeInput>
  }

  export type DealUpdateWithWhereUniqueWithoutSmeInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutSmeInput, DealUncheckedUpdateWithoutSmeInput>
  }

  export type DealUpdateManyWithWhereWithoutSmeInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutSmeInput>
  }

  export type CertificationUpsertWithWhereUniqueWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutSmeInput, CertificationUncheckedUpdateWithoutSmeInput>
    create: XOR<CertificationCreateWithoutSmeInput, CertificationUncheckedCreateWithoutSmeInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutSmeInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutSmeInput, CertificationUncheckedUpdateWithoutSmeInput>
  }

  export type CertificationUpdateManyWithWhereWithoutSmeInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutSmeInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    smeId?: StringFilter<"Certification"> | string
    advisorId?: StringFilter<"Certification"> | string
    status?: EnumCertificationStatusFilter<"Certification"> | $Enums.CertificationStatus
    score?: FloatNullableFilter<"Certification"> | number | null
    comments?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutSmeInput, WorkflowUncheckedUpdateWithoutSmeInput>
    create: XOR<WorkflowCreateWithoutSmeInput, WorkflowUncheckedCreateWithoutSmeInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutSmeInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutSmeInput, WorkflowUncheckedUpdateWithoutSmeInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutSmeInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutSmeInput>
  }

  export type TenantCreateWithoutInvestorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvestorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvestorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
  }

  export type UserCreateWithoutInvestorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    advisor?: AdvisorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    advisor?: AdvisorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorCreateWithoutInvestorInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deal: DealCreateNestedOneWithoutInvestorsInput
  }

  export type DealInvestorUncheckedCreateWithoutInvestorInput = {
    id?: string
    dealId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorCreateOrConnectWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorCreateManyInvestorInputEnvelope = {
    data: DealInvestorCreateManyInvestorInput | DealInvestorCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutInvestorInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutInvestorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput>
  }

  export type WorkflowCreateManyInvestorInputEnvelope = {
    data: WorkflowCreateManyInvestorInput | WorkflowCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInvestorsInput = {
    update: XOR<TenantUpdateWithoutInvestorsInput, TenantUncheckedUpdateWithoutInvestorsInput>
    create: XOR<TenantCreateWithoutInvestorsInput, TenantUncheckedCreateWithoutInvestorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvestorsInput, TenantUncheckedUpdateWithoutInvestorsInput>
  }

  export type TenantUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutInvestorInput = {
    update: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
    create: XOR<UserCreateWithoutInvestorInput, UserUncheckedCreateWithoutInvestorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorInput, UserUncheckedUpdateWithoutInvestorInput>
  }

  export type UserUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DealInvestorUpsertWithWhereUniqueWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    update: XOR<DealInvestorUpdateWithoutInvestorInput, DealInvestorUncheckedUpdateWithoutInvestorInput>
    create: XOR<DealInvestorCreateWithoutInvestorInput, DealInvestorUncheckedCreateWithoutInvestorInput>
  }

  export type DealInvestorUpdateWithWhereUniqueWithoutInvestorInput = {
    where: DealInvestorWhereUniqueInput
    data: XOR<DealInvestorUpdateWithoutInvestorInput, DealInvestorUncheckedUpdateWithoutInvestorInput>
  }

  export type DealInvestorUpdateManyWithWhereWithoutInvestorInput = {
    where: DealInvestorScalarWhereInput
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyWithoutInvestorInput>
  }

  export type DealInvestorScalarWhereInput = {
    AND?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
    OR?: DealInvestorScalarWhereInput[]
    NOT?: DealInvestorScalarWhereInput | DealInvestorScalarWhereInput[]
    id?: StringFilter<"DealInvestor"> | string
    dealId?: StringFilter<"DealInvestor"> | string
    investorId?: StringFilter<"DealInvestor"> | string
    amount?: FloatFilter<"DealInvestor"> | number
    status?: EnumInvestmentStatusFilter<"DealInvestor"> | $Enums.InvestmentStatus
    createdAt?: DateTimeFilter<"DealInvestor"> | Date | string
    updatedAt?: DateTimeFilter<"DealInvestor"> | Date | string
  }

  export type WorkflowUpsertWithWhereUniqueWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutInvestorInput, WorkflowUncheckedUpdateWithoutInvestorInput>
    create: XOR<WorkflowCreateWithoutInvestorInput, WorkflowUncheckedCreateWithoutInvestorInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutInvestorInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutInvestorInput, WorkflowUncheckedUpdateWithoutInvestorInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutInvestorInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutInvestorInput>
  }

  export type TenantCreateWithoutAdvisorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAdvisorsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAdvisorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
  }

  export type UserCreateWithoutAdvisorInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sme?: SMECreateNestedOneWithoutUserInput
    investor?: InvestorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme?: SMEUncheckedCreateNestedOneWithoutUserInput
    investor?: InvestorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdvisorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationCreateWithoutAdvisorInput = {
    id?: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sme: SMECreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateWithoutAdvisorInput = {
    id?: string
    smeId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationCreateManyAdvisorInputEnvelope = {
    data: CertificationCreateManyAdvisorInput | CertificationCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutAdvisorInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    deal?: DealCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutAdvisorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput>
  }

  export type WorkflowCreateManyAdvisorInputEnvelope = {
    data: WorkflowCreateManyAdvisorInput | WorkflowCreateManyAdvisorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAdvisorsInput = {
    update: XOR<TenantUpdateWithoutAdvisorsInput, TenantUncheckedUpdateWithoutAdvisorsInput>
    create: XOR<TenantCreateWithoutAdvisorsInput, TenantUncheckedCreateWithoutAdvisorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAdvisorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAdvisorsInput, TenantUncheckedUpdateWithoutAdvisorsInput>
  }

  export type TenantUpdateWithoutAdvisorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAdvisorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAdvisorInput = {
    update: XOR<UserUpdateWithoutAdvisorInput, UserUncheckedUpdateWithoutAdvisorInput>
    create: XOR<UserCreateWithoutAdvisorInput, UserUncheckedCreateWithoutAdvisorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdvisorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdvisorInput, UserUncheckedUpdateWithoutAdvisorInput>
  }

  export type UserUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CertificationUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutAdvisorInput, CertificationUncheckedUpdateWithoutAdvisorInput>
    create: XOR<CertificationCreateWithoutAdvisorInput, CertificationUncheckedCreateWithoutAdvisorInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutAdvisorInput, CertificationUncheckedUpdateWithoutAdvisorInput>
  }

  export type CertificationUpdateManyWithWhereWithoutAdvisorInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type WorkflowUpsertWithWhereUniqueWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutAdvisorInput, WorkflowUncheckedUpdateWithoutAdvisorInput>
    create: XOR<WorkflowCreateWithoutAdvisorInput, WorkflowUncheckedCreateWithoutAdvisorInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutAdvisorInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutAdvisorInput, WorkflowUncheckedUpdateWithoutAdvisorInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutAdvisorInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutAdvisorInput>
  }

  export type TenantCreateWithoutDealsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDealsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDealsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
  }

  export type SMECreateWithoutDealsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDealsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDealsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
  }

  export type DealInvestorCreateWithoutDealInput = {
    id?: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutDealInvestmentsInput
  }

  export type DealInvestorUncheckedCreateWithoutDealInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorCreateOrConnectWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    create: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput>
  }

  export type DealInvestorCreateManyDealInputEnvelope = {
    data: DealInvestorCreateManyDealInput | DealInvestorCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDealInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    sme?: SMECreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutDealInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentCreateManyDealInputEnvelope = {
    data: DocumentCreateManyDealInput | DocumentCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutDealInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowsInput
    sme?: SMECreateNestedOneWithoutWorkflowsInput
    investor?: InvestorCreateNestedOneWithoutWorkflowsInput
    advisor?: AdvisorCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateOrConnectWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput>
  }

  export type WorkflowCreateManyDealInputEnvelope = {
    data: WorkflowCreateManyDealInput | WorkflowCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutDealsInput = {
    update: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDealsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type TenantUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutDealsInput = {
    update: XOR<SMEUpdateWithoutDealsInput, SMEUncheckedUpdateWithoutDealsInput>
    create: XOR<SMECreateWithoutDealsInput, SMEUncheckedCreateWithoutDealsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDealsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDealsInput, SMEUncheckedUpdateWithoutDealsInput>
  }

  export type SMEUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type DealInvestorUpsertWithWhereUniqueWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    update: XOR<DealInvestorUpdateWithoutDealInput, DealInvestorUncheckedUpdateWithoutDealInput>
    create: XOR<DealInvestorCreateWithoutDealInput, DealInvestorUncheckedCreateWithoutDealInput>
  }

  export type DealInvestorUpdateWithWhereUniqueWithoutDealInput = {
    where: DealInvestorWhereUniqueInput
    data: XOR<DealInvestorUpdateWithoutDealInput, DealInvestorUncheckedUpdateWithoutDealInput>
  }

  export type DealInvestorUpdateManyWithWhereWithoutDealInput = {
    where: DealInvestorScalarWhereInput
    data: XOR<DealInvestorUpdateManyMutationInput, DealInvestorUncheckedUpdateManyWithoutDealInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDealInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDealInput>
  }

  export type WorkflowUpsertWithWhereUniqueWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutDealInput, WorkflowUncheckedUpdateWithoutDealInput>
    create: XOR<WorkflowCreateWithoutDealInput, WorkflowUncheckedCreateWithoutDealInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutDealInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutDealInput, WorkflowUncheckedUpdateWithoutDealInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutDealInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutDealInput>
  }

  export type DealCreateWithoutInvestorsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutInvestorsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutInvestorsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
  }

  export type InvestorCreateWithoutDealInvestmentsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    workflows?: WorkflowCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutDealInvestmentsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutDealInvestmentsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
  }

  export type DealUpsertWithoutInvestorsInput = {
    update: XOR<DealUpdateWithoutInvestorsInput, DealUncheckedUpdateWithoutInvestorsInput>
    create: XOR<DealCreateWithoutInvestorsInput, DealUncheckedCreateWithoutInvestorsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutInvestorsInput, DealUncheckedUpdateWithoutInvestorsInput>
  }

  export type DealUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
  }

  export type InvestorUpsertWithoutDealInvestmentsInput = {
    update: XOR<InvestorUpdateWithoutDealInvestmentsInput, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
    create: XOR<InvestorCreateWithoutDealInvestmentsInput, InvestorUncheckedCreateWithoutDealInvestmentsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutDealInvestmentsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutDealInvestmentsInput, InvestorUncheckedUpdateWithoutDealInvestmentsInput>
  }

  export type InvestorUpdateWithoutDealInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutDealInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type TenantCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    workflows?: WorkflowCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
  }

  export type SMECreateWithoutDocumentsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutDocumentsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
  }

  export type DealCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    workflows?: WorkflowCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutDocumentsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
  }

  export type TenantUpsertWithoutDocumentsInput = {
    update: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type TenantUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutDocumentsInput = {
    update: XOR<SMEUpdateWithoutDocumentsInput, SMEUncheckedUpdateWithoutDocumentsInput>
    create: XOR<SMECreateWithoutDocumentsInput, SMEUncheckedCreateWithoutDocumentsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutDocumentsInput, SMEUncheckedUpdateWithoutDocumentsInput>
  }

  export type SMEUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type DealUpsertWithoutDocumentsInput = {
    update: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SMECreateWithoutCertificationsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    workflows?: WorkflowCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutCertificationsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutCertificationsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
  }

  export type AdvisorCreateWithoutCertificationsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    workflows?: WorkflowCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutCertificationsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutCertificationsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
  }

  export type SMEUpsertWithoutCertificationsInput = {
    update: XOR<SMEUpdateWithoutCertificationsInput, SMEUncheckedUpdateWithoutCertificationsInput>
    create: XOR<SMECreateWithoutCertificationsInput, SMEUncheckedCreateWithoutCertificationsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutCertificationsInput, SMEUncheckedUpdateWithoutCertificationsInput>
  }

  export type SMEUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type AdvisorUpsertWithoutCertificationsInput = {
    update: XOR<AdvisorUpdateWithoutCertificationsInput, AdvisorUncheckedUpdateWithoutCertificationsInput>
    create: XOR<AdvisorCreateWithoutCertificationsInput, AdvisorUncheckedCreateWithoutCertificationsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutCertificationsInput, AdvisorUncheckedUpdateWithoutCertificationsInput>
  }

  export type AdvisorUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type TenantCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    smes?: SMECreateNestedManyWithoutTenantInput
    investors?: InvestorCreateNestedManyWithoutTenantInput
    advisors?: AdvisorCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    domain?: string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    smes?: SMEUncheckedCreateNestedManyWithoutTenantInput
    investors?: InvestorUncheckedCreateNestedManyWithoutTenantInput
    advisors?: AdvisorUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWorkflowsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
  }

  export type SMECreateWithoutWorkflowsInput = {
    id?: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSmesInput
    user: UserCreateNestedOneWithoutSmeInput
    documents?: DocumentCreateNestedManyWithoutSmeInput
    deals?: DealCreateNestedManyWithoutSmeInput
    certifications?: CertificationCreateNestedManyWithoutSmeInput
  }

  export type SMEUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSmeInput
    deals?: DealUncheckedCreateNestedManyWithoutSmeInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutSmeInput
  }

  export type SMECreateOrConnectWithoutWorkflowsInput = {
    where: SMEWhereUniqueInput
    create: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
  }

  export type InvestorCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvestorsInput
    user: UserCreateNestedOneWithoutInvestorInput
    dealInvestments?: DealInvestorCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealInvestments?: DealInvestorUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutWorkflowsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
  }

  export type AdvisorCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAdvisorsInput
    user: UserCreateNestedOneWithoutAdvisorInput
    certifications?: CertificationCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    certifications?: CertificationUncheckedCreateNestedManyWithoutAdvisorInput
  }

  export type AdvisorCreateOrConnectWithoutWorkflowsInput = {
    where: AdvisorWhereUniqueInput
    create: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
  }

  export type DealCreateWithoutWorkflowsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    sme: SMECreateNestedOneWithoutDealsInput
    investors?: DealInvestorCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    tenantId: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investors?: DealInvestorUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutWorkflowsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
  }

  export type TenantUpsertWithoutWorkflowsInput = {
    update: XOR<TenantUpdateWithoutWorkflowsInput, TenantUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<TenantCreateWithoutWorkflowsInput, TenantUncheckedCreateWithoutWorkflowsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWorkflowsInput, TenantUncheckedUpdateWithoutWorkflowsInput>
  }

  export type TenantUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    smes?: SMEUpdateManyWithoutTenantNestedInput
    investors?: InvestorUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    smes?: SMEUncheckedUpdateManyWithoutTenantNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutTenantNestedInput
    advisors?: AdvisorUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SMEUpsertWithoutWorkflowsInput = {
    update: XOR<SMEUpdateWithoutWorkflowsInput, SMEUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<SMECreateWithoutWorkflowsInput, SMEUncheckedCreateWithoutWorkflowsInput>
    where?: SMEWhereInput
  }

  export type SMEUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: SMEWhereInput
    data: XOR<SMEUpdateWithoutWorkflowsInput, SMEUncheckedUpdateWithoutWorkflowsInput>
  }

  export type SMEUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSmesNestedInput
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type InvestorUpsertWithoutWorkflowsInput = {
    update: XOR<InvestorUpdateWithoutWorkflowsInput, InvestorUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<InvestorCreateWithoutWorkflowsInput, InvestorUncheckedCreateWithoutWorkflowsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutWorkflowsInput, InvestorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type InvestorUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvestorsNestedInput
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type AdvisorUpsertWithoutWorkflowsInput = {
    update: XOR<AdvisorUpdateWithoutWorkflowsInput, AdvisorUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<AdvisorCreateWithoutWorkflowsInput, AdvisorUncheckedCreateWithoutWorkflowsInput>
    where?: AdvisorWhereInput
  }

  export type AdvisorUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: AdvisorWhereInput
    data: XOR<AdvisorUpdateWithoutWorkflowsInput, AdvisorUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AdvisorUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAdvisorsNestedInput
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type DealUpsertWithoutWorkflowsInput = {
    update: XOR<DealUpdateWithoutWorkflowsInput, DealUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<DealCreateWithoutWorkflowsInput, DealUncheckedCreateWithoutWorkflowsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutWorkflowsInput, DealUncheckedUpdateWithoutWorkflowsInput>
  }

  export type DealUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    language?: $Enums.Language
    did?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SMECreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    sector: string
    stage: $Enums.SMEStage
    fundingRequired: number
    description?: string | null
    website?: string | null
    location?: string | null
    score?: number | null
    certified?: boolean
    certificationDate?: Date | string | null
    status?: $Enums.SMEStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorCreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    type: $Enums.InvestorType
    kycStatus?: $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvisorCreateManyTenantInput = {
    id?: string
    userId: string
    name: string
    specialization?: AdvisorCreatespecializationInput | string[]
    certificationList?: AdvisorCreatecertificationListInput | string[]
    status?: $Enums.AdvisorStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyTenantInput = {
    id?: string
    smeId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyTenantInput = {
    id?: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyTenantInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutUserNestedInput
    investor?: InvestorUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUncheckedUpdateOneWithoutUserNestedInput
    investor?: InvestorUncheckedUpdateOneWithoutUserNestedInput
    advisor?: AdvisorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    did?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMEUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSmeNestedInput
    documents?: DocumentUpdateManyWithoutSmeNestedInput
    deals?: DealUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSmeNestedInput
    deals?: DealUncheckedUpdateManyWithoutSmeNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutSmeNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutSmeNestedInput
  }

  export type SMEUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    stage?: EnumSMEStageFieldUpdateOperationsInput | $Enums.SMEStage
    fundingRequired?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certified?: BoolFieldUpdateOperationsInput | boolean
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSMEStatusFieldUpdateOperationsInput | $Enums.SMEStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorNestedInput
    dealInvestments?: DealInvestorUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealInvestments?: DealInvestorUncheckedUpdateManyWithoutInvestorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumInvestorTypeFieldUpdateOperationsInput | $Enums.InvestorType
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    preferences?: JsonNullValueInput | InputJsonValue
    portfolio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvisorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdvisorNestedInput
    certifications?: CertificationUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certifications?: CertificationUncheckedUpdateManyWithoutAdvisorNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAdvisorNestedInput
  }

  export type AdvisorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialization?: AdvisorUpdatespecializationInput | string[]
    certificationList?: AdvisorUpdatecertificationListInput | string[]
    status?: EnumAdvisorStatusFieldUpdateOperationsInput | $Enums.AdvisorStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManySmeInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    dealId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManySmeInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    amount: number
    equity?: number | null
    status?: $Enums.DealStatus
    successFee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateManySmeInput = {
    id?: string
    advisorId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManySmeInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    investors?: DealInvestorUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investors?: DealInvestorUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDealStatusFieldUpdateOperationsInput | $Enums.DealStatus
    successFee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advisor?: AdvisorUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    advisorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutSmeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyInvestorInput = {
    id?: string
    dealId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyInvestorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    advisorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneRequiredWithoutInvestorsNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyAdvisorInput = {
    id?: string
    smeId: string
    status?: $Enums.CertificationStatus
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyAdvisorInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    dealId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sme?: SMEUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    smeId?: StringFieldUpdateOperationsInput | string
    status?: EnumCertificationStatusFieldUpdateOperationsInput | $Enums.CertificationStatus
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    deal?: DealUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutAdvisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorCreateManyDealInput = {
    id?: string
    investorId: string
    amount: number
    status?: $Enums.InvestmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyDealInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.DocumentType
    url: string
    size: number
    mimeType: string
    smeId?: string | null
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowCreateManyDealInput = {
    id?: string
    tenantId: string
    type: $Enums.WorkflowType
    status?: $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: string | null
    investorId?: string | null
    advisorId?: string | null
    didWorkflowId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealInvestorUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutDealInvestmentsNestedInput
  }

  export type DealInvestorUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealInvestorUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvestmentStatusFieldUpdateOperationsInput | $Enums.InvestmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    sme?: SMEUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowsNestedInput
    sme?: SMEUpdateOneWithoutWorkflowsNestedInput
    investor?: InvestorUpdateOneWithoutWorkflowsNestedInput
    advisor?: AdvisorUpdateOneWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumWorkflowTypeFieldUpdateOperationsInput | $Enums.WorkflowType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    data?: JsonNullValueInput | InputJsonValue
    smeId?: NullableStringFieldUpdateOperationsInput | string | null
    investorId?: NullableStringFieldUpdateOperationsInput | string | null
    advisorId?: NullableStringFieldUpdateOperationsInput | string | null
    didWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SMECountOutputTypeDefaultArgs instead
     */
    export type SMECountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SMECountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorCountOutputTypeDefaultArgs instead
     */
    export type InvestorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisorCountOutputTypeDefaultArgs instead
     */
    export type AdvisorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealCountOutputTypeDefaultArgs instead
     */
    export type DealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SMEDefaultArgs instead
     */
    export type SMEArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SMEDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorDefaultArgs instead
     */
    export type InvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvisorDefaultArgs instead
     */
    export type AdvisorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvisorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealDefaultArgs instead
     */
    export type DealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealInvestorDefaultArgs instead
     */
    export type DealInvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealInvestorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificationDefaultArgs instead
     */
    export type CertificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefaultArgs instead
     */
    export type WorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}