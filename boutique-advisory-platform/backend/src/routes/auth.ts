import { Router, Request, Response } from 'express';
import bcrypt from 'bcryptjs';

import { COOKIE_OPTIONS, issueTokensAndSetCookies } from '../utils/auth-utils';
import { getTenantId } from '../utils/tenant-utils';
import jwt from 'jsonwebtoken';
import { prisma } from '../database';
import { Prisma } from '@prisma/client';
import {
  validatePasswordStrength,
  generateSecureToken,
  hashToken,
  logAuditEvent,
  isLockedOut,
  recordFailedAttempt,
  clearFailedAttempts,
  sanitizeEmail,
  encryptData,
  decryptData
} from '../utils/security';
import { isBreachedPassword } from '../utils/breached-passwords';
import { sendWelcomeEmail, sendPasswordResetEmail, sendVerificationEmail } from '../utils/email';
import { generateMfaSecret, generateQrCode, verifyMfaToken, generateBackupCodes } from '../utils/mfa';
import {
  authenticateToken,
  AuthenticatedRequest
} from '../middleware/jwt-auth';

const router = Router();

// Register endpoint
router.post('/register', async (req: Request, res: Response) => {
  try {
    const { email, password, role, firstName, lastName } = req.body;
    const clientIp = req.ip || req.socket.remoteAddress || 'unknown';
    const tenantId = getTenantId(req); // Derive tenantId server-side

    // Validate required fields
    if (!email || !password || !role || !firstName || !lastName) {
      return res.status(400).json({
        error: 'Missing required fields: email, password, role, firstName, lastName'
      });
    }

    // SECURITY: Sanitize and validate email
    const sanitizedEmail = sanitizeEmail(email);
    if (!sanitizedEmail) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    // SECURITY: Validate password strength
    const passwordError = validatePasswordStrength(password);
    if (passwordError) {
      return res.status(400).json({ error: passwordError });
    }

    // SECURITY: Check for breached passwords
    if (await isBreachedPassword(password)) {
      return res.status(400).json({
        error: 'This password has been found in a data breach and is unsafe to use. Please choose a different password.'
      });
    }

    // Check for active conflict (exact email match in this tenant)
    const activeUser = await prisma.user.findFirst({
      where: {
        email: { equals: sanitizedEmail, mode: 'insensitive' },
        tenantId,
        status: { not: 'DELETED' }
      }
    });

    if (activeUser) {
      // SECURITY: Log attempt to register with existing email
      await logAuditEvent({
        userId: 'anonymous',
        action: 'REGISTER_ATTEMPT',
        resource: 'user',
        details: { email: sanitizedEmail, reason: 'email_exists' },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Email already registered'
      });
      return res.status(409).json({
        error: 'User already exists with this email'
      });
    }

    // Archive any existing soft-deleted or legacy record to avoid unique index collision.
    // NOTE: Do not hard-delete users here because relational records can block deletion.
    const usersToPurge = await prisma.user.findMany({
      where: {
        tenantId,
        OR: [
          { email: { equals: sanitizedEmail, mode: 'insensitive' } },
          { email: { contains: sanitizedEmail, mode: 'insensitive' } }
        ]
      }
    });

    for (const u of usersToPurge) {
      if (u.status === 'DELETED' || u.status === 'INACTIVE' || u.email.toLowerCase().includes('deleted_')) {
        console.log(`[AUTH] Archiving record ${u.id} (${u.status}) to allow re-registration for ${sanitizedEmail}`);
        try {
          const archivedEmail = `deleted_${Date.now()}_${u.id}_${u.email}`;
          await prisma.user.update({
            where: { id: u.id },
            data: {
              status: 'DELETED' as any,
              email: archivedEmail
            }
          });
        } catch (e) {
          console.error(`[AUTH] Error archiving ${u.id}:`, e);
        }
      }
    }

    // Hash password with strong hashing
    const hashedPassword = await bcrypt.hash(password, 12);

    // SECURITY: Restrict roles for public registration to prevent privilege escalation
    // Roles like ADVISOR, ADMIN, and SUPER_ADMIN have elevated permissions and must be manually assigned
    const allowedPublicRoles = ['SME', 'INVESTOR'];
    if (!allowedPublicRoles.includes(role)) {
      await logAuditEvent({
        userId: 'anonymous',
        action: 'REGISTER_BLOCKED',
        resource: 'user',
        details: { email: sanitizedEmail, attemptedRole: role },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Unauthorized role registration'
      });
      return res.status(403).json({
        error: 'Unauthorized role. Please contact support for administrative access.'
      });
    }

    // Create user with Verification Token
    const verificationToken = generateSecureToken(32);
    const hashedVerificationToken = hashToken(verificationToken);
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    const user = await prisma.user.create({
      data: {
        email: sanitizedEmail,
        password: hashedPassword,
        role: role as any,
        firstName,
        lastName,
        tenantId,
        status: 'ACTIVE', // Require email verification logic if status is PENDING
        isEmailVerified: false,
        verificationToken: hashedVerificationToken,
        verificationTokenExpiry: verificationExpires,
        language: 'EN'
      }
    });

    // Create role-specific profile
    if (role === 'SME') {
      await prisma.sME.create({
        data: {
          userId: user.id,
          tenantId,
          name: `${firstName} ${lastName}`,
          sector: req.body.sector || 'General',
          stage: 'SEED',
          fundingRequired: req.body.fundingRequired || 0,
          status: 'DRAFT'
        }
      });
    } else if (role === 'INVESTOR') {
      await prisma.investor.create({
        data: {
          userId: user.id,
          tenantId,
          name: `${firstName} ${lastName}`,
          type: req.body.investorType || 'ANGEL',
          kycStatus: 'PENDING'
        }
      });
    } else if (role === 'ADVISOR') {
      await prisma.advisor.create({
        data: {
          userId: user.id,
          tenantId,
          name: `${firstName} ${lastName}`,
          specialization: req.body.specialization || ['General'],
          certificationList: req.body.certifications || [],
          status: 'ACTIVE'
        }
      });
    }

    // Send Verification Email (don't block registration if email fails)
    sendVerificationEmail(user.email, verificationToken)
      .catch(error => console.error('Failed to send verification email:', error));

    // Do NOT create an authenticated session before email verification.
    // Also clear any stale cookies in case user had a previous session.
    res.clearCookie('token', { ...COOKIE_OPTIONS, maxAge: 0 });
    res.clearCookie('accessToken', { ...COOKIE_OPTIONS, maxAge: 0 });
    res.clearCookie('refreshToken', { ...COOKIE_OPTIONS, path: '/api', maxAge: 0 });

    return res.status(201).json({
      message: 'User registered successfully. Please verify your email before logging in.',
      requiresEmailVerification: true,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        firstName: user.firstName,
        lastName: user.lastName,
        isEmailVerified: false
      }
    });
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
      return res.status(409).json({ error: 'User already exists with this email address' });
    }
    console.error('Registration error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Verify Email Endpoint
router.post('/verify-email', async (req: Request, res: Response) => {
  try {
    const { token } = req.body;
    if (!token) return res.status(400).json({ error: 'Token required' });

    const hashedToken = hashToken(token);

    const user = await prisma.user.findFirst({
      where: {
        verificationToken: hashedToken,
        verificationTokenExpiry: { gt: new Date() }
      }
    });

    if (!user) {
      return res.status(400).json({ error: 'Invalid or expired verification token' });
    }

    await prisma.user.update({
      where: { id: user.id },
      data: {
        isEmailVerified: true,
        verificationToken: null,
        verificationTokenExpiry: null
      }
    });

    return res.json({ message: 'Email verified successfully', success: true });
  } catch (error) {
    console.error('Email verification error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Resend Verification Email Endpoint
router.post('/resend-verification', async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }

    const sanitizedEmail = sanitizeEmail(email);
    if (!sanitizedEmail) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    // Rate limiting
    if (await isLockedOut(`resend_${sanitizedEmail}`)) {
      return res.status(429).json({ error: 'Too many requests. Please try again later.' });
    }

    const tenantId = getTenantId(req);
    const user = await prisma.user.findFirst({
      where: { email: sanitizedEmail, tenantId }
    });

    if (!user) {
      // Return success to avoid email enumeration
      return res.json({ message: 'If an account exists, a verification email has been sent.' });
    }

    if (user.isEmailVerified) {
      return res.status(400).json({ error: 'Email is already verified' });
    }

    // Generate new token
    const verificationToken = generateSecureToken(32);
    const hashedVerificationToken = hashToken(verificationToken);
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    await prisma.user.update({
      where: { id: user.id },
      data: {
        verificationToken: hashedVerificationToken,
        verificationTokenExpiry: verificationExpires
      }
    });

    // Send email
    sendVerificationEmail(user.email, verificationToken)
      .catch(error => console.error('Failed to send verification email:', error));

    // Record attempt for rate limiting
    await recordFailedAttempt(`resend_${sanitizedEmail}`);

    return res.json({ message: 'Verification email sent successfully.' });

  } catch (error) {
    console.error('Resend verification error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Login endpoint
router.post('/login', async (req: Request, res: Response) => {
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  try {
    const { email, password } = req.body;

    // Validate required fields
    if (!email || !password) {
      return res.status(400).json({
        error: 'Email and password are required'
      });
    }

    // SECURITY: Sanitize email
    const sanitizedEmail = sanitizeEmail(email);
    if (!sanitizedEmail) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    // SECURITY: Check for account lockout (brute force protection)
    const emailLocked = await isLockedOut(sanitizedEmail);
    const ipLocked = await isLockedOut(clientIp);
    if (emailLocked || ipLocked) {
      await logAuditEvent({
        userId: 'unknown',
        action: 'LOGIN_BLOCKED',
        resource: 'auth',
        details: { email: sanitizedEmail, reason: 'account_locked' },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Account temporarily locked'
      });
      return res.status(429).json({
        error: 'Too many failed attempts. Please try again in 15 minutes.'
      });
    }

    const tenantId = getTenantId(req);
    // Find user
    const user = await prisma.user.findFirst({
      where: { email: sanitizedEmail, tenantId }
    });

    if (!user) {
      // SECURITY: Record failed attempt but don't reveal if user exists
      await recordFailedAttempt(sanitizedEmail);
      await recordFailedAttempt(clientIp);
      await logAuditEvent({
        userId: 'unknown',
        action: 'LOGIN_FAILED',
        resource: 'auth',
        details: { email: sanitizedEmail },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Invalid credentials'
      });
      return res.status(401).json({
        error: 'Invalid credentials'
      });
    }

    // Check password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      // SECURITY: Record failed attempt
      await recordFailedAttempt(sanitizedEmail);
      await recordFailedAttempt(clientIp);
      await logAuditEvent({
        userId: user.id,
        action: 'LOGIN_FAILED',
        resource: 'auth',
        details: { email: sanitizedEmail },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Invalid password'
      });
      return res.status(401).json({
        error: 'Invalid credentials'
      });
    }

    // SECURITY: Check if email is verified
    // Allow SUPER_ADMIN to bypass this check to prevent lockout during setup
    // Removed ADMIN from bypass to enforce verification
    if (!user.isEmailVerified && user.role !== 'SUPER_ADMIN') {
      await logAuditEvent({
        userId: user.id,
        action: 'LOGIN_BLOCKED',
        resource: 'auth',
        details: { email: sanitizedEmail, reason: 'email_not_verified' },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Email not verified'
      });
      return res.status(403).json({
        error: 'Please verify your email address before logging in. Check your inbox for the verification link.'
      });
    }

    // SECURITY: Check if account is active
    if (user.status !== 'ACTIVE') {
      await logAuditEvent({
        userId: user.id,
        action: 'LOGIN_BLOCKED',
        resource: 'auth',
        details: { email: sanitizedEmail, status: user.status },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Account not active'
      });
      return res.status(403).json({
        error: 'Account is not active. Please contact support.'
      });
    }

    // SECURITY: Clear failed attempts on successful login
    await clearFailedAttempts(sanitizedEmail);
    await clearFailedAttempts(clientIp);

    // Generate JWT token
    if (!process.env.JWT_SECRET) {
      console.error('FATAL: JWT_SECRET environment variable is not set');
      return res.status(500).json({ error: 'Server configuration error' });
    }

    // 2FA Check (optionally enforce for Admin roles)
    const isAdmin = user.role === 'ADMIN' || user.role === 'SUPER_ADMIN';
    const enforceAdmin2fa = process.env.ENFORCE_ADMIN_2FA === 'true';
    if (user.twoFactorEnabled || (isAdmin && enforceAdmin2fa)) {
      if (!user.twoFactorEnabled && isAdmin && enforceAdmin2fa) {
        console.warn(`[SECURITY] Admin ${user.email} login attempt without MFA enabled. MFA is ENFORCED for admins.`);
        return res.status(403).json({
          error: '2FA is required for admin accounts. Please enable 2FA in settings or contact support.'
        });
      }
      const tempToken = jwt.sign(
        {
          userId: user.id,
          email: user.email,
          role: user.role,
          tenantId: user.tenantId,
          isPreAuth: true
        },
        process.env.JWT_SECRET,
        { expiresIn: '5m' } // Short expiration for 2FA entry
      );

      return res.status(200).json({
        message: '2FA verification required',
        require2fa: true,
        tempToken
      });
    }

    // Issue Access & Refresh tokens
    await issueTokensAndSetCookies(res, user, req);

    // SECURITY: Login Anomaly Detection (New IP)
    const previousSuccessLogin = await prisma.activityLog.findFirst({
      where: {
        userId: user.id,
        action: 'LOGIN_SUCCESS'
      }
    });

    if (previousSuccessLogin) {
      // User has logged in before, check if this IP is in history
      const thisIpPreviouslyUsed = await prisma.activityLog.findFirst({
        where: {
          userId: user.id,
          action: 'LOGIN_SUCCESS',
          metadata: {
            path: ['ip'],
            equals: clientIp
          }
        }
      });

      if (!thisIpPreviouslyUsed) {
        await logAuditEvent({
          userId: user.id,
          action: 'LOGIN_ANOMALY',
          resource: 'auth',
          details: { email: sanitizedEmail, reason: 'new_ip_detected', ip: clientIp },
          ipAddress: clientIp,
          success: true
        });
        console.warn(`[SECURITY] Login anomaly detected for ${user.email}: New IP ${clientIp}`);
      }
    }

    // SECURITY: Log successful login
    await logAuditEvent({
      userId: user.id,
      action: 'LOGIN_SUCCESS',
      resource: 'auth',
      details: { email: sanitizedEmail },
      ipAddress: clientIp,
      success: true
    });

    return res.status(200).json({
      message: 'Login successful',
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        firstName: user.firstName,
        lastName: user.lastName,
        twoFactorEnabled: user.twoFactorEnabled
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    await logAuditEvent({
      userId: 'unknown',
      action: 'LOGIN_ERROR',
      resource: 'auth',
      ipAddress: clientIp,
      success: false,
      errorMessage: error instanceof Error ? error.message : 'Unknown error'
    });
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Refresh Token Endpoint
router.post('/refresh', async (req: Request, res: Response) => {
  try {
    const refreshToken = req.cookies['refreshToken'];
    if (!refreshToken) {
      return res.status(401).json({ error: 'No refresh token provided' });
    }

    const tokenHash = hashToken(refreshToken);

    const storedToken = await prisma.refreshToken.findUnique({
      where: { token: tokenHash },
      include: { user: true }
    });

    if (!storedToken) {
      // Token might have been rotated and deleted?
      return res.status(401).json({ error: 'Invalid refresh token' });
    }

    if (storedToken.revoked || (storedToken.replacedByToken)) {
      // Reuse detection: Potentially revoke all tokens for this user
      // For now, just deny.
      await logAuditEvent({
        userId: storedToken.userId,
        action: 'TOKEN_REUSE_ATTEMPT',
        resource: 'auth',
        ipAddress: req.ip || req.socket.remoteAddress,
        success: false
      });
      return res.status(401).json({ error: 'Invalid refresh token (reused)' });
    }

    if (new Date() > storedToken.expiresAt) {
      // Cleanup expired
      await prisma.refreshToken.delete({ where: { id: storedToken.id } });
      return res.status(401).json({ error: 'Refresh token expired' });
    }

    // Valid token -> Rotate
    // Revoke old token (or delete) using db transaction if strict
    // We will just delete it to keep table small, or mark as replaced if keeping history
    // "Rotation" usually means new token replaces old.

    // Deleting old token prevents reuse (simple rotation)
    await prisma.refreshToken.delete({ where: { id: storedToken.id } });

    // Issue new tokens
    await issueTokensAndSetCookies(res, storedToken.user, req);

    return res.json({ message: 'Token refreshed' });

  } catch (error) {
    console.error('Refresh token error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Logout endpoint
router.post('/logout', async (req: Request, res: Response) => {
  const refreshToken = req.cookies['refreshToken'];
  if (refreshToken) {
    try {
      const tokenHash = hashToken(refreshToken);
      // Delete from DB to revoke
      await prisma.refreshToken.deleteMany({ // deleteMany ignores lookup error
        where: { token: tokenHash }
      });
    } catch (e) {
      console.error('Error revoking token on logout:', e);
    }
  }

  res.clearCookie('token', { ...COOKIE_OPTIONS, maxAge: 0 });
  res.clearCookie('accessToken', { ...COOKIE_OPTIONS, maxAge: 0 });
  res.clearCookie('refreshToken', { ...COOKIE_OPTIONS, path: '/api', maxAge: 0 });

  res.status(200).json({ message: 'Logged out successfully' });
});

// Get current user
router.get('/me', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const user = req.user;

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    return res.status(200).json({
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        firstName: user.firstName,
        lastName: user.lastName,
        twoFactorEnabled: user.twoFactorEnabled,
        language: user.language || 'EN',
        preferences: user.preferences
      }
    });
  } catch (error) {
    console.error('Get user error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user profile
router.put('/profile', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    const { firstName, lastName, language, preferences } = req.body;

    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Validate inputs
    if (firstName && firstName.length > 100) return res.status(400).json({ error: 'First name too long' });
    if (lastName && lastName.length > 100) return res.status(400).json({ error: 'Last name too long' });

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        ...(firstName && { firstName }),
        ...(lastName && { lastName }),
        ...(language && { language: language.toUpperCase() as any }), // Convert to uppercase for Enum match
        ...(preferences && { preferences: preferences as any }),
      }
    });

    return res.json({
      id: updatedUser.id,
      email: updatedUser.email,
      role: updatedUser.role,
      firstName: updatedUser.firstName,
      lastName: updatedUser.lastName,
      twoFactorEnabled: updatedUser.twoFactorEnabled,
      language: updatedUser.language,
      preferences: updatedUser.preferences
    });
  } catch (error) {
    console.error('Update profile error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Forgot password endpoint
router.post('/forgot-password', async (req: Request, res: Response) => {
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }

    // SECURITY: Sanitize email
    const sanitizedEmail = sanitizeEmail(email);
    if (!sanitizedEmail) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    // SECURITY: Rate limit password reset requests
    if (await isLockedOut(`reset_${sanitizedEmail}`)) {
      return res.status(429).json({
        error: 'Too many password reset requests. Please try again later.'
      });
    }

    const tenantId = getTenantId(req);
    const user = await prisma.user.findFirst({
      where: { email: sanitizedEmail, tenantId }
    });

    // SECURITY: Always return success message to prevent email enumeration
    // But only generate token if user exists
    if (user) {
      // Generate secure reset token
      const resetToken = generateSecureToken(32);
      const hashedResetToken = hashToken(resetToken);
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour expiry

      // Store hashed token in user record
      await prisma.user.update({
        where: { id: user.id },
        data: {
          resetToken: hashedResetToken,
          resetTokenExpiry: expiresAt
        }
      });

      await logAuditEvent({
        userId: user.id,
        action: 'PASSWORD_RESET_REQUESTED',
        resource: 'auth',
        details: {
          email: sanitizedEmail,
          tokenHash: hashedResetToken.substring(0, 10) + '...',
          expiresAt: expiresAt.toISOString()
        },
        ipAddress: clientIp,
        success: true
      });

      // Send password reset email (don't block response if email fails)
      sendPasswordResetEmail(user.email, resetToken)
        .catch(error => console.error('Failed to send password reset email:', error));
    } else {
      // Log attempt for non-existent user (for security monitoring)
      await logAuditEvent({
        userId: 'unknown',
        action: 'PASSWORD_RESET_UNKNOWN_EMAIL',
        resource: 'auth',
        details: { email: sanitizedEmail },
        ipAddress: clientIp,
        success: false
      });
    }

    // Always return same response to prevent email enumeration
    return res.json({
      message: 'If an account exists with this email, a password reset link has been sent.',
      success: true
    });
  } catch (error) {
    console.error('Forgot password error:', error);
    await logAuditEvent({
      userId: 'unknown',
      action: 'PASSWORD_RESET_ERROR',
      resource: 'auth',
      ipAddress: clientIp,
      success: false,
      errorMessage: error instanceof Error ? error.message : 'Unknown error'
    });
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Reset password endpoint
router.post('/reset-password', async (req: Request, res: Response) => {
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  try {
    const { token, password } = req.body;

    if (!token || !password) {
      return res.status(400).json({ error: 'Token and new password are required' });
    }

    // SECURITY: Validate password strength
    const passwordError = validatePasswordStrength(password);
    if (passwordError) {
      return res.status(400).json({ error: passwordError });
    }

    // SECURITY: Check for breached passwords
    if (await isBreachedPassword(password)) {
      return res.status(400).json({
        error: 'This password has been found in a data breach and is unsafe to use. Please choose a different password.'
      });
    }

    // Hash the provided token to compare with stored hash
    const hashedToken = hashToken(token);

    // In production: Look up the hashed token in the database
    // For now, we'll validate the token format
    if (token.length !== 64) { // 32 bytes = 64 hex characters
      await logAuditEvent({
        userId: 'unknown',
        action: 'PASSWORD_RESET_INVALID_TOKEN',
        resource: 'auth',
        details: { tokenLength: token.length },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Invalid token format'
      });
      return res.status(400).json({ error: 'Invalid or expired reset token' });
    }

    // Verify token exists and is not expired
    const user = await prisma.user.findFirst({
      where: {
        resetToken: hashedToken,
        resetTokenExpiry: {
          gt: new Date()
        }
      }
    });

    if (!user) {
      await logAuditEvent({
        userId: 'unknown',
        action: 'PASSWORD_RESET_INVALID_TOKEN',
        resource: 'auth',
        details: { tokenHash: hashedToken.substring(0, 10) + '...' },
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Token not found or expired'
      });
      return res.status(400).json({ error: 'Invalid or expired reset token' });
    }

    // Has valid token, update password
    const hashedPassword = await bcrypt.hash(password, 12);

    await prisma.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        resetToken: null,       // Invalidate token
        resetTokenExpiry: null
      }
    });

    // SECURITY: Revoke all refresh tokens on password reset
    await prisma.refreshToken.deleteMany({
      where: { userId: user.id }
    });

    await logAuditEvent({
      userId: user.id,
      action: 'PASSWORD_RESET_SUCCESS',
      resource: 'auth',
      details: { email: user.email },
      ipAddress: clientIp,
      success: true
    });

    // Clear any failed login attempts for this user
    await clearFailedAttempts(user.email);

    return res.json({
      message: 'Password has been reset successfully.',
      success: true
    });
  } catch (error) {
    const clientIp = req.ip || req.socket.remoteAddress || 'unknown';
    console.error('Reset password error:', error);
    await logAuditEvent({
      userId: 'unknown',
      action: 'PASSWORD_RESET_ERROR',
      resource: 'auth',
      ipAddress: clientIp,
      success: false,
      errorMessage: error instanceof Error ? error.message : 'Unknown error'
    });
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Change password endpoint (for authenticated users)
router.post('/change-password', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  try {
    const { currentPassword, newPassword } = req.body;
    const user = req.user;

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Verify current password
    const isValidPassword = await bcrypt.compare(currentPassword, user.password);
    if (!isValidPassword) {
      await logAuditEvent({
        userId: user.id,
        action: 'PASSWORD_CHANGE_FAILED',
        resource: 'auth',
        ipAddress: clientIp,
        success: false,
        errorMessage: 'Invalid current password'
      });
      return res.status(401).json({ error: 'Current password is incorrect' });
    }

    // SECURITY: Validate new password strength
    const passwordError = validatePasswordStrength(newPassword);
    if (passwordError) {
      return res.status(400).json({ error: passwordError });
    }

    // SECURITY: Check for breached passwords
    if (await isBreachedPassword(newPassword)) {
      return res.status(400).json({
        error: 'This password has been found in a data breach and is unsafe to use. Please choose a different password.'
      });
    }

    // Update password
    const hashedPassword = await bcrypt.hash(newPassword, 12);
    await prisma.user.update({
      where: { id: user.id },
      data: { password: hashedPassword }
    });

    // SECURITY: Revoke all refresh tokens on password change
    await prisma.refreshToken.deleteMany({
      where: { userId: user.id }
    });

    await logAuditEvent({
      userId: user.id,
      action: 'PASSWORD_CHANGE_SUCCESS',
      resource: 'auth',
      ipAddress: clientIp,
      success: true
    });

    return res.json({
      message: 'Password changed successfully',
      success: true
    });

  } catch (error) {
    console.error('Change password error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// ==================== 2FA ENDPOINTS ====================

// Verify 2FA during Login
router.post('/verify-2fa', async (req: Request, res: Response) => {
  const { tempToken, code } = req.body;
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  if (!tempToken || !code) {
    return res.status(400).json({ error: 'Token and code are required' });
  }

  try {
    if (!process.env.JWT_SECRET) return res.status(500).json({ error: 'Config error' });

    // Verify temp token
    const decoded = jwt.verify(tempToken, process.env.JWT_SECRET) as any;

    // Ensure it is a pre-auth token
    if (!decoded.isPreAuth) {
      return res.status(400).json({ error: 'Invalid token usage' });
    }

    const user = await prisma.user.findUnique({ where: { id: decoded.userId } });

    if (!user || !user.twoFactorEnabled || !user.twoFactorSecret) {
      return res.status(400).json({ error: '2FA not enabled or configured' });
    }

    let secret = user.twoFactorSecret;
    try {
      if (user.twoFactorSecret.includes(':')) {
        secret = decryptData(user.twoFactorSecret);
      }
    } catch (e) {
      // Fallback for legacy plaintext secrets or if decryption fails
      console.warn('Using fallback plaintext 2FA secret for user', user.id);
    }

    let verified = verifyMfaToken(secret, code);
    let usedBackupCode = false;

    if (!verified && user.twoFactorBackupCodes && user.twoFactorBackupCodes.length > 0) {
      // Check backup codes
      for (const hashedCode of user.twoFactorBackupCodes) {
        const isMatch = await bcrypt.compare(code, hashedCode);
        if (isMatch) {
          verified = true;
          usedBackupCode = true;

          // Remove used backup code (SECURITY best practice)
          const updatedCodes = user.twoFactorBackupCodes.filter(c => c !== hashedCode);
          await prisma.user.update({
            where: { id: user.id },
            data: { twoFactorBackupCodes: updatedCodes }
          });

          await logAuditEvent({
            userId: user.id,
            action: 'LOGIN_MFA_BACKUP',
            resource: 'user',
            details: { remaining: updatedCodes.length },
            ipAddress: clientIp,
            success: true
          });
          break;
        }
      }
    }

    if (!verified) {
      await logAuditEvent({
        userId: user.id,
        action: 'LOGIN_MFA_FAIL',
        resource: 'user',
        details: { reason: 'invalid_code' },
        ipAddress: clientIp,
        success: false
      });
      return res.status(401).json({ error: 'Invalid 2FA code' });
    }

    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    // SECURITY: Revoke all other refresh tokens for this user upon 2FA successful login
    // This ensures only the new session is active if that's the desired security posture,
    // or at least ensures that tokens issued during the pre-auth phase are gone.
    // Actually, issueTokensAndSetCookies already issues new ones.
    // Usually we want to revoke OLD tokens when a new 2FA login happens.
    await prisma.refreshToken.deleteMany({
      where: {
        userId: user.id,
        // We might want to keep the one we JUST issued, but issueTokensAndSetCookies
        // adds it to the DB. So we should probably do this BEFORE issueTokensAndSetCookies
        // or exclude the current one.
      }
    });

    // Issue Access & Refresh tokens
    await issueTokensAndSetCookies(res, user, req);

    await logAuditEvent({
      userId: user.id,
      action: 'LOGIN_SUCCESS',
      resource: 'auth',
      details: { method: '2FA' },
      ipAddress: clientIp,
      success: true
    });

    return res.json({
      message: 'Login successful',
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        firstName: user.firstName,
        lastName: user.lastName,
        twoFactorEnabled: true
      }
    });

  } catch (error) {
    console.error('2FA Verify Error:', error);
    return res.status(401).json({ error: 'Invalid or expired session' });
  }
});

// Setup 2FA (Generate Secret)
router.post('/2fa/setup', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const user = req.user;
    if (user.twoFactorEnabled) {
      return res.status(400).json({ error: '2FA is already enabled' });
    }

    const secret = generateMfaSecret(user.email);
    if (!secret.otpauth_url) {
      return res.status(500).json({ error: 'Failed to generate 2FA secret URL' });
    }
    const qrCode = await generateQrCode(secret.otpauth_url);

    // Return secret to client (client must send it back to confirm)
    // We do NOT save it to DB yet to prevent lockout if they fail to scan
    return res.json({
      secret: secret.base32,
      qrCode
    });

  } catch (error) {
    console.error('2FA Setup Error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Activate 2FA (Verify and Save)
router.post('/2fa/activate', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  const { code, secret } = req.body;
  const user = req.user;

  if (!code || !secret) {
    return res.status(400).json({ error: 'Code and secret are required' });
  }

  try {
    const isValid = verifyMfaToken(secret, code);

    if (!isValid) {
      return res.status(400).json({ error: 'Invalid code. Please try again.' });
    }

    // Generate backup codes
    const backupCodes = generateBackupCodes(); // Assuming this function exists and generates an array of plaintext codes
    const hashedBackupCodes = await Promise.all(backupCodes.map(code => bcrypt.hash(code, 12)));

    await prisma.user.update({
      where: { id: user.id },
      data: {
        twoFactorEnabled: true,
        twoFactorSecret: encryptData(secret),
        twoFactorBackupCodes: hashedBackupCodes
      }
    });

    // SECURITY: Revoke all existing sessions when 2FA is enabled
    // This forces all devices to re-login with the new 2FA requirement
    await prisma.refreshToken.deleteMany({
      where: { userId: user.id }
    });

    await logAuditEvent({
      userId: user.id,
      action: '2FA_ENABLED',
      resource: 'auth',
      ipAddress: req.ip || 'unknown',
      success: true
    });

    return res.json({
      message: 'Two-factor authentication enabled successfully',
      success: true,
      backupCodes
    });

  } catch (error) {
    console.error('2FA Activation Error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Disable 2FA
router.post('/2fa/disable', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  const { password } = req.body; // Require password to disable
  const user = req.user;

  if (!password) {
    return res.status(400).json({ error: 'Password required' });
  }

  try {
    // Verify user exists and check password
    const dbUser = await prisma.user.findUnique({ where: { id: user.id } });
    if (!dbUser) return res.status(404).json({ error: 'User not found' });

    const validPassword = await bcrypt.compare(password, dbUser.password);
    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid password' });
    }

    await prisma.user.update({
      where: { id: user.id },
      data: {
        twoFactorEnabled: false,
        twoFactorSecret: null
      }
    });

    // SECURITY: Revoke all refresh tokens when 2FA is disabled
    await prisma.refreshToken.deleteMany({
      where: { userId: user.id }
    });

    await logAuditEvent({
      userId: user.id,
      action: '2FA_DISABLED',
      resource: 'auth',
      ipAddress: req.ip || 'unknown',
      success: true
    });

    return res.json({ message: 'Two-factor authentication disabled' });

  } catch (error) {
    console.error('2FA Disable Error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete account (Soft Delete)
router.post('/delete-account', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  const clientIp = req.ip || req.socket.remoteAddress || 'unknown';

  try {
    const user: any = req.user;

    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    // New unique email to free up the original email
    // Format: deleted_<timestamp>_<original_email>
    const timestamp = Date.now();
    const deletedEmail = `deleted_${timestamp}_${user.email}`;

    // Transaction to update user and related profiles
    await prisma.$transaction(async (tx) => {
      // 1. Update User Record
      await tx.user.update({
        where: { id: user.id },
        data: {
          status: 'DELETED' as any, // Soft delete
          email: deletedEmail,
          firstName: 'Deleted',
          lastName: 'User',
          password: `deleted_${timestamp}`, // Scramble password
          twoFactorSecret: null,
          twoFactorEnabled: false,
          did: null, // Remove DID link
          resetToken: null,
          resetTokenExpiry: null
        }
      });

      // 1.25 SECURITY: Revoke all refresh tokens
      await tx.refreshToken.deleteMany({
        where: { userId: user.id }
      });

      // 1.5 Purge Push Subscriptions to prevent notification leakage
      await tx.pushSubscription.deleteMany({
        where: { userId: user.id }
      });

      // 2. Anonymize Linked Profiles based on Role

      // Anonymize SME Profile if exists
      if (user.role === 'SME') {
        const sme = await tx.sME.findFirst({ where: { userId: user.id, tenantId: user.tenantId } });
        if (sme) {
          await tx.sME.update({
            where: { id: sme.id },
            data: {
              name: `Deleted Company ${timestamp}`,
              description: 'This account has been deleted.',
              website: null,
              location: null,
              status: 'REJECTED'
            }
          });
        }
      }

      // Anonymize Investor Profile if exists
      if (user.role === 'INVESTOR') {
        const investor = await tx.investor.findFirst({ where: { userId: user.id, tenantId: user.tenantId } });
        if (investor) {
          await tx.investor.update({
            where: { id: investor.id },
            data: {
              name: `Deleted Investor ${timestamp}`,
              type: 'ANGEL',
              preferences: {},
              kycStatus: 'REJECTED'
            }
          });
        }
      }

      // Anonymize Advisor Profile if exists
      if (user.role === 'ADVISOR') {
        const advisor = await tx.advisor.findFirst({ where: { userId: user.id, tenantId: user.tenantId } });
        if (advisor) {
          await tx.advisor.update({
            where: { id: advisor.id },
            data: {
              name: `Deleted Advisor ${timestamp}`,
              status: 'SUSPENDED'
            }
          });
        }
      }
    });

    await logAuditEvent({
      userId: user.id,
      action: 'ACCOUNT_DELETED',
      resource: 'user',
      details: {
        originalEmail: user.email,
        newEmail: deletedEmail
      },
      ipAddress: clientIp,
      success: true
    });

    return res.json({
      message: 'Account deleted successfully. You have been logged out.',
      success: true
    });

  } catch (error: any) {
    console.error('Delete account error:', error);
    await logAuditEvent({
      userId: req.user?.id || 'unknown',
      action: 'ACCOUNT_DELETE_ERROR',
      resource: 'user',
      ipAddress: clientIp,
      success: false,
      errorMessage: error instanceof Error ? error.message : 'Unknown error'
    });
    return res.status(500).json({ error: 'Internal server error' });
  }
});


// Switch Role Endpoint
// Switch Role Endpoint
router.post('/switch-role', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const { targetRole } = req.body;

    if (!['SME', 'INVESTOR'].includes(targetRole)) {
      return res.status(400).json({ error: 'Invalid target role. Can only switch between SME and INVESTOR.' });
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { sme: true, investor: true }
    });

    if (!user) return res.status(404).json({ error: 'User not found' });

    // logic to ensure profile exists
    if (targetRole === 'INVESTOR') {
      if (!user.investor) {
        // Create Investor Profile
        await prisma.investor.create({
          data: {
            userId: user.id,
            tenantId: user.tenantId,
            name: `${user.firstName} ${user.lastName}`,
            type: 'ANGEL', // Default
            kycStatus: 'PENDING'
          }
        });
      }
    } else if (targetRole === 'SME') {
      if (!user.sme) {
        // Create SME Profile
        await prisma.sME.create({
          data: {
            userId: user.id,
            tenantId: user.tenantId,
            name: `${user.firstName} ${user.lastName}`,
            sector: 'General',
            stage: 'SEED',
            fundingRequired: 0,
            status: 'DRAFT'
          }
        });
      }
    }

    // Update User Role
    const updatedUser = await prisma.user.update({
      where: { id: user.id },
      data: { role: targetRole as any }
    });

    // Issue Access & Refresh tokens
    await issueTokensAndSetCookies(res, updatedUser, req);

    return res.json({
      message: `Successfully switched to ${targetRole}`,
      user: {
        id: updatedUser.id,
        email: updatedUser.email,
        role: updatedUser.role,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        twoFactorEnabled: updatedUser.twoFactorEnabled
      }
    });

  } catch (error) {
    console.error('Switch role error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * List active sessions for the current user
 */
router.get('/sessions', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const user = req.user;
    if (!user) return res.status(401).json({ error: 'Unauthorized' });

    const currentRefreshToken = req.cookies?.['refreshToken'];
    let currentSessionId: string | null = null;
    if (currentRefreshToken) {
      const currentTokenHash = hashToken(currentRefreshToken);
      const currentSession = await prisma.refreshToken.findUnique({
        where: { token: currentTokenHash },
        select: { id: true, userId: true }
      });
      if (currentSession && currentSession.userId === user.id) {
        currentSessionId = currentSession.id;
      }
    }

    const sessions = await prisma.refreshToken.findMany({
      where: { userId: user.id },
      select: {
        id: true,
        ipAddress: true,
        userAgent: true,
        createdAt: true,
        expiresAt: true
      },
      orderBy: { createdAt: 'desc' }
    });

    return res.json({ sessions, currentSessionId });
  } catch (error) {
    console.error('List sessions error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * Revoke a specific session
 */
router.delete('/sessions/:id', authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const user = req.user;
    if (!user) return res.status(401).json({ error: 'Unauthorized' });

    const sessionId = req.params.id;

    // Ensure session belongs to user
    const session = await prisma.refreshToken.findFirst({
      where: { id: sessionId, userId: user.id },
      select: { id: true, token: true }
    });

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    await prisma.refreshToken.delete({
      where: { id: sessionId }
    });

    const currentRefreshToken = req.cookies?.['refreshToken'];
    if (currentRefreshToken && session.token === hashToken(currentRefreshToken)) {
      // If user revoked the current device session, clear local auth cookies immediately.
      res.clearCookie('token', { ...COOKIE_OPTIONS, maxAge: 0 });
      res.clearCookie('accessToken', { ...COOKIE_OPTIONS, maxAge: 0 });
      res.clearCookie('refreshToken', { ...COOKIE_OPTIONS, path: '/api', maxAge: 0 });
    }

    return res.json({ message: 'Session revoked successfully' });
  } catch (error) {
    console.error('Revoke session error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
